<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>MQTT on Standing on the Shoulder of Giants</title><link>https://www.jonathanlin.top/tags/mqtt/</link><description>Recent content in MQTT on Standing on the Shoulder of Giants</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright>Copyright © {year} Jonathan Lin. All rights reserved.</copyright><lastBuildDate>Tue, 06 Jun 2023 16:33:29 +0800</lastBuildDate><atom:link href="https://www.jonathanlin.top/tags/mqtt/index.xml" rel="self" type="application/rss+xml"/><item><title>MQTT控制报文</title><link>https://www.jonathanlin.top/posts/mqtt-note-03/</link><pubDate>Tue, 06 Jun 2023 16:33:29 +0800</pubDate><guid>https://www.jonathanlin.top/posts/mqtt-note-03/</guid><description>
&lt;h3 id="控制报文结构">控制报文结构&lt;/h3>
&lt;p>MQTT 控制报文由三部分组成，按照 下图描述的顺序:&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jonlimx/blogs@main/image/image-20220224155932690.png" alt="MQTT控制报文">&lt;/p>
&lt;h3 id="固定报头">固定报头&lt;/h3>
&lt;p>每个 MQTT 控制报文都包含一个固定报头。下图描述了固定报头的格式，固定报头的第一字节是固定的，用于表示控制报文类型和标志位，不再赘述请参考 &lt;a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html">MQTT协议规范&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jonlimx/blogs@main/image/image-20220224155952188.png" alt="固定头部">&lt;/p>
&lt;p>紧接的是&lt;strong>剩余长度&lt;/strong>这里重点记录一下剩余长度的含义以及计算方式。&lt;/p>
&lt;h3 id="剩余长度">剩余长度&lt;/h3>
&lt;p>**剩余长度(Remaining Length)**表示当前报文剩余部分的字节数，&lt;strong>包括可变报头(Variable header)和负载(Payload)的数据&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>剩余长度字段使用一个变长度编码方案，从byte2开始，最多可达4个字节，也就是说可能用byte2~byte5来编码表示剩余长度&lt;/li>
&lt;li>对于小于128的值使用单字节编码，大于128的值使用低7位编码数据，最高位指示后续是否有更多的字节&lt;/li>
&lt;/ul>
&lt;p>展开来说：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>byte2 ~ byte 5&lt;/th>
&lt;th>二进制&lt;/th>
&lt;th>解释&lt;/th>
&lt;th>剩余长度最小值&lt;/th>
&lt;th>剩余长度最大值&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>byte2&lt;/td>
&lt;td>0XXX XXXX&lt;/td>
&lt;td>高位为0，仅byte2用于编码剩余长度&lt;/td>
&lt;td>0 (0x00)&lt;/td>
&lt;td>127 (0x7F)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>byte2byte3&lt;/td>
&lt;td>1XXX XXXX 0XXX XXXX&lt;/td>
&lt;td>高位为1，byte2和byte3用于编码剩余长度&lt;/td>
&lt;td>128 (0x80, 0x01)&lt;/td>
&lt;td>16 383 (0xFF, 0x7F)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>byte2byte3byte4&lt;/td>
&lt;td>1XXX XXXX 1XXX XXXX 0XXX XXXX&lt;/td>
&lt;td>byte2和byte3的高位为1，byte2，byte3和byte4用于编码剩余长度&lt;/td>
&lt;td>16384 (0x80, 0x80, 0x01)&lt;/td>
&lt;td>2097151 (0xFF, 0xFF, 0x7F)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Byte2byte3byte4byte5&lt;/td>
&lt;td>1XXX XXXX 1XXX XXXX 1XXX XXXX 0XXX XXXX&lt;/td>
&lt;td>byte2，byte3和byte4的高位为1，byte2，byte3，byte4和byte5用于编码剩余长度&lt;/td>
&lt;td>2097152 (0x80, 0x80, 0x80, 0x01)&lt;/td>
&lt;td>268435455 (0xFF, 0xFF, 0xFF, 0x7F)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>
&lt;p>剩余长度不包括用于编码剩余长度字段本身的字节数&lt;/p>
&lt;/li>
&lt;li>
&lt;p>剩余长度单位是字节&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于byte2~byte5，计算剩余长度数值的时候，遵循以下的算法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">&lt;span class="n">len&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">byte5&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">16&lt;/span>&lt;span class="err">进制&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;amp;~&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x80&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">128&lt;/span>&lt;span class="o">^&lt;/span>&lt;span class="mi">3&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nf">byte4&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">16&lt;/span>&lt;span class="err">进制&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;amp;~&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x80&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">128&lt;/span>&lt;span class="o">^&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nf">byte3&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">16&lt;/span>&lt;span class="err">进制&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;amp;~&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x80&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">128&lt;/span>&lt;span class="o">^&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nf">byte2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">16&lt;/span>&lt;span class="err">进制&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;amp;~&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x80&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">128&lt;/span>&lt;span class="o">^&lt;/span>&lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以剩余长度最大值0xFF, 0xFF, 0xFF, 0x7F，计算过程如下：&lt;/p>
&lt;ul>
&lt;li>0xFF - 对于byte2~byte5，最高位是标记位，不能参与计算，去掉最高位就是0X7F（0111 1111），对应十进制127&lt;/li>
&lt;li>公式里的 bytex(16进制)&amp;amp;~(0x80)目的就是去掉最高位标记位&lt;/li>
&lt;li>套用上面的公式：&lt;code>127*128^3 + 127*128^2 + 127*128 + 127 = 268435455 bytes = 256MB&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="mqtt控制报文">MQTT控制报文&lt;/h3>
&lt;p>可变报头位于剩余长度和Payload之间。可变不是可选（optional）的意思，可变报头的内容根据报文类型的不同而不同。具体取决于报文类型，有的类型包含可变报头，有的没有。&lt;/p>
&lt;h4 id="connect---连接服务端broker">CONNECT - 连接服务端（Broker）&lt;/h4>
&lt;p>&lt;strong>可变报头&lt;/strong>&lt;/p>
&lt;p>包括：协议名长度（Protocol Name Length）、 协议名（Protocol Name)、协议级别（Protocol Level/Version），连接标志（Connection Flags）和保持连接（Keep Alive）&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jonlimx/blogs@main/image/image-20230224171541298.png" alt="CONNECT报文">&lt;/p>
&lt;blockquote>
&lt;p>由于v3.1.1版本的Version对应的值是4，这也是MQTT5的由来&lt;/p>
&lt;/blockquote>
&lt;p>连接标志位（Connection Flags）各bit含义如下：&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jonlimx/blogs@main/image/image-20230308142402425.png" alt="Connection Flags">&lt;/p>
&lt;blockquote>
&lt;p>1 - Clean Session：会话清除标志位。当设置为0时，服务端必须基于当前会话（通过客户端标识符识别）的状态恢复与客户端的通信，即持久化会话。持久化会话只对QoS为1或者2 的消息有效，客户端和服务端需要将QoS1和2的消息保存为会话的一部分；当设置为1时，客户端和服务端必须丢弃之前任何会话并开始一个新的会话 (&lt;strong>保留消息不是服务端会话状态的一部分，会话终止时不能删除保留信息&lt;/strong>)&lt;/p>
&lt;p>2 - Will Flag：遗嘱标志。这个是和Will Retain和Will QoS一起使用的。当遗嘱标志位0时，这几个都要置0，表明网络断开的时候不能发送医嘱信息；当遗嘱标志位设置为1时&lt;/p>
&lt;p>3/4 - Will QoS：遗嘱消息QoS，值为0,1和2&lt;/p>
&lt;p>5 - Will Retain：遗嘱保留&lt;/p>
&lt;p>6 - Password Flag：密码标志，标识有效载荷中是否包含用户密码&lt;/p>
&lt;p>7 - User Name Flag：用户名标志，标识有效载荷中是否包含用户名&lt;/p>
&lt;/blockquote>
&lt;p>保持连接（Keep Alive）：以秒为单位的时间间隔，是指在客户端传输完成一个控制报文的时刻到发送下一个报文的时刻，两者之间允许空闲的最大时间间隔。&lt;/p>
&lt;p>对于Keep Alive机制：&lt;/p>
&lt;ul>
&lt;li>MQTT 协议中约定 - 在 1.5*Keep Alive 的时间间隔内，如果 Broker 没有收到来自 Client 的任何数据包，那么 Broker 认为它和 Client 之间的连接已经断开；同样地, 如果 Client 没有收到来自 Broker 的任何数据包，那么 Client 认为它和 Broker 之间的连接已经断开&lt;/li>
&lt;li>如果在一个Keep Alive时间间隔内，Client和Broker有过数据包传输（比如PUBLISH），Client 就没有必要再使用 PINGREQ了。在网络资源比较紧张的情况下这点很重要&lt;/li>
&lt;li>Keep Alive 值是由 Client 指定的，不同的 Client 可以指定不同的值&lt;/li>
&lt;li>Keep Alive 的最大值为 18 小时 12 分 15 秒&lt;/li>
&lt;li>Keep Alive 值如果设为 0 的话，代表不使用 Keep Alive 机制&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>有效载荷&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jonlimx/blogs@main/image/image-20230308154242825.png" alt="Payload">&lt;/p>
&lt;p>客户端标识符（Client ID）：客户端和服务器必须使用Client ID标识两者之间的MQTT会话状态&lt;/p>
&lt;p>遗嘱主题（Will Topic）：可变报头中的连接标志位中设置了Will Flag时，就必须设置遗嘱主题&lt;/p>
&lt;p>遗嘱消息（Will Message）：发布到遗嘱主题的消息&lt;/p>
&lt;p>用户名(User Name) | 密码（Password）：用于连接MQTT的Broker的用户名和密码&lt;/p>
&lt;h4 id="connack---确认连接请求">CONNACK - 确认连接请求&lt;/h4>
&lt;p>服务端发送给客户端的第一个报文必须是CONNACK&lt;/p>
&lt;p>&lt;strong>可变报头&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jonlimx/blogs@main/image/image-20230308155504193.png" alt="CONNACK报文">&lt;/p>
&lt;p>连接确认标志位（Acknowledge Flags）：总共一个字节，7~1位为保留位，值都为0。第零位也叫SP位，其值和ONNECT里的Clean Session有关&lt;/p>
&lt;ul>
&lt;li>如果Clean Session为1，那么每次连接都是新的会话，SP的值置为0&lt;/li>
&lt;li>如果Clean Session为0，服务根据客户端标识判断是否已经有该客户端会话，那么SP的值置为1，否则为0&lt;/li>
&lt;/ul>
&lt;p>连接返回码（Return Code）：连接返回码，用于标识连接成功与否。如果连接失败，如下表，根据该值判断连接失败的原因&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;strong>值&lt;/strong>&lt;/th>
&lt;th>&lt;strong>返回码响应&lt;/strong>&lt;/th>
&lt;th>&lt;strong>描述&lt;/strong>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>0x00连接已接受&lt;/td>
&lt;td>连接已被服务端接受&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>0x01连接已拒绝，不支持的协议版本&lt;/td>
&lt;td>服务端不支持客户端请求的MQTT协议级别&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>0x02连接已拒绝，不合格的客户端标识符&lt;/td>
&lt;td>客户端标识符是正确的UTF-8编码，但服务端不允许使用&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>0x03连接已拒绝，服务端不可用&lt;/td>
&lt;td>网络连接已建立，但MQTT服务不可用&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4&lt;/td>
&lt;td>0x04连接已拒绝，无效的用户名或密码&lt;/td>
&lt;td>用户名或密码的数据格式无效&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>5&lt;/td>
&lt;td>0x05连接已拒绝，未授权&lt;/td>
&lt;td>客户端未被授权连接到此服务器&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>6-255&lt;/td>
&lt;td>&lt;/td>
&lt;td>保留&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;blockquote>
&lt;p>如果认为上表中的所有连接返回码都不太合适，那么服务端必须关闭网络连接，不需要发送 CONNACK 报文&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>有效载荷&lt;/strong>&lt;/p>
&lt;p>无&lt;/p>
&lt;h4 id="disconnect---断开连接">DISCONNECT - 断开连接&lt;/h4>
&lt;p>客户端发送给服务端的最后一个控制报文，表示客户端正常断开连接。除了固定头以外，就不包含可变报头和有效负载&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jonlimx/blogs@main/image/image-20230308164658138.png" alt="DISCONNECT">&lt;/p>
&lt;h4 id="publish---发布消息">PUBLISH - 发布消息&lt;/h4>
&lt;p>&lt;strong>固定报头&lt;/strong>&lt;/p>
&lt;p>大多数MQTT固定报头标志位都是保留位，但是PUBLISH报文的标志位有其特殊的用途，如下图所示：&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jonlimx/blogs@main/image/image-20230523155106325.png" alt="PUBLISH固定报头">&lt;/p>
&lt;ul>
&lt;li>DUP - 如果为0，说明这是第一次发送这个PUBLISH报文；如果为1，则对应的QoS为1或者2，说明这是重发的报文&lt;/li>
&lt;li>RETAIN - 保留消息标志&lt;/li>
&lt;/ul>
&lt;p>当客户端为新接入的客户端，且订阅了匹配保留消息的主题，服务端发送给新客户端的PUBLISH 消息的RETAIN标志位要置为1；否则，如果是一个已存在的客户端且匹配到了保留消息的主题，那么服务发送的PUBLISH消息的RETAIN标志位置0&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jonlimx/blogs@main/image/image-20230523161923676.png" alt="RETAIN标志位">&lt;/p>
&lt;p>&lt;strong>可变报头&lt;/strong>&lt;/p>
&lt;p>可变报头按顺序包含&lt;code>主题名(Topic Name)&lt;/code>和&lt;code>报文标识符(Packet Identifier)&lt;/code>&lt;/p>
&lt;p>主题名：服务端发送的PUBLISH报文的主题名&lt;strong>不能&lt;/strong>包含通配符&lt;/p>
&lt;p>报文标识符：当QoS为1或者2的时候，报文标识符才能出现在PUBLISH报文中&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jonlimx/blogs@main/image/image-20230523163424185.png" alt="报文标识符">&lt;/p>
&lt;p>报文标识符用来区分报文，特别是在重发的报文中用来标识是否是同一个报文，并在需要应答的场景中用于确定是对哪个发送报文的应答。可变报头的报文标识符（Message Identifier）字段存在于在多个类型的报文里（占用2个字节）。这些报文是：&lt;code>PUBLISH（QoS &amp;gt; 0时）&lt;/code>， &lt;code>PUBACK&lt;/code>，&lt;code>PUBREC&lt;/code>，&lt;code>PUBREL&lt;/code>，&lt;code>PUBCOMP&lt;/code>，&lt;code>SUBSCRIBE,&lt;/code> &lt;code>SUBACK&lt;/code>，&lt;code>UNSUBSCRIBE&lt;/code>，&lt;code>UNSUBACK&lt;/code>。&lt;/p>
&lt;p>报文标识符的一些规则：&lt;/p>
&lt;ul>
&lt;li>QoS0的PUBLISH报文不能包含报文标识符&lt;/li>
&lt;li>报文标识符默认是从1(0x01)开始并自增，最大为255(0xff)&lt;/li>
&lt;li>客户端/服务端每次发送一个新的PUBLISH报文时都必须分配一个当前&lt;strong>未使用的报文标识符&lt;/strong>&lt;/li>
&lt;li>对于重发的PUBLISH报文，报文标识符需要和之前的保持一致&lt;/li>
&lt;li>当客户端和服务端完成相应的QoS流程后，报文标识符可以释放被再一次使用&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>有效载荷&lt;/strong>&lt;/p>
&lt;p>提供给上层应用的具体的消息&lt;/p>
&lt;h4 id="puback---发布确认报文-qos-1">PUBACK - 发布确认报文 （QoS 1）&lt;/h4>
&lt;p>PUBACK 报文比较简单，它是对QoS 1等级的PUBLISH报文的响应。PUBACK 报文的组成（没有有效载荷） = 一个固定头(0x40 0x20) + 报文标识符。&lt;/p>
&lt;h4 id="pubrec--发布收到报文-qos-2第一步">PUBREC – 发布收到报文 （QoS 2，第一步）&lt;/h4>
&lt;p>PUBREC报文是对QoS等级2的PUBLISH报文的响应。PUBREC 报文的 组成 （没有 有效载荷） = 一个固定头(0x50 0x20) + 报文标识符。&lt;/p>
&lt;h4 id="pubrel--发布释放qos-2第二步">PUBREL – 发布释放（QoS 2，第二步）&lt;/h4>
&lt;p>PUBREL报文是对PUBREC报文的响应。PUBREL 报文的 组成 （没有 有效载荷） = 一个固定头(0x62 0x02) + 报文标识符。&lt;/p>
&lt;blockquote>
&lt;p>PUBREL控制报文固定报头的第3,2,1,0位是保留位，&lt;strong>必须&lt;/strong>被设置为0,0,1,0。&lt;/p>
&lt;/blockquote>
&lt;h4 id="pubcomp--发布完成qos-2第三步">PUBCOMP – 发布完成（QoS 2，第三步）&lt;/h4>
&lt;p>PUBCOMP报文是对PUBREL报文的响应。PUBCOMP 报文的 组成 （没有 有效载荷） = 一个固定头(0x70 0x02) + 报文标识符。&lt;/p>
&lt;h4 id="subscribe---订阅主题">SUBSCRIBE - 订阅主题&lt;/h4>
&lt;p>&lt;strong>可变报头&lt;/strong>&lt;/p>
&lt;p>SUBSCRIBE的可变头中只有&lt;code>报文标识符(Message Identifier)&lt;/code>这一个字段。&lt;/p>
&lt;p>&lt;strong>有效载荷&lt;/strong>&lt;/p>
&lt;p>SUBSCRIBE 报文的有效载荷包含了一个主题过滤器列表，它们表示客户端想要订阅的主题。这个列表包含了一些列的主题过滤器和QoS的组合&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jonlimx/blogs@main/image/image-20230605165712118.png" alt="主题过滤器和QoS组合">&lt;/p>
&lt;p>&lt;strong>SUBSCRIBE响应&lt;/strong>&lt;/p>
&lt;p>服务端收到客户端发送的一个SUBSCRIBE报文时，&lt;strong>必须&lt;/strong>使用SUBACK报文响应。&lt;/p>
&lt;ul>
&lt;li>SUBACK报文&lt;strong>必须&lt;/strong>和等待确认的SUBSCRIBE报文有相同的报文标识符&lt;/li>
&lt;li>如果服务端收到一个SUBSCRIBE报文，报文的主题过滤器与一个现存订阅的主题过滤器相同，那么&lt;strong>必须&lt;/strong>使用新的订阅彻底替换现存的订阅。新订阅的主题过滤器和之前订阅的相同，但是它的最大QoS值可以不同。与这个主题过滤器匹配的任何现存的保留消息&lt;strong>必须&lt;/strong>被重发，但是发布流程&lt;strong>不能&lt;/strong>中断&lt;/li>
&lt;li>如果主题过滤器不同于任何现存订阅的过滤器，服务端会创建一个新的订阅并发送所有匹配的保留消息&lt;/li>
&lt;li>如果服务端收到包含多个主题过滤器的SUBSCRIBE报文，它&lt;strong>必须&lt;/strong>如同收到了一系列的多个SUBSCRIBE报文一样处理那个，除了需要将它们的响应合并到一个单独的SUBACK报文发送&lt;/li>
&lt;li>服务端发送给客户端的SUBACK报文对每一对主题过滤器 和QoS等级都&lt;strong>必须&lt;/strong>包含一个返回码。这个返回码&lt;strong>必须&lt;/strong>表示那个订阅被授予的最大QoS等级，或者表示这个订阅失败 。服务端可以授予比订阅者要求的低一些的QoS等级。&lt;strong>为响应订阅而发出的消息的有效载荷的QoS必须是原始发布消息的QoS和服务端授予的QoS两者中的最小值&lt;/strong>。如果原始消息的QoS是1而被授予的最大QoS是0，允许服务端重复发送一个消息的副本给订阅者（什么情况下会重传？QoS应该降级为0，不应该重传才是？？）&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>订阅降级的一些例子&lt;/strong>&lt;/p>
&lt;p>如果正在订阅的客户端被授予的最大 QoS 等级是 0，那么原来按 QoS 等级 2 发布给客户端的应用 消息在繁忙时可能会丢失，但是服务端不应该发送重复的消息副本。发布给同一主题的 QoS 等级 1 的消息在传输给客户端时可能会丢失或重复。&lt;/p>
&lt;p>对某个特定的主题过滤器，如果正在订阅的客户端被授予的最大QoS等级是1，那么匹配这个过滤器的QoS等级0的应用消息会按QoS等级0分发给这个客户端。这意味着客户端最多收到这个消息的一个副本。从另一方面说，发布给同一主题的QoS等级2的消息会被服务端降级到QoS等级1再分发给客户端，因此客户端可能会收到重复的消息副本。&lt;/p>
&lt;p>使用QoS等级2订阅一个主题过滤器等于是说：&lt;em>我想要按照它们发布时的QoS等级接受匹配这个过滤器的消息&lt;/em> 。这意味着，&lt;strong>确定消息分发时可能的最大QoS等级是发布者的责任，而订阅者可以要求服务端降低QoS到更适合它的等级&lt;/strong>。&lt;/p>
&lt;h4 id="suback---订阅确认">SUBACK - 订阅确认&lt;/h4>
&lt;p>&lt;strong>可变报头&lt;/strong>&lt;/p>
&lt;p>SUBACK 的可变头中只有&lt;code>报文标识符(Message Identifier)&lt;/code>这一个字段。&lt;/p>
&lt;p>&lt;strong>有效载荷&lt;/strong>&lt;/p>
&lt;p>有效载荷包含一个返回码清单。每个返回码对应等待确认的SUBSCRIBE报文中的一个主题过滤器。下图中的SUBACK报文里的&lt;strong>Granted QoS就是服务端授予客户端订阅的最大QoS&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jonlimx/blogs@main/image/image-20230606113452108.png" alt="SUBACK返回码">&lt;/p>
&lt;p>每一个返回码占用1个字节，允许的返回码值：&lt;/p>
&lt;ul>
&lt;li>0x00 - 最大QoS 0&lt;/li>
&lt;li>0x01 - 成功 – 最大QoS 1&lt;/li>
&lt;li>0x02 - 成功 – 最大 QoS 2&lt;/li>
&lt;li>0x80 - Failure 失败&lt;/li>
&lt;/ul>
&lt;p>0x00, 0x01, 0x02, 0x80之外的SUBACK返回码是保留的，&lt;strong>不能&lt;/strong>使用。返回码的顺序&lt;strong>必须&lt;/strong>和SUBSCRIBE报文中主题过滤器的顺序相同。&lt;/p>
&lt;h4 id="unsubscribe--取消订阅报文">UNSUBSCRIBE – 取消订阅报文&lt;/h4>
&lt;p>客户端发送UNSUBSCRIBE报文给服务端，用于取消订阅主题。在 UNSUBSCRIBE 报文中，除了有效荷载中不包含QoS等级，其他都是和 SUBSCRIBE 非常相似。&lt;/p>
&lt;p>&lt;strong>可变报头&lt;/strong>&lt;/p>
&lt;p>UNSUBSCRIBE的可变头中只有&lt;code>报文标识符(Message Identifier)&lt;/code>这一个字段。&lt;/p>
&lt;p>&lt;strong>有效载荷&lt;/strong>&lt;/p>
&lt;p>UNSUBSCRIBE报文的有效载荷包含客户端想要取消订阅的主题过滤器列表。UNSUBSCRIBE报文中的主题过滤器&lt;strong>必须&lt;/strong>是连续的。SUBSCRIBE报文的有效载荷&lt;strong>必须&lt;/strong>包含至少1个主题过滤器。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jonlimx/blogs@main/image/image-20230606152347837.png" alt="UNSUBSCRIBE主题过滤器列表">&lt;/p>
&lt;p>&lt;strong>UNSUBSCRIBE响应&lt;/strong>&lt;/p>
&lt;p>UNSUBSCRIBE 报文提供的主题过滤器(无论是否包含通配符)必须与服务端持有的这个客户端的当前主题过滤器集合逐个字符比较。如果有任何过滤器完全匹配，那么它(服务端)自己的订阅将被删除，否则不会有进一步的处理。&lt;/p>
&lt;p>如果服务端删除了一个订阅：&lt;/p>
&lt;ul>
&lt;li>它&lt;strong>必须&lt;/strong>停止分发任何新消息给这个客户端&lt;/li>
&lt;li>它&lt;strong>必须&lt;/strong>完成分发任何已经开始往客户端发送的QoS 1和QoS 2的消息&lt;/li>
&lt;li>它&lt;strong>可以&lt;/strong>继续发送任何现存的准备分发给客户端的缓存消息&lt;/li>
&lt;/ul>
&lt;h4 id="unsuback--取消订阅确认报文">UNSUBACK – 取消订阅确认报文&lt;/h4>
&lt;p>服务端发送UNSUBACK报文给客户端用于确认收到UNSUBSCRIBE报文。UNSUBACK报文是对UNSUBSCRIBE报文的响应。&lt;/p>
&lt;p>UNSUBACK 报文的组成 （没有有效载荷） = 一个固定头(0xb 0x02) + Message Identifier。&lt;/p>
&lt;h4 id="pingreq--心跳请求报文">PINGREQ – 心跳请求报文&lt;/h4>
&lt;p>当Client在一个Keep Alive时间间隔内没有向Broker发送任何数据包时，它应该向Broker发送 PINGREQ数据包。&lt;/p>
&lt;p>PINGREQ数据包没有可变头和有效载荷，那么PINGREQ 报文的全部内容(共2个字节)就是 ： &lt;code>0xc0 0x00&lt;/code>&lt;/p>
&lt;h4 id="pingresp--心跳响应-报文">PINGRESP – 心跳响应 报文&lt;/h4>
&lt;p>当Broker收到来自Client的PINGREQ数据包，它应该回复Client一个PINGRESP数据包。&lt;/p>
&lt;p>PINGRESP数据包没有可变头和有效载荷，那么PINGRESP报文的全部内容(共2个字节)就是 ： &lt;code>0xd0 0x00&lt;/code>&lt;/p></description></item><item><title>MQTT QoS和协议流程</title><link>https://www.jonathanlin.top/posts/mqtt-note-04/</link><pubDate>Tue, 23 May 2023 22:29:47 +0800</pubDate><guid>https://www.jonathanlin.top/posts/mqtt-note-04/</guid><description>
&lt;p>一些容易搞混的概念：&lt;/p>
&lt;ol>
&lt;li>QoS是发送者和接受者之间的协议，而不是Publisher和Subscriber之间的协定，Subscriber订阅到的消息的QoS和Publisher没有直接关系&lt;/li>
&lt;li>Subscriber订阅到的消息的QoS：Publisher发布消息到Broker的QoS为QoSA，Subscriber从Broker订阅消息的QoS为QoSB，取QoSA和QoSB这二者的最小值&lt;/li>
&lt;/ol>
&lt;h3 id="qos-0最多分发一次">QoS 0：最多分发一次&lt;/h3>
&lt;p>消息的分发依赖于底层网络的能力。接收者不会发送响应，发送者也不会重试。消息可能送达一次也可能根本没送达。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jonlimx/blogs@main/image/image-20230320094437868.png" alt="QoS0消息交互">&lt;/p>
&lt;h3 id="qos1至少分发一次">QoS1：至少分发一次&lt;/h3>
&lt;p>服务质量确保消息至少送达一次。QoS 1 的 PUBLISH 报文的可变报头中包含一个&lt;strong>报文标识符&lt;/strong>，需要PUBACK 报文确认。&lt;strong>QoS1的情况下，接收端收到的消息可能会重复。&lt;/strong>&lt;/p>
&lt;p>对于&lt;strong>发送者&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>每次发送新的应用消息都必须分配一个未使用的报文标识符&lt;/li>
&lt;li>发送的 PUBLISH 报文必须包含报文标识符且 QoS 等于 1，DUP 等于 0&lt;/li>
&lt;li>必须将这个 PUBLISH 报文看作是 未确认的 ，直到从接收者那收到对应的 PUBACK 报文&lt;/li>
&lt;li>一旦发送者收到 PUBACK 报文，这个报文标识符就可以重用&lt;/li>
&lt;li>允许发送者在等待确认时使用不同的报文标识符发送后续的 PUBLISH 报文&lt;/li>
&lt;/ul>
&lt;p>对于&lt;strong>接收者&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>响应的 PUBACK 报文必须包含一个&lt;strong>报文标识符&lt;/strong>，这个标识符来自接收到的、已经接受所有权的 PUBLISH 报文&lt;/li>
&lt;li>发送了 PUBACK 报文之后，接收者必须将任何包含相同报文标识符的入站 PUBLISH 报文当作一 个新的消息，并忽略它的 DUP 标志的值&lt;/li>
&lt;li>不要求接收者在发送 PUBACK 之前完整分发应用消息。原来的发送者收到 PUBACK 报文之后， 应用消息的所有权就会转移给这个接收者&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jonlimx/blogs@main/image/image-20230320094542565.png" alt="QoS1消息交互">&lt;/p>
&lt;h4 id="为什么qos1可能导致消息重复">为什么QoS1可能导致消息重复？&lt;/h4>
&lt;p>来看看以下两种情况，如下图所示：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>左边&lt;/strong>：PUBACK传输失败了，因此发送端重发了这个报文（下图左边的2），Packet Id也就是报文标识符保持一致，DUP变为1表示消息重传。实际上，这里面只是一个QoS1的消息来回&lt;/li>
&lt;li>&lt;strong>右边&lt;/strong>：在完成了一次QoS1的消息交互后，报文标识符即可释放。后续的消息可以复用已释放的消息标识符，然后再发送PUBLISH报文的时候，因为某种原因失败了发生了重传（下图右边的4），这是DUP变为1。实际上，这里面是两个QoS1消息的的来回&lt;/li>
&lt;/ul>
&lt;p>这两种情况，Packet Id一致，且DUP均为1，同时Payload一致。对于接收方来说，无法区分是重复消息（左边步骤3）还是新消息（右边的4）。综合来看，只能让接收方将这些 PUBLISH 报文都当作全新的消息来处理。因此当我们使用 QoS 1 时，消息的重复在协议层面上是无法避免的。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jonlimx/blogs@main/image/image-20230320094912484.png" alt="QoS1重复消息对比">&lt;/p>
&lt;h3 id="qos-2-仅分发一次">QoS 2: 仅分发一次&lt;/h3>
&lt;p>最高等级，消息丢失和重复都不可接受。&lt;/p>
&lt;p>对于&lt;strong>发送者&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>必须给要发送的新应用消息分配一个未使用的报文标识符&lt;/li>
&lt;li>发送的 PUBLISH 报文必须包含报文标识符且报文的 QoS 等于 2，DUP 等于 0&lt;/li>
&lt;li>必须将这个 PUBLISH 报文看作是 未确认的 ，直到从接收者那收到对应的 PUBREC 报文&lt;/li>
&lt;li>收到 PUBREC 报文后必须发送一个 PUBREL 报文。PUBREL 报文必须包含与原始 PUBLISH 报文 相同的报文标识符&lt;/li>
&lt;li>必须将这个 PUBREL 报文看作是 未确认的 ，直到从接收者那收到对应的 PUBCOMP 报文&lt;/li>
&lt;li>一旦发送了对应的 PUBREL 报文就不能重发这个 PUBLISH 报文&lt;/li>
&lt;li>一旦发送者收到 PUBCOMP 报文，这个报文标识符就可以重用&lt;/li>
&lt;/ul>
&lt;p>对于&lt;strong>接收者&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>响应的 PUBREC 报文必须包含报文标识符，这个标识符来自接收到的、已经接受所有权的PUBLISH 报文&lt;/li>
&lt;li>在收到对应的 PUBREL 报文之前，接收者必须发送 PUBREC 报文确认任何后续的具有相同标识符的 PUBLISH 报文。 在这种情况下，它不能重复分发消息给任何后续的接收者&lt;/li>
&lt;li>响应 PUBREL 报文的 PUBCOMP 报文必须包含与 PUBREL 报文相同的标识符&lt;/li>
&lt;li>发送 PUBCOMP 报文之后，接收者必须将包含相同报文标识符的任何后续 PUBLISH 报文当作一个新的发布&lt;/li>
&lt;/ul>
&lt;p>下图中，在完成了步骤3后，说明接收者已经收到PUBLISHB报文，发送者就不再需要重复发送这个PUBLISH报文，因此就可以删除掉本地缓存的PUBLISH报文。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jonlimx/blogs@main/image/image-20230320092715928.png" alt="QoS2消息交互">&lt;/p>
&lt;h4 id="为什么qos2可以避免重复消息">为什么QoS2可以避免重复消息？&lt;/h4>
&lt;p>首先QoS2和QoS1类似，当发送者发送了PUBLISH报文以后，是需要接收者的PUBREC报文来告诉发送者PUBLISH已收到。&lt;/p>
&lt;p>不同的是，对于QoS1来说，在此之后相同的报文标识符又变得可用，这样导致可能的&lt;a href="#%E4%B8%BA%E4%BB%80%E4%B9%88qos1%E5%8F%AF%E8%83%BD%E5%AF%BC%E8%87%B4%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D">消息重复&lt;/a>。对于QoS2而言，释放报文标识符也是需要通过一组PUBREL/PUBCOM使得发送者和接收者双方达成一致以后才能释放报文标识符。发送方只有在收到 PUBREC 报文之前可以重传 PUBLISH 报文。一旦收到 PUBREC 报文并发出 PUBREL 报文，发送方就进入了 Packet ID 释放流程，不可以再使用当前 Packet ID 重传 PUBLISH 报文。同时，在收到对端回复的 PUBCOMP 报文确认双方都完成 Packet ID 释放之前，也不可以使用当前 Packet ID 发送新的消息。&lt;/p>
&lt;h3 id="qos和session">QoS和Session&lt;/h3>
&lt;p>客户端的会话状态包括:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>已经发送给服务端，但是还没有完成确认的 QoS 1 和 QoS 2 级别的消息&lt;/p>
&lt;/li>
&lt;li>
&lt;p>已从服务端接收，但是还没有完成确认的 QoS 2 级别的消息。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>服务端的会话状态包括:&lt;/p>
&lt;ul>
&lt;li>会话是否存在（即使会话状态的其它部分都是空）&lt;/li>
&lt;li>客户端的订阅信息&lt;/li>
&lt;li>已经发送给客户端，但是还没有完成确认的 QoS 1 和 QoS 2 级别的消息&lt;/li>
&lt;li>即将传输给客户端的 QoS 1 和 QoS 2 级别的消息&lt;/li>
&lt;li>已从客户端接收，但是还没有完成确认的 QoS 2 级别的消息&lt;/li>
&lt;li>可选，准备发送给客户端的 QoS 0 级别的消息&lt;/li>
&lt;/ul>
&lt;p>保留消息不是服务端会话状态的一部分，会话终止时&lt;strong>不能&lt;/strong>删除保留消息。&lt;/p>
&lt;h3 id="qos等级的选择">QoS等级的选择&lt;/h3>
&lt;p>&lt;strong>在以下情况下你可以选择 QoS0&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>Client 和 Broker 之间的网络连接非常稳定，例如一个通过有线网络连接到 Broker 的测试用 Client&lt;/li>
&lt;li>可以接受丢失部分消息，比如你有一个传感器以非常短的间隔发布状态数据，所以丢一些也可以接受&lt;/li>
&lt;li>你不需要离线消息&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>在以下情况下你应该选择 QoS1：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>你需要接收所有的消息，而且你的应用可以接受并处理重复的消息；&lt;/li>
&lt;li>你无法接受 QoS2 带来的额外开销，QoS1 发送消息的速度比 QoS2 快很多&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>在以下情况下你应该选择 QoS2：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>你的应用必须接收到所有的消息，而且你的应用在重复的消息下无法正常工作，同时你也能接受 QoS2 带来的额外开销&lt;/li>
&lt;/ul></description></item><item><title>保留消息和最后遗嘱</title><link>https://www.jonathanlin.top/posts/mqtt-note-05/</link><pubDate>Tue, 23 May 2023 11:27:12 +0800</pubDate><guid>https://www.jonathanlin.top/posts/mqtt-note-05/</guid><description>
&lt;h3 id="保留消息retained">保留消息（Retained）&lt;/h3>
&lt;p>保留消息是指在 PUBLISH 数据包中 Retain 标识设为 1 的消息，Broker 收到这样的 PUBLISH 包以后，将保存这个消息以及它的QoS，当有一个新的订阅者订阅相应主题的时候，Broker 会马上将这个消息发送给订阅者。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jonlimx/blogs@main/image/image-20230412164743661.png" alt="Retained Message">&lt;/p>
&lt;p>保留消息具有以下特点：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>一个 Topic 只能有 1 条保留消息，发布新的保留消息将覆盖老的保留消息&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果订阅者使用通配符订阅主题，它会收到所有匹配的主题上的保留消息，如下所示&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jonlimx/blogs@main/image/image-20230412165634682.png" alt="通配符订阅">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>保留消息发送到订阅者时，消息的 Retain 标识仍然是 1，订阅者可以判断这个消息是否是保留消息，以做相应的处理。同时，订阅者收到的消息的QoS与保留消息一致&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jonlimx/blogs@main/image/image-20230412170420371.png" alt="image-20230412170420371">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>只有新的订阅者才会收到保留消息，&lt;strong>如果订阅者重复订阅一个主题，也会被当做新的订阅者，然后收到保留消息&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>删除一个 Retained 消息只需要向这个主题发布一个 Payload 长度为 0 的 Retained 消息即可&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>注意&lt;/strong>：保留消息和持久性会话没有关系，保留消息是 Broker为每一个Topic单独存储的，而持久性会话是 Broker 为每一个 Client 单独存储的&lt;/p>
&lt;h3 id="最后遗嘱lwt---last-will-and-testament">最后遗嘱（LWT - Last Will and Testament)&lt;/h3>
&lt;p>遗嘱消息是在客户端连接的时候在CONNETCT报文里设置，详见[CONNECT报文](&lt;a href="https://www.jonathanlin.top/posts/mqtt-note-03/#connect---%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E7%AB%AFbroker">MQTT控制报文 | Standing on the Shoulder of Giants (jonathanlin.top)&lt;/a>)。举例来首，下图的CONNECT报文中：&lt;/p>
&lt;ul>
&lt;li>Will Flag标志打开，表明开启使用LWT&lt;/li>
&lt;li>Will Retain标志打开，表明遗嘱消息作为保留消息发布（即客户端异常断开以后，broker会往遗嘱Topic里写入遗嘱消息，且遗嘱消息以保留消息的方式保存）&lt;/li>
&lt;li>遗嘱消息的长度，Topic以及内容见下图的红框里的内容&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jonlimx/blogs@main/image/image-20230523101516636.png" alt="image-20230523101516636">&lt;/p>
&lt;p>当客户端&lt;strong>异常断开&lt;/strong>连接的时候，Broker会往遗嘱Topic里发送遗嘱消息，这样订阅遗嘱Topic的客户端就能相应的收到遗嘱消息。&lt;strong>如果客户端通过DISCONNECT报文正常断开连接，那么Broker不会触发LWT机制，同时Broker把遗嘱消息从服务端删除。&lt;/strong>&lt;/p>
&lt;p>Broker在以下情况认为Client是异常断开连接：&lt;/p>
&lt;ul>
&lt;li>服务端检测到了一个 I/O 错误或者网络故障&lt;/li>
&lt;li>客户端在保持连接(Keep Alive)的时间内未能通讯&lt;/li>
&lt;li>客户端没有先发送 DISCONNECT 报文直接关闭了网络连接&lt;/li>
&lt;li>由于协议错误服务端关闭了网络连接&lt;/li>
&lt;/ul>
&lt;h3 id="保留消息和最后遗嘱结合使用的场景">保留消息和最后遗嘱结合使用的场景&lt;/h3>
&lt;p>如果要实现设备上线和离线通知（下线包括正常离线和异常离线），可以结合保留消息和最后遗嘱来实现。参考下面的golang代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="ln"> 1&lt;/span>&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 2&lt;/span>&lt;span class="cl"> &lt;span class="nx">clientOption&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">mqtt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewClientOptions&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 3&lt;/span>&lt;span class="cl"> &lt;span class="nx">clientOption&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">AddBroker&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;tcp://192.168.60.40:1883&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 4&lt;/span>&lt;span class="cl"> &lt;span class="nx">clientOption&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">SetUsername&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;user&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 5&lt;/span>&lt;span class="cl"> &lt;span class="nx">clientOption&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">SetPassword&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;1234&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 6&lt;/span>&lt;span class="cl"> &lt;span class="nx">clientOption&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">SetClientID&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;jonlimx110&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 7&lt;/span>&lt;span class="cl"> &lt;span class="c1">// 通过CONNECT设置遗嘱消息，这里把遗嘱消息的Will Retian标志位打开，使得订阅mqtttest/status主题的客户端，不论是当前是连接的还是后续连接的都能接收到遗嘱消息
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 8&lt;/span>&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">clientOption&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">SetWill&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;mqtttest/status&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;lwt - offline&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 9&lt;/span>&lt;span class="cl"> &lt;span class="nx">client&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">mqtt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewClient&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">clientOption&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">10&lt;/span>&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">token&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">client&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Connect&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="nx">token&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Wait&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">token&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Error&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">11&lt;/span>&lt;span class="cl"> &lt;span class="nb">panic&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">token&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Error&lt;/span>&lt;span class="p">())&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">12&lt;/span>&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">13&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">14&lt;/span>&lt;span class="cl"> &lt;span class="c1">// 客户端上线以后，往mqtttest/status主题发布消息，通知该客户端上线
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">15&lt;/span>&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">token&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">client&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Publish&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;mqtttest/status&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;online&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">16&lt;/span>&lt;span class="cl"> &lt;span class="nx">token&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Wait&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">17&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">18&lt;/span>&lt;span class="cl"> &lt;span class="nx">c&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="nx">os&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Signal&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">19&lt;/span>&lt;span class="cl"> &lt;span class="nx">signal&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Notify&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">c&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">os&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Interrupt&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">syscall&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">SIGTERM&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">20&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">21&lt;/span>&lt;span class="cl"> &lt;span class="k">select&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">22&lt;/span>&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">c&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">23&lt;/span>&lt;span class="cl"> &lt;span class="c1">// 这里没有调用client.Disconnect就退出，模拟异常离线的情况
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">24&lt;/span>&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 异常离线后，Broker触发LWT，往mqtttest/status发布遗嘱消息，且是以保留消息的方式发布
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">25&lt;/span>&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;exit without disconnect from broker&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">26&lt;/span>&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">After&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">5&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Second&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">27&lt;/span>&lt;span class="cl"> &lt;span class="c1">// 客户端如果正常离线，发布保留消息通过客户端离线
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">28&lt;/span>&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">token&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">client&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Publish&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;mqtttest/status&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;retained - offline&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">29&lt;/span>&lt;span class="cl"> &lt;span class="nx">token&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Wait&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">30&lt;/span>&lt;span class="cl"> &lt;span class="nx">client&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Disconnect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">31&lt;/span>&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">32&lt;/span>&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>MQTT杂记</title><link>https://www.jonathanlin.top/posts/mqtt-note-01/</link><pubDate>Fri, 24 Feb 2023 21:23:09 +0800</pubDate><guid>https://www.jonathanlin.top/posts/mqtt-note-01/</guid><description>
&lt;blockquote>
&lt;p>本文记录一些学些MQTT的过程中的重点和难点，学习材料包括：&lt;/p>
&lt;ul>
&lt;li>MQTT协议规范&lt;/li>
&lt;li>&lt;a href="https://www.cnblogs.com/schips/p/12266847.html">MQTT 协议学习： 总结 与 各种定义的速查表 - schips - 博客园 (cnblogs.com)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="角色">角色&lt;/h3>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jonlimx/blogs@main/image/mqtt-publish-subscribe-20220222113341799.png" alt="mqtt-publish-subscribe">&lt;/p>
&lt;ul>
&lt;li>MQTT Broker - 消息代理服务器&lt;/li>
&lt;li>MQTT Client - 消息发布者，通过QoS和Topic发布和订阅消息。MQTT Client可以同时是Publisher和Subscriber&lt;/li>
&lt;/ul>
&lt;h3 id="订阅">订阅&lt;/h3>
&lt;ul>
&lt;li>包含一个主题和QoS&lt;/li>
&lt;li>订阅与单个会话关联，一个会话可以包含一个或者多个订阅&lt;/li>
&lt;/ul>
&lt;h3 id="主题名和主题过滤器">主题名和主题过滤器&lt;/h3>
&lt;blockquote>
&lt;p>以下内容多来自MQTT3.1.1规范&lt;/p>
&lt;/blockquote>
&lt;p>MQTT Client通过主题发布和订阅消息。主题名可以有不同层级，通过&lt;code>/&lt;/code>划分。主题可能是管理员在服务端预先定义好的，也可能是服务端收到第一个订阅或使用那个主题名的应用消息时动态添加 的。&lt;strong>主题过滤器通过在主题名中引入通配符来匹配一个或者多个主题。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>注意：MQTT允许使用主题过滤器进行订阅（匹配）多个主题，但是不允许通过主题过滤器进行发布&lt;/p>
&lt;/blockquote>
&lt;h4 id="主题语义和用法">主题语义和用法&lt;/h4>
&lt;p>主题名和主题过滤器必须符合下列规则：&lt;/p>
&lt;ul>
&lt;li>所有的主题名和主题过滤器必须至少包含一个字符&lt;/li>
&lt;li>主题名和主题过滤器是区分大小写的&lt;/li>
&lt;li>主题名和主题过滤器可以包含空格&lt;/li>
&lt;li>主题名或主题过滤器以前置或后置斜杠&amp;quot;/&amp;quot;区分&lt;/li>
&lt;li>只包含斜杠&amp;quot;/&amp;quot;的主题名或主题过滤器是合法的&lt;/li>
&lt;li>主题名和主题过滤器不能包含空字符 (Unicode U+0000)&lt;/li>
&lt;li>主题名和主题过滤器是 UTF-8 编码字符串，它们不能超过 65535字节&lt;/li>
&lt;/ul>
&lt;p>例如：&lt;/p>
&lt;ul>
&lt;li>&amp;quot;ACCOUNTS&amp;quot;和&amp;quot;Accounts&amp;quot;是不同的主题名&lt;/li>
&lt;li>&amp;quot;Accounts payable&amp;quot;是合法的主题名&lt;/li>
&lt;li>&amp;quot;/finance&amp;quot; 和 &amp;quot;finance&amp;quot;是不同的&lt;/li>
&lt;/ul>
&lt;h4 id="多层通配符">多层通配符&lt;code>#&lt;/code>&lt;/h4>
&lt;p>&lt;strong>&lt;code>#&lt;/code>&lt;/strong> 用于匹配主题中的任意层级的通配符。多层通配符必须是主题过滤器的最后一个字符，用于匹配它的父级和任意数量的子层级。例如，&amp;quot;sport/tennis/player1/#&amp;quot; 匹配下列主题名：&lt;/p>
&lt;ul>
&lt;li>&amp;quot;sport/tennis/player1&amp;quot;&lt;/li>
&lt;li>&amp;quot;sport/tennis/player1/ranking&amp;quot;&lt;/li>
&lt;li>&amp;quot;sport/tennis/player1/score/wimbledon&amp;quot;&lt;/li>
&lt;/ul>
&lt;p>一些其他的例子：&lt;/p>
&lt;ul>
&lt;li>&amp;quot;sport/#&amp;quot;也匹配单独的 &amp;quot;sport&amp;quot; ，因为&amp;quot;#&amp;quot; 包括它的父级&lt;/li>
&lt;li>&amp;quot;sport/tennis/#&amp;quot;也是有效的&lt;/li>
&lt;li>&amp;quot;sport/tennis#&amp;quot;是无效的&lt;/li>
&lt;li>&amp;quot;sport/tennis/#/ranking&amp;quot;是无效的&lt;/li>
&lt;/ul>
&lt;h4 id="单层通配符">单层通配符&lt;code>+&lt;/code>&lt;/h4>
&lt;p>在主题过滤器的任意层级都可以使用单层通配符，包括第一个和最后一个层级。它占据的是主题过滤器的整个层级，匹配的是特定的某个层级，&lt;strong>不能匹配子层级&lt;/strong>。例如，对于主题过滤器&amp;quot;sport/tennis/+&amp;quot;：&lt;/p>
&lt;ul>
&lt;li>&amp;quot;sport/tennis/player1&amp;quot; - 匹配&lt;/li>
&lt;li>&amp;quot;sport/tennis/player2&amp;quot; - 匹配&lt;/li>
&lt;li>&amp;quot;sport/tennis/player1/ranking&amp;quot; - 不匹配&lt;/li>
&lt;/ul>
&lt;p>一些其他的例子：&lt;/p>
&lt;ul>
&lt;li>&amp;quot;sport/+&amp;quot;不匹配 &amp;quot;sport&amp;quot;但是却匹配 &amp;quot;sport/&amp;quot;&lt;/li>
&lt;li>&amp;quot;+&amp;quot;是有效的&lt;/li>
&lt;li>&amp;quot;+/tennis/#&amp;quot;是有效的&lt;/li>
&lt;li>&amp;quot;sport+&amp;quot;是无效的&lt;/li>
&lt;li>&amp;quot;sport/+/player1&amp;quot;也是有效的&lt;/li>
&lt;li>&amp;quot;/finance&amp;quot;匹配 &amp;quot;+/+&amp;quot;和 &amp;quot;/+&amp;quot;，但是不匹配&amp;quot;+&amp;quot;&lt;/li>
&lt;/ul>
&lt;h4 id="以开头的主题">以&lt;code>$&lt;/code>开头的主题&lt;/h4>
&lt;p>服务端不能将&amp;quot;$&amp;quot;字符开头的主题名和&amp;quot;#/+&amp;quot;开头的主题过滤器匹配。&amp;quot;$&amp;quot;字符开头的主题名应该用于其他目的&lt;/p>
&lt;ul>
&lt;li>&amp;quot;$SYS/ &amp;quot;被广泛用作包含服务器特定信息或控制接口的主题的前缀&lt;/li>
&lt;li>应用不能使用 &amp;quot;$&amp;quot; 字符开头的主题 （也就是MQTT Client用于交互业务数据的主题）&lt;/li>
&lt;li>订阅 &amp;quot;#&amp;quot;的客户端不会收到任何发布到以&amp;quot;$&amp;quot;开头主题的消息&lt;/li>
&lt;li>订阅 &amp;quot;+/monitor/Clients&amp;quot; 的客户端不会收到任何发布到&amp;quot; $SYS/monitor/Clients&amp;quot;的消息&lt;/li>
&lt;li>订阅 &amp;quot;$SYS/#&amp;quot;的客户端会收到发布到以&amp;quot;$SYS/&amp;quot;开头主题的消息&lt;/li>
&lt;li>订阅 &amp;quot;$SYS/monitor/+&amp;quot;的客户端会收到发布到&amp;quot;$SYS/monitor/Clients&amp;quot;主题的消息&lt;/li>
&lt;li>如果客户端想同时接受以&amp;quot; $SYS/&amp;quot;开头主题的消息和不以&amp;quot;$&amp;quot; 开头主题的消息，它需要同时 订阅&amp;quot;#&amp;quot;和&amp;quot;$SYS/#&amp;quot;&lt;/li>
&lt;/ul></description></item><item><title>Mac下安装和配置Mosquitto</title><link>https://www.jonathanlin.top/posts/mqtt-note-02/</link><pubDate>Tue, 21 Feb 2023 16:18:26 +0800</pubDate><guid>https://www.jonathanlin.top/posts/mqtt-note-02/</guid><description>
&lt;h3 id="安装">安装&lt;/h3>
&lt;p>Mac下通过&lt;code>brew&lt;/code>安装Mosquitto只需要一条简单的命令：&lt;code>brew install mosquitto&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">&lt;span class="nx">mosquitto&lt;/span> &lt;span class="nx">has&lt;/span> &lt;span class="nx">been&lt;/span> &lt;span class="nx">installed&lt;/span> &lt;span class="kd">with&lt;/span> &lt;span class="nx">a&lt;/span> &lt;span class="k">default&lt;/span> &lt;span class="nx">configuration&lt;/span> &lt;span class="nx">file&lt;/span>&lt;span class="p">.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">2&lt;/span>&lt;span class="cl">&lt;span class="nx">You&lt;/span> &lt;span class="nx">can&lt;/span> &lt;span class="nx">make&lt;/span> &lt;span class="nx">changes&lt;/span> &lt;span class="nx">to&lt;/span> &lt;span class="nx">the&lt;/span> &lt;span class="nx">configuration&lt;/span> &lt;span class="nx">by&lt;/span> &lt;span class="nx">editing&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">3&lt;/span>&lt;span class="cl"> &lt;span class="err">/usr/local/etc/mosquitto/mosquitto.conf&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">4&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">5&lt;/span>&lt;span class="cl">&lt;span class="nx">To&lt;/span> &lt;span class="nx">restart&lt;/span> &lt;span class="nx">mosquitto&lt;/span> &lt;span class="nx">after&lt;/span> &lt;span class="nx">an&lt;/span> &lt;span class="nx">upgrade&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">6&lt;/span>&lt;span class="cl"> &lt;span class="nx">brew&lt;/span> &lt;span class="nx">services&lt;/span> &lt;span class="nx">restart&lt;/span> &lt;span class="nx">mosquitto&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">7&lt;/span>&lt;span class="cl">&lt;span class="nx">Or&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">you&lt;/span> &lt;span class="nx">don&lt;/span>&lt;span class="err">&amp;#39;&lt;/span>&lt;span class="nx">t&lt;/span> &lt;span class="nx">want&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="nx">need&lt;/span> &lt;span class="nx">a&lt;/span> &lt;span class="nx">background&lt;/span> &lt;span class="nx">service&lt;/span> &lt;span class="nx">you&lt;/span> &lt;span class="nx">can&lt;/span> &lt;span class="nx">just&lt;/span> &lt;span class="nx">run&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">8&lt;/span>&lt;span class="cl"> &lt;span class="err">/usr/local/opt/mosquitto/sbin/mosquitto -c /usr/local/etc/mosquitto/mosquitto.conf&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>安装完成后，默认情况下可执行文件和配置文件的位置如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">➜ ~ ll /usr/local/bin &lt;span class="p">|&lt;/span> grep mosquitto
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">2&lt;/span>&lt;span class="cl">lrwxr-xr-x &lt;span class="m">1&lt;/span> jonathanlin admin 47B Nov &lt;span class="m">25&lt;/span> 11:48 mosquitto_ctrl -&amp;gt; ../Cellar/mosquitto/2.0.10_1/bin/mosquitto_ctrl
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">3&lt;/span>&lt;span class="cl">lrwxr-xr-x &lt;span class="m">1&lt;/span> jonathanlin admin 49B Nov &lt;span class="m">25&lt;/span> 11:48 mosquitto_passwd -&amp;gt; ../Cellar/mosquitto/2.0.10_1/bin/mosquitto_passwd
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">4&lt;/span>&lt;span class="cl">lrwxr-xr-x &lt;span class="m">1&lt;/span> jonathanlin admin 46B Nov &lt;span class="m">25&lt;/span> 11:48 mosquitto_pub -&amp;gt; ../Cellar/mosquitto/2.0.10_1/bin/mosquitto_pub
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">5&lt;/span>&lt;span class="cl">lrwxr-xr-x &lt;span class="m">1&lt;/span> jonathanlin admin 45B Nov &lt;span class="m">25&lt;/span> 11:48 mosquitto_rr -&amp;gt; ../Cellar/mosquitto/2.0.10_1/bin/mosquitto_rr
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">6&lt;/span>&lt;span class="cl">lrwxr-xr-x &lt;span class="m">1&lt;/span> jonathanlin admin 46B Nov &lt;span class="m">25&lt;/span> 11:48 mosquitto_sub -&amp;gt; ../Cellar/mosquitto/2.0.10_1/bin/mosquitto_sub
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">7&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">8&lt;/span>&lt;span class="cl">➜ ~ ll /usr/local/etc/mosquitto &lt;span class="p">|&lt;/span> grep mosquitto.conf
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">9&lt;/span>&lt;span class="cl">lrwxr-xr-x &lt;span class="m">1&lt;/span> jonathanlin admin 60B Nov &lt;span class="m">25&lt;/span> 11:48 mosquitto.conf -&amp;gt; ../../Cellar/mosquitto/2.0.10_1/etc/mosquitto/mosquitto.conf
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="配置">配置&lt;/h3>
&lt;p>修改配置文件，显式关闭匿名访问，同时指定账号密码保存路径：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">allow_anonymous &lt;span class="nb">false&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">2&lt;/span>&lt;span class="cl">password_file /Users/jonathanlin/Workspace/mosquitto/pwd
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用&lt;code>mosquitto_passwd&lt;/code>创建两个测试账号：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">➜ mosquitto mosquitto_passwd -c ~/Workspace/mosquitto/pwd admin &lt;span class="c1"># 注意密码不要使用特殊字符@&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">2&lt;/span>&lt;span class="cl">Password:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">3&lt;/span>&lt;span class="cl">Reenter password:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">4&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">5&lt;/span>&lt;span class="cl">➜ mosquitto mosquitto_passwd ~/Workspace/mosquitto/pwd user &lt;span class="c1"># 这里不再需要-c参数，否则是覆盖之前的文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">6&lt;/span>&lt;span class="cl">Password:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">7&lt;/span>&lt;span class="cl">Reenter password:
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过&lt;code>brew&lt;/code>启动&lt;code>mosquitto&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">➜ mosquitto brew services start &lt;span class="nv">mosquitto&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">2&lt;/span>&lt;span class="cl">&lt;span class="o">==&lt;/span>&amp;gt; Successfully started &lt;span class="sb">`&lt;/span>mosquitto&lt;span class="sb">`&lt;/span> &lt;span class="o">(&lt;/span>label: homebrew.mxcl.mosquitto&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>或者执行二进制文件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">➜ ~ /usr/local/sbin/mosquitto -c /usr/local/etc/mosquitto/mosquitto.conf
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用&lt;code>mosquitto_sub&lt;/code>订阅一个主题：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">➜ mosquitto mosquitto_sub -u admin -P &lt;span class="m">1234&lt;/span> -t &lt;span class="s1">&amp;#39;topic-test&amp;#39;&lt;/span> -v
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用&lt;code>mosquitto_pub&lt;/code>往主题里发送消息：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">➜ ~ mosquitto_pub -u admin -P &lt;span class="m">1234&lt;/span> -t &lt;span class="s1">&amp;#39;topic-test&amp;#39;&lt;/span> -m &lt;span class="s1">&amp;#39;test&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>