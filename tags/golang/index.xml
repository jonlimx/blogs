<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>golang on Standing on the Shoulder of Giants</title><link>https://www.jonathanlin.top/tags/golang/</link><description>Recent content in golang on Standing on the Shoulder of Giants</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © {year} Jonathan Lin. All rights reserved.</copyright><lastBuildDate>Wed, 07 Jul 2021 23:24:02 +0800</lastBuildDate><atom:link href="https://www.jonathanlin.top/tags/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>[译]Goroutine Leaks - The Forgotten Sender</title><link>https://www.jonathanlin.top/posts/gorouting-leak-the-forgotten-sender/</link><pubDate>Wed, 07 Jul 2021 23:24:02 +0800</pubDate><guid>https://www.jonathanlin.top/posts/gorouting-leak-the-forgotten-sender/</guid><description>
&lt;p>原文链接：&lt;a href="https://www.ardanlabs.com/blog/2018/11/goroutine-leaks-the-forgotten-sender.html">Goroutine Leaks - The Forgotten Sender (ardanlabs.com)&lt;/a>&lt;/p>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>并发编程可以让程序员以多个执行路径来解决问题，而且通常是试图提高程序性能。并发并不意味着这些执行路径是以并行的方式执行，而是说这些执行路径以无序异步的方式执行而不是同步顺序执行。历史上这种编程模型是通过标准款或者第三方库来实现的。&lt;/p>
&lt;p>Go语言中，并发特性是通过语言内置的Goroutine和channel来实现，这样就减少了对库的依赖。这容易给人一种错觉，觉得使用Go来编写并发程序会很简单。你得非常小心，因为如果你没有正确的使用Go的并发特性，往往会引入特定的边界效应或者调入陷阱。一不小心，这些陷阱就会给你程序带来很多复杂度以及很恶心的bug。&lt;/p>
&lt;p>本文中，我将讨论的可能出现的陷阱是Goroutine泄漏。&lt;/p>
&lt;h2 id="goroutine泄漏">Goroutine泄漏&lt;/h2>
&lt;p>关于内存管理，Go语言为了处理了许许多多的内存管理细节。Go编译器根据逃逸分析来决定值应该存放在内存中的什么地方（原文站点引用了一篇逃逸分析的博文&lt;a href="https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-escape-analysis.html">Language Mechanics On Escape Analysis (ardanlabs.com)&lt;/a>，回头我也会翻译出来）。运行时通过垃圾回收器管理跟踪和管理堆上分配的内存，正因为此，虽然不能完全肯定你的程序不会发生内存泄漏，但这种概率已经被极大降低了。&lt;/p>
&lt;p>一种常见的内存泄漏是由于Goroutine泄漏引起的。如果你启动了一个Goroutine并且你期望它最终会退出，但由于某种原因最终这个Goroutine没有退出，这时候就发生了泄漏。这种情况下，这个Goroutine就存在于你的应用的整个生命周期，分配给这Goroutine的内存也无法释放。这就是Dave Cheney所建议的“&lt;a href="https://dave.cheney.net/2016/12/22/never-start-a-goroutine-without-knowing-how-it-will-stop">Never start a goroutine without knowing how it will stop&lt;/a>”背后的逻辑。&lt;/p>
&lt;p>下面的代码演示了一种非常常见的Goroutine泄漏。&lt;/p>
&lt;p>&lt;strong>Listing 1&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://play.golang.org/p/dsu3PARM24K">https://play.golang.org/p/dsu3PARM24K&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln"> 1&lt;/span>&lt;span class="mi">31&lt;/span> &lt;span class="c1">// leak is a buggy function. It launches a goroutine that
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">32&lt;/span> &lt;span class="c1">// blocks receiving from a channel. Nothing will ever be
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">33&lt;/span> &lt;span class="c1">// sent on that channel and the channel is never closed so
&lt;/span>&lt;span class="ln"> 4&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">34&lt;/span> &lt;span class="c1">// that goroutine will be blocked forever.
&lt;/span>&lt;span class="ln"> 5&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">35&lt;/span> &lt;span class="kd">func&lt;/span> &lt;span class="nf">leak&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 6&lt;/span>&lt;span class="mi">36&lt;/span> &lt;span class="nx">ch&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 7&lt;/span>&lt;span class="mi">37&lt;/span>
&lt;span class="ln"> 8&lt;/span>&lt;span class="mi">38&lt;/span> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 9&lt;/span>&lt;span class="mi">39&lt;/span> &lt;span class="nx">val&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">ch&lt;/span>
&lt;span class="ln">10&lt;/span>&lt;span class="mi">40&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;We received a value:&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">val&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">11&lt;/span>&lt;span class="mi">41&lt;/span> &lt;span class="p">}()&lt;/span>
&lt;span class="ln">12&lt;/span>&lt;span class="mi">42&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Listing 1定义了一个叫&lt;code>leak&lt;/code>的函数。这个函数在第36行创建了一个channel，通过这个channel把数据传递给后面启动的Goroutine。第38行启动了一个Goroutine，然后这个Goroutine在第39行被阻塞以等待接收channel上的来的数据。当这个Goroutine等待的时候，启动它的函数&lt;code>leak&lt;/code>就执行完返回了，&lt;strong>这时候程序中的没有其他任何地方可以给这个channel发送数据&lt;/strong>，这就导致Goroutine被永久的阻塞在了第39行。第40行的&lt;code>fmt.Println&lt;/code>就永远不会执行。&lt;/p>
&lt;p>在这个例子中，这种Goroutine泄漏可以在一次代码审核中很快被识别出来。不幸的是，生成环境Goroutine泄漏往往很难被发现。我没办法穷举Goroutine泄漏的情景，但是本博文会消息讨论你可能会遇到的一种Goroutine泄漏。&lt;/p>
&lt;h2 id="泄漏被遗忘的发送者">泄漏：被遗忘的发送者&lt;/h2>
&lt;p>(&lt;em>注：个人理解，原作者想表达的”被遗忘的发送者“是指 - gorouting阻塞在了往（非缓冲）channel发送数据，因为由于种种原因程序中其他地方没有从channel中接收&lt;/em>)&lt;/p>
&lt;p>&lt;em>&lt;strong>在这个泄漏的例子中，你将看到一个Goroutine被永久阻塞，等待发送数据给channel&lt;/strong>&lt;/em>&lt;/p>
&lt;p>我们将看到的这个程序 - 基于关键字查找记录然后打印。该程序围绕一个&lt;code>search&lt;/code>函数构建：&lt;/p>
&lt;p>&lt;strong>Listing 2&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://play.golang.org/p/o6_eMjxMVFv">https://play.golang.org/p/o6_eMjxMVFv&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln">1&lt;/span>&lt;span class="mi">29&lt;/span> &lt;span class="c1">// search simulates a function that finds a record based
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">30&lt;/span> &lt;span class="c1">// on a search term. It takes 200ms to perform this work.
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">31&lt;/span> &lt;span class="kd">func&lt;/span> &lt;span class="nf">search&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">term&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="mi">32&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">200&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Millisecond&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="mi">33&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="s">&amp;#34;some value&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="ln">6&lt;/span>&lt;span class="mi">34&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Listing 2中的&lt;code>search&lt;/code>函数的第31行，模拟了一个长时间运行的耗时操作，比如数据库查询或者Web调用。在这里，假设这个耗时操作为200ms。调用&lt;code>search&lt;/code>函数的代码在Listing 3中，如下所示：&lt;/p>
&lt;p>&lt;strong>Listing 3&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln"> 1&lt;/span>&lt;span class="mi">17&lt;/span> &lt;span class="c1">// process is the work for the program. It finds a record
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">18&lt;/span> &lt;span class="c1">// then prints it.
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">19&lt;/span> &lt;span class="kd">func&lt;/span> &lt;span class="nf">process&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">term&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="mi">20&lt;/span> &lt;span class="nx">record&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">search&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">term&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 5&lt;/span>&lt;span class="mi">21&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 6&lt;/span>&lt;span class="mi">22&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;span class="ln"> 7&lt;/span>&lt;span class="mi">23&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln"> 8&lt;/span>&lt;span class="mi">24&lt;/span>
&lt;span class="ln"> 9&lt;/span>&lt;span class="mi">25&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Received:&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">record&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">10&lt;/span>&lt;span class="mi">26&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="ln">11&lt;/span>&lt;span class="mi">27&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Listing 3中第19行，定义了一个&lt;code>process&lt;/code>函数，它接受一个字符串类型的参数&lt;code>term&lt;/code>，这个参数就表示搜索关键字。第20行，&lt;code>term&lt;/code>传递给&lt;code>search&lt;/code>函数该函数返回一条记录和错误。如果有错误发生，在第22行返回错误，否则在第25行打印这条记录。&lt;/p>
&lt;p>对于一些应用而言，串行的调用&lt;code>search&lt;/code>带来的时延或许无法接受。假设&lt;code>search&lt;/code>无法更快的运行了，&lt;code>processs&lt;/code>函数可以修改成不必完全消耗在等待&lt;code>search&lt;/code>返回结果。为了达到这个目的，如下面Listing 4所示，可以使用一个Goroutine来解决这个问题。不幸的是，这个尝试是有问题的，它带来了潜在的Goroutine泄漏。&lt;/p>
&lt;p>&lt;strong>Listing 4&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://play.golang.org/p/m0DHuchgX0A">https://play.golang.org/p/m0DHuchgX0A&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln"> 1&lt;/span>&lt;span class="mi">38&lt;/span> &lt;span class="c1">// result wraps the return values from search. It allows us
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">39&lt;/span> &lt;span class="c1">// to pass both values across a single channel.
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">40&lt;/span> &lt;span class="kd">type&lt;/span> &lt;span class="nx">result&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="mi">41&lt;/span> &lt;span class="nx">record&lt;/span> &lt;span class="kt">string&lt;/span>
&lt;span class="ln"> 5&lt;/span>&lt;span class="mi">42&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="kt">error&lt;/span>
&lt;span class="ln"> 6&lt;/span>&lt;span class="mi">43&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln"> 7&lt;/span>&lt;span class="mi">44&lt;/span>
&lt;span class="ln"> 8&lt;/span>&lt;span class="mi">45&lt;/span> &lt;span class="c1">// process is the work for the program. It finds a record
&lt;/span>&lt;span class="ln"> 9&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">46&lt;/span> &lt;span class="c1">// then prints it. It fails if it takes more than 100ms.
&lt;/span>&lt;span class="ln">10&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">47&lt;/span> &lt;span class="kd">func&lt;/span> &lt;span class="nf">process&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">term&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">11&lt;/span>&lt;span class="mi">48&lt;/span>
&lt;span class="ln">12&lt;/span>&lt;span class="mi">49&lt;/span> &lt;span class="c1">// Create a context that will be canceled in 100ms.
&lt;/span>&lt;span class="ln">13&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">50&lt;/span> &lt;span class="nx">ctx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">cancel&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">context&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">WithTimeout&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">context&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Background&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="mi">100&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Millisecond&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">14&lt;/span>&lt;span class="mi">51&lt;/span> &lt;span class="k">defer&lt;/span> &lt;span class="nf">cancel&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="ln">15&lt;/span>&lt;span class="mi">52&lt;/span>
&lt;span class="ln">16&lt;/span>&lt;span class="mi">53&lt;/span> &lt;span class="c1">// Make a channel for the goroutine to report its result.
&lt;/span>&lt;span class="ln">17&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">54&lt;/span> &lt;span class="nx">ch&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="nx">result&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">18&lt;/span>&lt;span class="mi">55&lt;/span>
&lt;span class="ln">19&lt;/span>&lt;span class="mi">56&lt;/span> &lt;span class="c1">// Launch a goroutine to find the record. Create a result
&lt;/span>&lt;span class="ln">20&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">57&lt;/span> &lt;span class="c1">// from the returned values to send through the channel.
&lt;/span>&lt;span class="ln">21&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">58&lt;/span> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">22&lt;/span>&lt;span class="mi">59&lt;/span> &lt;span class="nx">record&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">search&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">term&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">23&lt;/span>&lt;span class="mi">60&lt;/span> &lt;span class="nx">ch&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="nx">result&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="nx">record&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="ln">24&lt;/span>&lt;span class="mi">61&lt;/span> &lt;span class="p">}()&lt;/span>
&lt;span class="ln">25&lt;/span>&lt;span class="mi">62&lt;/span>
&lt;span class="ln">26&lt;/span>&lt;span class="mi">63&lt;/span> &lt;span class="c1">// Block waiting to either receive from the goroutine&amp;#39;s
&lt;/span>&lt;span class="ln">27&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">64&lt;/span> &lt;span class="c1">// channel or for the context to be canceled.
&lt;/span>&lt;span class="ln">28&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">65&lt;/span> &lt;span class="k">select&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">29&lt;/span>&lt;span class="mi">66&lt;/span> &lt;span class="k">case&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Done&lt;/span>&lt;span class="p">():&lt;/span>
&lt;span class="ln">30&lt;/span>&lt;span class="mi">67&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nx">errors&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">New&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;search canceled&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">31&lt;/span>&lt;span class="mi">68&lt;/span> &lt;span class="k">case&lt;/span> &lt;span class="nx">result&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">ch&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="ln">32&lt;/span>&lt;span class="mi">69&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">result&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">33&lt;/span>&lt;span class="mi">70&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nx">result&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">err&lt;/span>
&lt;span class="ln">34&lt;/span>&lt;span class="mi">71&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">35&lt;/span>&lt;span class="mi">72&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Received:&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">result&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">record&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">36&lt;/span>&lt;span class="mi">73&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="ln">37&lt;/span>&lt;span class="mi">74&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">38&lt;/span>&lt;span class="mi">75&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Listing 4的第50行，&lt;code>process&lt;/code>函数创建了一个100ms的&lt;code>Cancel Context&lt;/code>。关于如何使用&lt;code>Context&lt;/code>你可以阅读&lt;a href="https://blog.golang.org/context">golang.org blog post&lt;/a>。&lt;/p>
&lt;p>第54行，程序创建了一个非缓冲（阻塞）channel允许对它发送&lt;code>result&lt;/code>类型数据或者从它接收。第58行到61行定义了一个匿名函数并启动了一个Goroutine开始执行。这个Goroutine调用了&lt;code>search&lt;/code>函数而后在第60行把返回结果发送到channel。在这个Goroutine工作的时候，&lt;code>process&lt;/code>执行第65行的&lt;code>select&lt;/code>代码块，这个代码块有两个&lt;code>case&lt;/code>分支等待从对应的channel接收数据。&lt;/p>
&lt;p>第66行，这个分支从&lt;code>ctx.Done()&lt;/code>这个channel上接收数据，如果对应的&lt;code>Context&lt;/code>由于100ms超时这个case则被执行。如果这个分支被执行，&lt;code>process&lt;/code>函数则返回错误报告&lt;code>seacrh&lt;/code>超时了。或者说，第68行的分支执行了，意味着&lt;code>search&lt;/code>正常返回了并把结果赋给了变量&lt;code>result&lt;/code>。如上面Listing 3中串行调用&lt;code>search&lt;/code>的那样，第69和70行，程序判断&lt;code>search&lt;/code>函数是否返回错误，如果有则处理错误。如果没有错误，那么在第72行打印结果而后最终发挥&lt;code>nil&lt;/code>给上层调用者。&lt;/p>
&lt;p>这个版本的重构，在&lt;code>process&lt;/code>函数中设定了一个等待&lt;code>search&lt;/code>完成的最长时间，也就是100ms。然后，这种方式也带来了潜在的Goroutine泄漏。想一想这个Goroutine做的事情，在第60行发送结果到channel - 这个操作会阻塞直到另一个Goroutine读取了这个channel里的数据。但是考虑超时的情况，如果超时先发生了（&lt;code>search&lt;/code>还没返回结果），那么&lt;code>select&lt;/code>块就结束等待往下进行（&lt;code>case &amp;lt;-ctx.Done()&lt;/code>分支)，由于channel里的数据没有地方消费那么Goroutine就永久阻塞（第60行），这就导致了Goroutine泄漏。&lt;/p>
&lt;h2 id="修复给channel点空间非缓冲---缓冲">修复：给channel点空间（非缓冲 -&amp;gt; 缓冲）&lt;/h2>
&lt;p>上面的泄漏问题，最简单的解决方式就是 - 把原先的非缓冲（阻塞）channel修改为容量为1的缓冲（非阻塞）channel。&lt;/p>
&lt;p>&lt;strong>Listing 5&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://play.golang.org/p/u3xtQ48G3qK">https://play.golang.org/p/u3xtQ48G3qK&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln">1&lt;/span>&lt;span class="mi">53&lt;/span> &lt;span class="c1">// Make a channel for the goroutine to report its result.
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">54&lt;/span> &lt;span class="c1">// Give it capacity so sending doesn&amp;#39;t block.
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">55&lt;/span> &lt;span class="nx">ch&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="nx">result&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在在超时的那个分支，即使由于超时导致&lt;code>select&lt;/code>块结束等待往下进行（&lt;code>case &amp;lt;-ctx.Done()&lt;/code>分支)，启动&lt;code>search&lt;/code>的那个Goroutine最终也会得到搜索结果并发送到channel进而执行完成返回而不阻塞。最终Goroutine以及channel占用的内存都会被释放掉。所有事情自然而然的都解决了。&lt;/p>
&lt;p>在William Kennedy的一片博文&lt;a href="https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html">The Behavior of Channels&lt;/a>中，他给出了一些很不错的关于channel行为的例子，同时也介绍了如何使用channel的哲学。那篇文章中最后一个例子Listing 10中演示的程序和本文中timeout的例子相似。你可以读一读他的博文以了解更多关于如何使用缓冲channel和如何设置容量的建议。&lt;/p>
&lt;h2 id="结论">结论&lt;/h2>
&lt;p>Go语言中很容易去使用Goroutine，但是如何明智的使用是我们的责任。在本文中，我展示一个错误的使用Goroutine的例子。还有许许多多其他陷阱一样，也是有许许多多的方式会造成并发编程中的Goroutine的泄漏。在将来的博文中，我会提供更多关于Goroutine泄漏的例子和陷阱。现在我留给你一个建议：任何时候你需要启动一个Goroutine的时候，你必须要问问你自己：&lt;/p>
&lt;ul>
&lt;li>它何时会终止？&lt;/li>
&lt;li>有哪些情况会阻碍它终止？&lt;/li>
&lt;/ul>
&lt;p>&lt;em>&lt;strong>并发是非常有用的工具，但是你一定要非常小心的使用它。&lt;/strong>&lt;/em>&lt;/p></description></item><item><title>[译]Protocol Buffer Language Guide (proto3)</title><link>https://www.jonathanlin.top/posts/protocol-buffer-language-guide/</link><pubDate>Tue, 06 Jul 2021 14:49:22 +0800</pubDate><guid>https://www.jonathanlin.top/posts/protocol-buffer-language-guide/</guid><description>
&lt;p>原文链接：&lt;a href="https://developers.google.com/protocol-buffers/docs/proto3">Language Guide (proto3) | Protocol Buffers | Google Developers&lt;/a>&lt;/p>
&lt;p>本指导文档描述了如何使用protocol buffer语言来构建你的protocol buffer数据，包括&lt;code>.proto&lt;/code>文件的语法规则，包括如何从你的&lt;code>.proto&lt;/code>文件中生成数据访问类。本文介绍的是&lt;strong>proto3&lt;/strong>版本的语言规则，关于&lt;strong>proto2&lt;/strong>版本的信息，请参考： &lt;a href="https://developers.google.com/protocol-buffers/docs/proto">Proto2 Language Guide&lt;/a>。&lt;/p>
&lt;p>本文是一个指导性的参考文档，关于如何使用本文中提及的特性的例子，请参考&lt;a href="https://developers.google.com/protocol-buffers/docs/tutorials">tutorial&lt;/a> 并选择你想要的特定编程语言的例子。&lt;/p>
&lt;h2 id="定义一个消息类型">定义一个消息类型&lt;/h2>
&lt;p>首先让我们来看一个非常简单的例子。比如说你想要定义一个搜索请求这样一个消息，这个消息里包含一个查询字符串（query string）、你所感兴趣页面的数量以及每个页面包含的结果。如下是你的&lt;code>.proto&lt;/code>文件定义：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="n">syntax&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;proto3&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">SearchRequest&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">4&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="n">query&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">5&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">int32&lt;/span> &lt;span class="n">page_number&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">6&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">int32&lt;/span> &lt;span class="n">result_per_page&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">7&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>第一行说明你使用的是&lt;code>proto3&lt;/code>版本的语言规则。如果没有这一行，那么protocol buffer编译器会认为你是使用&lt;code>proto2&lt;/code> 版本的语言规则。&lt;code>syntax&lt;/code>定义必须是在&lt;code>.proto&lt;/code>文件的第一行&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>SearchRequest&lt;/code>包含了三个字段（键值对），每个字段都有一个名字和对应的数据类型&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="指定字段类型">指定字段类型&lt;/h3>
&lt;p>上面的例子中，三个字段都是&lt;a href="#%E6%A0%87%E9%87%8F%E7%B1%BB%E5%9E%8B">标量类型&lt;/a>（相对与复合类型，比如struct而言)：两个整型变量（&lt;code>page_number&lt;/code>和&lt;code>result_per_page&lt;/code>）和一个字符串变量（&lt;code>query&lt;/code>)。当然，你可以定义你的字段为复合类型，比如&lt;a href="#%E6%9E%9A%E4%B8%BE">枚举&lt;/a>和其他消息类型。&lt;/p>
&lt;h3 id="分配字段号码">分配字段号码&lt;/h3>
&lt;p>正如你所见，消息定义中的每一个字段都一个唯一的号码。这些字段号码是在二进制消息格式中（&lt;a href="https://developers.google.com/protocol-buffers/docs/encoding">message binary format&lt;/a>）的标识，一旦你开始使用你定义的消息，这些字段号码都不应该再改变。注意，字段号码为1到15的字段在编码的时候占用一个字节（包括字段号码和字段类型，关于这点的更多细节，请参看：&lt;a href="https://developers.google.com/protocol-buffers/docs/encoding#structure">Protocol Buffer Encoding&lt;/a>）。字段号码从16到2047的字段会占用两个字节。因此你应该将1到15范围的号码留给那些在消息里经常用到的字段。并且要考虑预留一些该范围的号码，以便将来扩展你的消息。&lt;/p>
&lt;p>你可以使用的最小字段号码是1，最大字段2&lt;sup>29&lt;/sup> - 1或者536,870,911。你不可以使用字段号码为19000到19999的部分（&lt;code>FieldDescriptor::kFirstReservedNumber&lt;/code> 到 &lt;code>FieldDescriptor::kLastReservedNumber&lt;/code>），这些是为protocol buffer本身的实现所保留的 - 如果你在&lt;code>.proto&lt;/code>文件中使用了这些保留范围内的字段号码，编译器报错。同样的，如果你使用了那些被标记为&lt;code>reserved&lt;/code>的字段号码，编译器也会报错。&lt;/p>
&lt;h3 id="指定字段规则">指定字段规则&lt;/h3>
&lt;p>消息的字段可以是下面两种形式：&lt;/p>
&lt;ul>
&lt;li>单数形式：一个良好组织的消息可以有零个或者一个这种字段（不能超过一个）。这是&lt;code>proto3&lt;/code>版本的默认字段规则。（个人理解，这里不是说只能定义零个或者一个这种单数形式的字段，而是说定义为单数形式的字段里最多包含一个元素。这个要对应&lt;code>repeated&lt;/code>来理解）&lt;/li>
&lt;li>&lt;code>repeated&lt;/code>：这种字段对应的元素在一个消息里可以重复任意多次。&lt;code>repeated&lt;/code>中的元素的顺序是固定的。&lt;/li>
&lt;/ul>
&lt;p>在&lt;code>proto3&lt;/code>中，标量类型的&lt;code>repeated&lt;/code>字段是默认是使用&lt;code>packed&lt;/code>来编码的。你可以从&lt;a href="https://developers.google.com/protocol-buffers/docs/encoding#packed">Protocol Buffer Encoding&lt;/a>中了解更多关于&lt;code>packed&lt;/code>编码的信息。&lt;/p>
&lt;h3 id="添加更多的消息类型">添加更多的消息类型&lt;/h3>
&lt;p>在一个&lt;code>.proto&lt;/code>文件中你可以定义多种不同的消息类型，如果你奥定义多个相关的消息，这就非常有用 - 比如你想要定义和&lt;code>SearchRequest&lt;/code>相对应的&lt;code>SearchResponse&lt;/code>消息，你可以在同一个&lt;code>.proto&lt;/code>文件中添加：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">SearchRequest&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="n">query&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">int32&lt;/span> &lt;span class="n">page_number&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">4&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">int32&lt;/span> &lt;span class="n">result_per_page&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">5&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">6&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">7&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">SearchResponse&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">8&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="o">...&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">9&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="添加注释">添加注释&lt;/h3>
&lt;p>在&lt;code>.proto&lt;/code>中添加注释，你可以使用C/C++风格的语法：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="cm">/* SearchRequest represents a search query, with pagination options to
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="cm"> * indicate which results to include in the response. */&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">4&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">SearchRequest&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">5&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="n">query&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">6&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">int32&lt;/span> &lt;span class="n">page_number&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// Which page number do we want?
&lt;/span>&lt;span class="ln">7&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int32&lt;/span> &lt;span class="n">result_per_page&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// Number of results to return per page.
&lt;/span>&lt;span class="ln">8&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="保留字段">保留字段&lt;/h3>
&lt;p>如果你&lt;a href="#%E6%9B%B4%E6%96%B0%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B">更新息类型&lt;/a>的时候删除了一个字段，或者把一个字段注释掉，将来其他人在更新相同的消息的时候是可以重用之前字段的号码。之后在他们使用老版本的&lt;code>.proto&lt;/code>时将会导致许多问题，包括数据出错，privacy bugs等。为了确保这些问题不会发生，有一个办法是把那些你删除的字段的使用过的字段号码（和/或名称）标记为&lt;code>reserved&lt;/code>。如果你使用了这些被&lt;code>reserved&lt;/code>标记的号码，编译器会报错。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">Foo&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">reserved&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">15&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">9&lt;/span> &lt;span class="k">to&lt;/span> &lt;span class="mi">11&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">reserved&lt;/span> &lt;span class="s">&amp;#34;foo&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;bar&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">4&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意，你不可以在同一个&lt;code>reserved&lt;/code>语句中同时制定字段号码和字段名称。&lt;/p>
&lt;h3 id="从proto文件中生成的代码">从&lt;code>.proto&lt;/code>文件中生成的代码&lt;/h3>
&lt;p>当你编译&lt;code>.proto&lt;/code>文件时，编译器会生成你指定的语言代码来和你定义在&lt;code>.proto&lt;/code>文件中消息交互，包括访问和设置字段的值、序列化你的消息问输出流以及从输入流中解析为消息。&lt;/p>
&lt;ul>
&lt;li>**C++**语言：生成&lt;code>.h&lt;/code>和&lt;code>.cc&lt;/code>文件，每个消息都会生成一个对应的类&lt;/li>
&lt;li>&lt;strong>Java&lt;/strong>语言，每个消息都会生成一个包含对应类的&lt;code>.java&lt;/code>文件，以及创建对应类实例的&lt;code>Builder&lt;/code>类&lt;/li>
&lt;li>&lt;strong>Kotlin&lt;/strong>语言，除了和Java语言生成的一样的代码以外，还会生成一个&lt;code>.kt&lt;/code>文件包含一个用例创建类型实例的DSL&lt;/li>
&lt;li>&lt;strong>Pytyon&lt;/strong>语言少许不同，生成一个包含了每个消息对应的静态描述器的模块，这些被用来在运行时创建必要的Python数据访问类&lt;/li>
&lt;li>&lt;strong>Go&lt;/strong>语言，生成一个包含所有消息的&lt;code>.pb.go&lt;/code>代码文件&lt;/li>
&lt;li>&lt;strong>Ruby&lt;/strong>语言，生成一个包含所有消息的&lt;code>.rb&lt;/code>代码文件&lt;/li>
&lt;li>&lt;strong>Object-C&lt;/strong>语言，生成一个&lt;code>probjc.h&lt;/code>和&lt;code>projc.m&lt;/code>文件，每一个消息对应了一个类&lt;/li>
&lt;li>**C#**语言，生成一个&lt;code>.cs&lt;/code>文件，每一个消息对应了一个类&lt;/li>
&lt;li>&lt;strong>Dart&lt;/strong>，生成一个&lt;code>.pb.dart&lt;/code>文件，每一个消息对应了一个类&lt;/li>
&lt;/ul>
&lt;p>关于特定语言的API的使用，你可以参考：&lt;a href="https://developers.google.com/protocol-buffers/docs/reference/overview">API reference&lt;/a>。&lt;/p>
&lt;h2 id="标量类型">标量类型&lt;/h2>
&lt;p>标量类型即下表中的一种类型。下表展示了&lt;code>.proto&lt;/code>中支持的标量类型和特定语言标量类型的对应关系（原文有更多的编程语言的对应关系，译文中我只选取我关心的语言☺）：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">.proto Type&lt;/th>
&lt;th style="text-align:left">Notes&lt;/th>
&lt;th style="text-align:left">C++ Type&lt;/th>
&lt;th style="text-align:left">Java/Kotlin Type[1]&lt;/th>
&lt;th style="text-align:left">Python Type[3]&lt;/th>
&lt;th style="text-align:left">Go Type&lt;/th>
&lt;th style="text-align:left">C# Type&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">double&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;td style="text-align:left">double&lt;/td>
&lt;td style="text-align:left">double&lt;/td>
&lt;td style="text-align:left">float&lt;/td>
&lt;td style="text-align:left">float64&lt;/td>
&lt;td style="text-align:left">double&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">float&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;td style="text-align:left">float&lt;/td>
&lt;td style="text-align:left">float&lt;/td>
&lt;td style="text-align:left">float&lt;/td>
&lt;td style="text-align:left">float32&lt;/td>
&lt;td style="text-align:left">float&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">int32&lt;/td>
&lt;td style="text-align:left">Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead.&lt;/td>
&lt;td style="text-align:left">int32&lt;/td>
&lt;td style="text-align:left">int&lt;/td>
&lt;td style="text-align:left">int&lt;/td>
&lt;td style="text-align:left">int32&lt;/td>
&lt;td style="text-align:left">int&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">int64&lt;/td>
&lt;td style="text-align:left">Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead.&lt;/td>
&lt;td style="text-align:left">int64&lt;/td>
&lt;td style="text-align:left">long&lt;/td>
&lt;td style="text-align:left">int/long[4]&lt;/td>
&lt;td style="text-align:left">int64&lt;/td>
&lt;td style="text-align:left">long&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">uint32&lt;/td>
&lt;td style="text-align:left">Uses variable-length encoding.&lt;/td>
&lt;td style="text-align:left">uint32&lt;/td>
&lt;td style="text-align:left">int[2]&lt;/td>
&lt;td style="text-align:left">int/long[4]&lt;/td>
&lt;td style="text-align:left">uint32&lt;/td>
&lt;td style="text-align:left">uint&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">uint64&lt;/td>
&lt;td style="text-align:left">Uses variable-length encoding.&lt;/td>
&lt;td style="text-align:left">uint64&lt;/td>
&lt;td style="text-align:left">long[2]&lt;/td>
&lt;td style="text-align:left">int/long[4]&lt;/td>
&lt;td style="text-align:left">uint64&lt;/td>
&lt;td style="text-align:left">ulong&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">sint32&lt;/td>
&lt;td style="text-align:left">Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s.&lt;/td>
&lt;td style="text-align:left">int32&lt;/td>
&lt;td style="text-align:left">int&lt;/td>
&lt;td style="text-align:left">int&lt;/td>
&lt;td style="text-align:left">int32&lt;/td>
&lt;td style="text-align:left">int&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">sint64&lt;/td>
&lt;td style="text-align:left">Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s.&lt;/td>
&lt;td style="text-align:left">int64&lt;/td>
&lt;td style="text-align:left">long&lt;/td>
&lt;td style="text-align:left">int/long[4]&lt;/td>
&lt;td style="text-align:left">int64&lt;/td>
&lt;td style="text-align:left">long&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">fixed32&lt;/td>
&lt;td style="text-align:left">Always four bytes. More efficient than uint32 if values are often greater than 228.&lt;/td>
&lt;td style="text-align:left">uint32&lt;/td>
&lt;td style="text-align:left">int[2]&lt;/td>
&lt;td style="text-align:left">int/long[4]&lt;/td>
&lt;td style="text-align:left">uint32&lt;/td>
&lt;td style="text-align:left">uint&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">fixed64&lt;/td>
&lt;td style="text-align:left">Always eight bytes. More efficient than uint64 if values are often greater than 256.&lt;/td>
&lt;td style="text-align:left">uint64&lt;/td>
&lt;td style="text-align:left">long[2]&lt;/td>
&lt;td style="text-align:left">int/long[4]&lt;/td>
&lt;td style="text-align:left">uint64&lt;/td>
&lt;td style="text-align:left">ulong&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">sfixed32&lt;/td>
&lt;td style="text-align:left">Always four bytes.&lt;/td>
&lt;td style="text-align:left">int32&lt;/td>
&lt;td style="text-align:left">int&lt;/td>
&lt;td style="text-align:left">int&lt;/td>
&lt;td style="text-align:left">int32&lt;/td>
&lt;td style="text-align:left">int&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">sfixed64&lt;/td>
&lt;td style="text-align:left">Always eight bytes.&lt;/td>
&lt;td style="text-align:left">int64&lt;/td>
&lt;td style="text-align:left">long&lt;/td>
&lt;td style="text-align:left">int/long[4]&lt;/td>
&lt;td style="text-align:left">int64&lt;/td>
&lt;td style="text-align:left">long&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">bool&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;td style="text-align:left">bool&lt;/td>
&lt;td style="text-align:left">boolean&lt;/td>
&lt;td style="text-align:left">bool&lt;/td>
&lt;td style="text-align:left">bool&lt;/td>
&lt;td style="text-align:left">bool&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">A string must always contain UTF-8 encoded or 7-bit ASCII text, and cannot be longer than 232.&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">String&lt;/td>
&lt;td style="text-align:left">str/unicode[5]&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">bytes&lt;/td>
&lt;td style="text-align:left">May contain any arbitrary sequence of bytes no longer than 232.&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">ByteString&lt;/td>
&lt;td style="text-align:left">str&lt;/td>
&lt;td style="text-align:left">[]byte&lt;/td>
&lt;td style="text-align:left">ByteString&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>你可以从&lt;a href="https://developers.google.com/protocol-buffers/docs/encoding">Protocol Buffer Encoding&lt;/a>了解更多关于消息序列化时的编码相关的信息。&lt;/p>
&lt;h2 id="默认值">默认值&lt;/h2>
&lt;p>解析消息的时候，如果原先经过编码的消息里没有包含特定的单数形式的元素（原文很拗口，个人觉得这里就是说从编码的消息里解析的时候找不到特定的字段），那些这些字段就被赋值成对应类型的默认值，规则如下：&lt;/p>
&lt;ul>
&lt;li>strings类型的默认值是空字符串&lt;/li>
&lt;li>bytes类型的默认值是空字节&lt;/li>
&lt;li>bools类型的默认值是false&lt;/li>
&lt;li>数字类型的默认值是0&lt;/li>
&lt;li>&lt;a href="#%E6%9E%9A%E4%B8%BE">枚举类型&lt;/a>类型的默认值是枚举的第一个元素，也就是枚举值为0的元素&lt;/li>
&lt;li>如果字段类型是其他的消息，那么其默认值跟特定的语言相关，详见：&lt;a href="https://developers.google.com/protocol-buffers/docs/reference/overview">generated code guide&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;code>repeated&lt;/code>类型的字段的默认值一般是对应语言里的空列表。&lt;/p>
&lt;p>对于标量类型的字段，实际上消息解析以后是没办法确定字段的值是人为设置的还是由于根本就没有赋值，而后解析的时候被解析成了默认值 - 你在定义消息的时候需要牢记这一点。例如说，不要定义一个boolean类型的开关是的当值为false的时候执行某些动作（如果你不希望这个动作默认是要执行的，因为boolean类型的默认值就是false）。同时还需要注意，当一个标量字段被设置为默认值的时候，值是不会被序列化的。&lt;/p>
&lt;h2 id="枚举">枚举&lt;/h2>
&lt;p>当你定义你的消息的时候，你可能希望某些字段的值只能从一些预先定义好的值里来。例如，你想为你的&lt;code>SearchRequest&lt;/code>添加一个&lt;code>corpus&lt;/code>字段，这个字段的值可以是&lt;code>UNIVERSAL&lt;/code>, &lt;code>WEB&lt;/code>, &lt;code>IMAGES&lt;/code>, &lt;code>LOCAL&lt;/code>, &lt;code>NEWS&lt;/code>, &lt;code>PRODUCTS&lt;/code> 或者 &lt;code>VIDEO&lt;/code>。你可以通过定义枚举类满足你的需求，枚举中所有可能的值都是一个常量。&lt;/p>
&lt;p>下面的例子中我们添加了一个名为&lt;code>Corpus&lt;/code>的枚举，这个枚举中定义了它可能的值，同时也定义类型为&lt;code>Corpus&lt;/code>的字段：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">SearchRequest&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="n">query&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">int32&lt;/span> &lt;span class="n">page_number&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 4&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">int32&lt;/span> &lt;span class="n">result_per_page&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 5&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kd">enum&lt;/span> &lt;span class="n">Corpus&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 6&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">UNIVERSAL&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 7&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">WEB&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 8&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">IMAGES&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 9&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">LOCAL&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">10&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">NEWS&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">11&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">PRODUCTS&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">12&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">VIDEO&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">13&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">14&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">Corpus&lt;/span> &lt;span class="n">corpus&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">15&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如你所见，枚举&lt;code>Corpus&lt;/code>中的第一个值&lt;code>UNIVERSAL&lt;/code>是常量0：实际上所有的枚举的第一个常量值都应该是0，这是因为：&lt;/p>
&lt;ul>
&lt;li>一定得有0值，这样枚举可以当成数字类型，默认值就是0&lt;/li>
&lt;li>0值作为枚举的第一个元素，这个和&lt;code>proto2&lt;/code>的语言兼容，即第一个元素的值总是默认值&lt;/li>
&lt;/ul>
&lt;p>你可以通过给不同的枚举元素赋相同的值来定义别名，前提是你需要把&lt;code>allow_alias&lt;/code>选项设置为&lt;code>true&lt;/code>，否者编译器遇到这样的别名设置会报错。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">MyMessage1&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kd">enum&lt;/span> &lt;span class="n">EnumAllowingAlias&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="k">option&lt;/span> &lt;span class="n">allow_alias&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 4&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">UNKNOWN&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 5&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">STARTED&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 6&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">RUNNING&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 7&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 8&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 9&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">MyMessage2&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">10&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kd">enum&lt;/span> &lt;span class="n">EnumNotAllowingAlias&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">11&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">UNKNOWN&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">12&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">STARTED&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">13&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="c1">// RUNNING = 1; // Uncommenting this line will cause a compile error inside Google and a warning message outside.
&lt;/span>&lt;span class="ln">14&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">15&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>枚举元素的值不能超过32位整型的范围。由于枚举值是使用&lt;a href="https://developers.google.com/protocol-buffers/docs/encoding">varint encoding&lt;/a> 编码，负值是无效的因此也不建议使用负值。你可以在一个消息内部定义枚举（如上面的例子所示）或者外部定义，然后可以在&lt;code>.proto&lt;/code>中定义的任意消息里使用内部或者外部定义的枚举。你可以像使用消息里的字段一样来使用定义在一个消息内部的枚举：&lt;code>_MessageType_._EnumType_&lt;/code>。&lt;/p>
&lt;p>在&lt;code>.proto&lt;/code>中定义的&lt;code>enum&lt;/code>，对应生成的代码中，比如Java，Kotlin，C++也会有对应的&lt;code>enum&lt;/code>，Pyton语言是&lt;code>EnumDescriptor&lt;/code>类。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>注意:&lt;/strong> 对于枚举类型的值的个数限制，这个是和编程语言本身相关，关于这个限制请查看特定的语言说明。&lt;/p>
&lt;/blockquote>
&lt;p>在反序列化的时候，对于无法识别的枚举值，也会在消息中保留下来，至于保留下来以何种方式展现，这个就和语言相关了。对于那些允许枚举值越界的变成语言，比如C++和Go，这些未知的枚举值就是被简单的以整型形式保留。对于不允许枚举值越界的语言，比如Java，可以通过特定的访问器来访问底层的整型值。不管何种情况，消息序列化的时候，会把无法识别的枚举值包含进去。&lt;/p>
&lt;p>更多关于如何使用&lt;code>enum&lt;/code>的信息，请参考：&lt;a href="https://developers.google.com/protocol-buffers/docs/reference/overview">generated code guide&lt;/a>中特定编程语言的部分。&lt;/p>
&lt;h3 id="枚举保留值">枚举保留值&lt;/h3>
&lt;p>如果你&lt;a href="#%E6%9B%B4%E6%96%B0%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B">更新消息类型&lt;/a>的时候删除了一个枚举项或者注释掉，后面其他人在更新这个枚举的时候可以重用原枚举项对应的数值。之后在他们使用老版本的&lt;code>.proto&lt;/code>时将会导致许多问题，包括数据出错，privacy bugs等。为了确保这些问题不会发生，有一个办法是把那些你删除的枚举项的使用过的数值（和/或名称）标记为&lt;code>reserved&lt;/code>。如果你使用了这些被&lt;code>reserved&lt;/code>标记的号码，编译器会报错。你可以指定你保留的枚举数值的范围，你可以使用&lt;code>max&lt;/code>关键字来指定范围的最大值。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="kd">enum&lt;/span> &lt;span class="n">Foo&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">reserved&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">15&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">9&lt;/span> &lt;span class="k">to&lt;/span> &lt;span class="mi">11&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">40&lt;/span> &lt;span class="k">to&lt;/span> &lt;span class="k">max&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">reserved&lt;/span> &lt;span class="s">&amp;#34;FOO&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;BAR&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">4&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意，你不可以在同一个&lt;code>reserved&lt;/code>语句中同时指定枚举项的名称和枚举值。&lt;/p>
&lt;h2 id="使用其他消息类型">使用其他消息类型&lt;/h2>
&lt;p>你可以使用其他消息作为你的字段的类型。例如，你希望你的&lt;code>SearchResponse&lt;/code>中包含&lt;code>Result&lt;/code>类型的字段 - 你可以在同一个&lt;code>.proto&lt;/code>文件找那个定义&lt;code>Result&lt;/code>消息，然后指定&lt;code>SearchResponse&lt;/code>的字段为&lt;code>Result&lt;/code>类型：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">SearchResponse&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="k">repeated&lt;/span> &lt;span class="n">Result&lt;/span> &lt;span class="n">results&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">4&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">5&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">Result&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">6&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="n">url&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">7&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="n">title&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">8&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="k">repeated&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="n">snippets&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">9&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="导入定义">导入定义&lt;/h3>
&lt;p>&lt;strong>注意，这个特性不适用于Java&lt;/strong>&lt;/p>
&lt;p>在上面的例子中，&lt;code>Result&lt;/code>是和&lt;code>SearchResponse&lt;/code>位于相同的&lt;code>.proto&lt;/code>文件中 - 如果你想要使用的消息类型是定义在其他&lt;code>.proto&lt;/code>文件中呢？&lt;/p>
&lt;p>你可以通过导入&lt;code>.proto&lt;/code>文件来使用定义在其他&lt;code>.proto&lt;/code>文件中的消息类型。你可以在文件头部添加import语句来导入：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="k">import&lt;/span> &lt;span class="s">&amp;#34;myproject/other_protos.proto&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>默认情况下，你只能使用直接导入的&lt;code>.proto&lt;/code>文件中定义的消息类型。但是，有时候你可能需要把&lt;code>.proto&lt;/code>文件移动到一个新的位置。你可以直接移动&lt;code>.proto&lt;/code>文件到一个新的位置，然后然后更新所有的import语句指向&lt;code>.proto&lt;/code>的新位置，你现在也可以在原来的位置放一个”假“的&lt;code>.proto&lt;/code>然后使用&lt;code>import public&lt;/code>语句把老的&lt;code>.proto&lt;/code>中的import语句重定向到新的位置。任何导入了包含&lt;code>import public&lt;/code>的&lt;code>.proto&lt;/code>文件也就把&lt;code>import public&lt;/code>的依赖也导入了。例如：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="c1">// new.proto
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="c1">// All definitions are moved here
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="c1">// old.proto
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="c1">// This is the proto that all clients are importing.
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">import&lt;/span> &lt;span class="n">public&lt;/span> &lt;span class="s">&amp;#34;new.proto&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">4&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">import&lt;/span> &lt;span class="s">&amp;#34;other.proto&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="c1">// client.proto
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">import&lt;/span> &lt;span class="s">&amp;#34;old.proto&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c1">// You use definitions from old.proto and new.proto, but not other.proto
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>protocol buffer编译器从命令行参数&lt;code>-I&lt;/code>/&lt;code>--proto_path&lt;/code>指定的一系列路径中查找导入的&lt;code>.proto&lt;/code>文件。如果这个参数没有指定一个值，编译器就从运行的目录里查找。通常地，你应该把&lt;code>--proto_path&lt;/code>的值设置为你项目的根目录，然后在import语句中使用完整的名称。&lt;/p>
&lt;h3 id="使用proto2的消息类型">使用&lt;code>proto2&lt;/code>的消息类型&lt;/h3>
&lt;p>在&lt;code>proto3&lt;/code>的消息中导入并使用&lt;code>proto2&lt;/code>的消息类型是可以的，相反也是可以。但是&lt;code>proto2&lt;/code>的枚举是无法在&lt;code>proto3&lt;/code>中使用（如果&lt;code>proto2&lt;/code>的消息体中使用&lt;code>proto2&lt;/code>枚举是可以的）&lt;/p>
&lt;h2 id="嵌套类型">嵌套类型&lt;/h2>
&lt;p>你可以在一个消息类型里定义嵌套的消息类型并使用它，如下面的例子所示 - &lt;code>Result&lt;/code>消息是定义在&lt;code>SearchResponse&lt;/code>里的：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">SearchResponse&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kd">message&lt;/span> &lt;span class="nc">Result&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="n">url&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">4&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="n">title&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">5&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="k">repeated&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="n">snippets&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">6&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">7&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="k">repeated&lt;/span> &lt;span class="n">Result&lt;/span> &lt;span class="n">results&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">8&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果你想在定义嵌套消息的父消息外使用，你可以通过&lt;code>_Parent_._Type_&lt;/code>来使用：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">SomeOtherMessage&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">SearchResponse.Result&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>你可以多层嵌套消息，如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">Outer&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// Level 0
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">message&lt;/span> &lt;span class="nc">MiddleAA&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// Level 1
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">message&lt;/span> &lt;span class="nc">Inner&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// Level 2
&lt;/span>&lt;span class="ln"> 4&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int64&lt;/span> &lt;span class="n">ival&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 5&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="n">booly&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 6&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 7&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 8&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kd">message&lt;/span> &lt;span class="nc">MiddleBB&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// Level 1
&lt;/span>&lt;span class="ln"> 9&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">message&lt;/span> &lt;span class="nc">Inner&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// Level 2
&lt;/span>&lt;span class="ln">10&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int32&lt;/span> &lt;span class="n">ival&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">11&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="n">booly&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">12&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">13&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">14&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="更新消息类型">更新消息类型&lt;/h2>
&lt;p>如果当前的消息已经不能满足你的需要，例如你希望你的消息里添加一个额外的字段，但是你仍然希望使用基于老的格式生成的代码。不用担心，更新消息类型而不破坏现有的代码是很简单的。你只需要记住以下规则：&lt;/p>
&lt;ul>
&lt;li>不要更改现有字段的字段号码&lt;/li>
&lt;li>如果你添加了新的字段，那些通过老的代码序列化出来的消息仍然可以被新的代码解析。你要牢记默认值 &lt;a href="https://developers.google.com/protocol-buffers/docs/proto3#default">default values&lt;/a>规则，这样才能恰当地和老代码生成的消息交互。同样的，新代码创建的消息也是可以被老代码解析：老代码程序解析的时候只是简单地忽略新加的字段。你可以参考&lt;a href="#%E6%9C%AA%E7%9F%A5%E5%AD%97%E6%AE%B5">未知字段&lt;/a>获取更多的细节&lt;/li>
&lt;li>字段可以被删除，但是要确保这些要删除的字段对应的字段号码不会在消息中再次被使用。你或许可以对字段重命名，比如添加&amp;quot;OBSOLETE_&amp;quot;这样的前缀，或者把字段号码标记为&lt;a href="#%E4%BF%9D%E7%95%99%E5%AD%97%E6%AE%B5">保留字段&lt;/a>，这样将来更新你的&lt;code>.proto&lt;/code>文件的时候就不会意外的使用那些号码&lt;/li>
&lt;li>&lt;code>int32&lt;/code>,&lt;code>uint32&lt;/code>,&lt;code>int64&lt;/code>,&lt;code>uint64&lt;/code>和&lt;code>bool&lt;/code>是相互兼容的 - 这意味着你从其中的一种类型改为另一种类型不会破坏向前或者向后的兼容性。如果一个解析一个数字的时候和目标类型不匹配，会发生和在C++中转化数字类型一样的结果，例如一个64位的数字读取为32位的时候，会被截断为32位的数字&lt;/li>
&lt;li>&lt;code>sint32&lt;/code>和&lt;code>sint64&lt;/code>兼容，但是和其他整型类型不兼容&lt;/li>
&lt;li>&lt;code>string&lt;/code>和&lt;code>bytes&lt;/code>兼容，只要&lt;code>bytes&lt;/code>是有效的UTF-8格式&lt;/li>
&lt;li>嵌套的消息和&lt;code>bytes&lt;/code>兼容，只要&lt;code>bytes&lt;/code>包含编码过的消息&lt;/li>
&lt;li>&lt;code>fixed32&lt;/code>和&lt;code>sfixed32&lt;/code>，&lt;code>fixed64&lt;/code>以及&lt;code>sfixed64&lt;/code>兼容&lt;/li>
&lt;li>对于&lt;code>string&lt;/code>，&lt;code>byte&lt;/code>和消息字段，&lt;code>optional&lt;/code>和&lt;code>repeated&lt;/code>兼容。如果一个&lt;code>repeated&lt;/code>类型字段的序列化数据作为输入，对于期望这个字段为&lt;code>optional&lt;/code>的客户端来说，如果这个字段是基本类型，那么会获取最后一个输入的值；如果这个字段是一个消息类型，那么会把消息里的所有元素合并（&lt;em>这个有点拗口，不知道该怎么理解&lt;/em>）。需要注意的是，对于数值类型（包括bools和enums）来说这是不安全的。数值类型的&lt;code>repeated&lt;/code>字段可以序列化为&lt;a href="https://developers.google.com/protocol-buffers/docs/encoding#packed">packed&lt;/a> 格式，如果客户端期望的是&lt;code>optional&lt;/code>字段，那么不能被正确解析&lt;/li>
&lt;li>&lt;code>enum&lt;/code>和&lt;code>int32&lt;/code>，&lt;code>uint32&lt;/code>，&lt;code>int64&lt;/code>，&lt;code>uint64&lt;/code>兼容（注意如果类型不完全匹配，数据可能被截断）。然而需要注意的是，客户端的代码在反序列的时候可能会有不同的行为，比如未识别的&lt;code>proto3 enum&lt;/code>类型的值会在消息中保留下来，这种行为是和语言本身相关。整型的字段的值总是保持了原来的值&lt;/li>
&lt;li>把一个字段的类型改为&lt;code>oneof&lt;/code>的成员是安全的且二进制上兼容。把多个字段变成&lt;code>oneof&lt;/code>或许是安全的，但是你要确保设置的代码只能有一次（&lt;em>这里也不理解是啥意思&lt;/em>）。把任何字段移到已存在的&lt;code>oneof&lt;/code>里是不安全的&lt;/li>
&lt;/ul>
&lt;h2 id="未知字段">未知字段&lt;/h2>
&lt;p>未知字段是指protocol buffer序列化数据的时候被良好的组织的数据，但是反序列化的时候解析器不认识的字段。例如，对于老代码程序解析由新代码程序序列化的带有新添加的字段的数据时，那些新添加的字段对于老代码程序就变成了未知字段。&lt;/p>
&lt;p>原先proto3消息在解析的时候总是丢弃未知字段，但是在版本3.5我们重新引入了对未知字段的保留以匹配proto2的行为。在版本3.5以及之后未知字段在解析和序列化的时候又重新保留了下来。&lt;/p>
&lt;h2 id="any">Any&lt;/h2>
&lt;p>&lt;code>Any&lt;/code>消息类型能让你像使用嵌套类型一样来使用一个消息而不需要有&lt;code>.proto&lt;/code>的定义。一个&lt;code>Any&lt;/code>消息包含一个序列化为&lt;code>bytes&lt;/code>的消息以及用来解释成对应消息类型的一个全局唯一标识符URL。你需要&lt;a href="#%E4%BD%BF%E7%94%A8%E5%85%B6%E4%BB%96%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B">导入&lt;/a>&lt;code>google/protobuf/any.proto&lt;/code>来使用&lt;code>Any&lt;/code>类型。（注：说白了，这个Any类型就是一种序列化，把一种特定类型按照某种方式序列化为字节数组）&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="k">import&lt;/span> &lt;span class="s">&amp;#34;google/protobuf/any.proto&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">ErrorStatus&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">4&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="kd">message&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">5&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="k">repeated&lt;/span> &lt;span class="n">google.protobuf.Any&lt;/span> &lt;span class="n">details&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">6&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>默认的类型URL是&lt;code>type.googleapis.com/_packagename_._messagename_&lt;/code>。&lt;/p>
&lt;p>不同的语言实现会提供类型安全的运行时库来打包和解包&lt;code>Any&lt;/code>类型的值 - 例如在Java中，&lt;code>Any&lt;/code>类型提供了&lt;code>pack()&lt;/code>和&lt;code>unpack()&lt;/code>访问器，在C++中提供了&lt;code>PackFrom()&lt;/code>和&lt;code>UnpackTo()&lt;/code>方法：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="ln"> 1&lt;/span>&lt;span class="c1">// Storing an arbitrary message type in Any.
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">NetworkErrorDetails&lt;/span> &lt;span class="n">details&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">...;&lt;/span>
&lt;span class="ln"> 3&lt;/span>&lt;span class="n">ErrorStatus&lt;/span> &lt;span class="n">status&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="n">status&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">add_details&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">PackFrom&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">details&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln"> 5&lt;/span>
&lt;span class="ln"> 6&lt;/span>&lt;span class="c1">// Reading an arbitrary message from Any.
&lt;/span>&lt;span class="ln"> 7&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">ErrorStatus&lt;/span> &lt;span class="n">status&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">...;&lt;/span>
&lt;span class="ln"> 8&lt;/span>&lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="n">Any&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="nl">detail&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">status&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">details&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">detail&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Is&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">NetworkErrorDetails&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="n">NetworkErrorDetails&lt;/span> &lt;span class="n">network_error&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="n">detail&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">UnpackTo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">network_error&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="p">...&lt;/span> &lt;span class="n">processing&lt;/span> &lt;span class="n">network_error&lt;/span> &lt;span class="p">...&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">14&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>当前用于和&lt;code>Any&lt;/code>类型交互的运行时库还在开发中&lt;/strong>。&lt;/p>
&lt;p>如果你熟悉 &lt;a href="https://developers.google.com/protocol-buffers/docs/proto">proto2 语法&lt;/a>，和&lt;code>proto2&lt;/code>消息的允许&lt;a href="https://developers.google.com/protocol-buffers/docs/proto#extensions">extensions&lt;/a>一样，&lt;code>Any&lt;/code>可以用来存放&lt;code>proto3&lt;/code>的消息。&lt;/p>
&lt;h2 id="oneof">Oneof&lt;/h2>
&lt;p>如果你的一个消息有多个字段，并且同一时刻最多只有一个字段被赋值，你可以使用&lt;code>oneof&lt;/code>特性来强制这种行为和节省内存。&lt;/p>
&lt;p>&lt;code>oneof&lt;/code>字段和常规字段一样，只是&lt;code>oneof&lt;/code>里所有的成员是共享内存的，且同一时刻最多只有一个字段被赋值。设置任何一个&lt;code>oneof&lt;/code>里的成员将自动清空其他的成员。你可以一个特殊的&lt;code>case()&lt;/code>或者&lt;code>WhichOneof()&lt;/code>方法（取决特定的语言）来判断&lt;code>oneof&lt;/code>里的成员是否被赋值了。&lt;/p>
&lt;h3 id="使用oneof">使用&lt;code>oneof&lt;/code>&lt;/h3>
&lt;p>你可以使用&lt;code>oneof&lt;/code>关键字跟上你的&lt;code>oneof&lt;/code>名称来定义一个&lt;code>oneof&lt;/code>，比如在&lt;code>test_oneof&lt;/code>中：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">SampleMessage&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="k">oneof&lt;/span> &lt;span class="n">test_oneof&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="n">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">4&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">SubMessage&lt;/span> &lt;span class="n">sub_message&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">9&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">5&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">6&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后你可以添加&lt;code>oneof&lt;/code>成员到它的定义中。你可以添加除了&lt;code>map&lt;/code>和&lt;code>repeated&lt;/code>类型的成员到&lt;code>oneof&lt;/code>定义里。在你生成的代码中，&lt;code>oneof&lt;/code>有着和常规字段一样的读写访问器。你还会有一个方法（取决特定的语言）来判断&lt;code>oneof&lt;/code>里的成员是否被赋值了。请参考特定语言的&lt;a href="https://developers.google.com/protocol-buffers/docs/reference/overview">API reference&lt;/a>以了解更多。&lt;/p>
&lt;h3 id="oneof特性">&lt;code>oneof&lt;/code>特性&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>设置任何一个&lt;code>oneof&lt;/code>里的成员将自动清空其他的成员。如果你设置了多个成员，只有最后一个设置的成员才有值。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln">1&lt;/span>&lt;span class="n">SampleMessage&lt;/span> &lt;span class="n">message&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="n">message&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">set_name&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;name&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="n">CHECK&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">message&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">has_name&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="n">message&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">mutable_sub_message&lt;/span>&lt;span class="o">();&lt;/span> &lt;span class="c1">// Will clear name field.
&lt;/span>&lt;span class="ln">5&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">CHECK&lt;/span>&lt;span class="o">(!&lt;/span>&lt;span class="n">message&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">has_name&lt;/span>&lt;span class="o">());&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>解析的时候如果遇到来自同一个&lt;code>oneof&lt;/code>的多个成员，只有最后一次看到的成员才会被解析&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>oneof&lt;/code>不用标识成&lt;code>repeat&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>反射API可以访问&lt;code>oneof&lt;/code>字段&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果&lt;code>oneof&lt;/code>字段设置为默认值（比如int32类型的&lt;code>oneof&lt;/code>成员设置为0），&lt;code>case&lt;/code>方法就会判定这个成员被设置了，这个值会被序列化&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果你使用C++，确保你的代码不会引发内存泄漏。下面的代码会奔溃原因是因为&lt;code>sub_message&lt;/code>在调用了&lt;code>set_name()&lt;/code>后就被删除了&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="ln">1&lt;/span>&lt;span class="n">SampleMessage&lt;/span> &lt;span class="n">message&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="n">SubMessage&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">sub_message&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">message&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">mutable_sub_message&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="n">message&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">set_name&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;name&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// Will delete sub_message
&lt;/span>&lt;span class="ln">4&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">sub_message&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">set_&lt;/span>&lt;span class="p">...&lt;/span> &lt;span class="c1">// Crashes here
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>还是C++，&lt;code>Swap()&lt;/code>两个&lt;code>oneof&lt;/code>消息后，每个消息的&lt;code>oneof&lt;/code>字段发生互换。在下面的例子中，&lt;code>msg1&lt;/code>将会有&lt;code>sub_message&lt;/code>成员而&lt;code>msg2&lt;/code>将会有&lt;code>name&lt;/code>成员：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="ln">1&lt;/span>&lt;span class="n">SampleMessage&lt;/span> &lt;span class="n">msg1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="n">msg1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">set_name&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;name&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="n">SampleMessage&lt;/span> &lt;span class="n">msg2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="n">msg2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">mutable_sub_message&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="n">msg1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">swap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">msg2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln">6&lt;/span>&lt;span class="n">CHECK&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">msg1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">has_sub_message&lt;/span>&lt;span class="p">());&lt;/span>
&lt;span class="ln">7&lt;/span>&lt;span class="n">CHECK&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">msg2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">has_name&lt;/span>&lt;span class="p">());&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="ln">1&lt;/span>&lt;span class="n">SampleMessage&lt;/span> &lt;span class="n">msg1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="n">msg1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">set_name&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;name&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="n">SampleMessage&lt;/span> &lt;span class="n">msg2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="n">msg2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">mutable_sub_message&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="n">msg1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">swap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">msg2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln">6&lt;/span>&lt;span class="n">CHECK&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">msg1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">has_sub_message&lt;/span>&lt;span class="p">());&lt;/span>
&lt;span class="ln">7&lt;/span>&lt;span class="n">CHECK&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">msg2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">has_name&lt;/span>&lt;span class="p">());&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h3 id="向后兼容的问题">向后兼容的问题&lt;/h3>
&lt;p>新增或者移除&lt;code>oneof&lt;/code>字段的是要小心 - 在检查&lt;code>oneof&lt;/code>的成员是否被赋值的时候返回&lt;code>None/NOT_SET&lt;/code>，这可能意味着&lt;code>oneof&lt;/code>成员没有被赋值或者某个成员的赋值是基于不同版本的&lt;code>oneof&lt;/code>字段。这其中的区别无从得知，因为无法确定未知字段是否是&lt;code>oneof&lt;/code>的成员。&lt;/p>
&lt;p>&lt;strong>标签复用问题：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>从&lt;code>oneof&lt;/code>中移出成员或者添加成员到&lt;code>oneof&lt;/code>&lt;/strong>：在消息序列化和解析后，你可能会丢失一些信息（比如一些字段被清空）。但是你可以安全的把一个字段移到一个新的&lt;code>oneof&lt;/code>里，或者把多个字段移到也可以，前提是你知道只能有一个字段被赋值&lt;/li>
&lt;li>**删除一个成员或者重新添加回去：**这个可能会知道消息序列化和解析后成员的赋值丢失&lt;/li>
&lt;li>**分离或者合并&lt;code>oneof&lt;/code>成员：**这和移动常规的字段有一样的问题&lt;/li>
&lt;/ul>
&lt;h2 id="maps">Maps&lt;/h2>
&lt;p>如果你希望在你的数据定义中创建&lt;code>map&lt;/code>，protocol buffer提供了一个方便的语法：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="n">map&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">key_type&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">value_type&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="n">map_field&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>key_type&lt;/code>可以是任何整型或者字符串类型（也就是说除了浮点和&lt;code>bytes&lt;/code>之外的标量类型）。因此，如果你希望创建一个键为字符串类型值为&lt;code>Project&lt;/code>消息的&lt;code>map&lt;/code>，你可以定义如下：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="n">map&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">Project&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="n">projects&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>map&lt;/code>类型的字段是不可以定义为&lt;code>repeated&lt;/code>&lt;/li>
&lt;li>Wire格式的顺序不固定，迭代&lt;code>map&lt;/code>也是无序的，因此你不能依赖&lt;code>map&lt;/code>为你提供有序的成员&lt;/li>
&lt;li>为&lt;code>.proto&lt;/code>生成text格式的时候，&lt;code>maps&lt;/code>是按照键排序的。数值类型的键是根据数值排序（&lt;em>这是啥意思，是不是和编码有关系？&lt;/em>）&lt;/li>
&lt;li>如果你只给定了一个键，对应的值没有赋值，这种情况在序列化的时候不同的语言有不同的行为 - C++，Java，Kotlin和Python中会用默认值来序列化，其他语言中这种情况不会被序列化&lt;/li>
&lt;/ul>
&lt;p>访问&lt;code>map&lt;/code>的API目前已对&lt;code>proto3&lt;/code>支持。你可以从 &lt;a href="https://developers.google.com/protocol-buffers/docs/reference/overview">API reference&lt;/a>中查找特定语言相关的说明。&lt;/p>
&lt;h3 id="向后兼容">向后兼容&lt;/h3>
&lt;p>&lt;code>map&lt;/code>的语法和下面的定义等价，因此对那些不支持&lt;code>map&lt;/code>的protocol buffer实现依然可以处理你的数据。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">MapFieldEntry&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">key_type&lt;/span> &lt;span class="n">key&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">value_type&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">4&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">5&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">6&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">repeated&lt;/span> &lt;span class="n">MapFieldEntry&lt;/span> &lt;span class="n">map_field&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>任何支持&lt;code>map&lt;/code>的protocol buffer的实现必须能够基于上面的定义生成和接受数据。&lt;/p>
&lt;h2 id="包">包&lt;/h2>
&lt;p>你可以在&lt;code>.proto&lt;/code>中添加一个可选的&lt;code>package&lt;/code>指示符，这样可以防止不同的消息类型间名字冲突。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="kn">package&lt;/span> &lt;span class="nn">foo&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">bar&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">Open&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="o">...&lt;/span> &lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>你可以在定义你的消息类型的时候使用&lt;code>package&lt;/code>指示符：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">Foo&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="o">...&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">foo.bar.Open&lt;/span> &lt;span class="n">open&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">4&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="o">...&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">5&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>package&lt;/code>指示符是如何起作用的，这个取决于你选择的编程语言：&lt;/p>
&lt;ul>
&lt;li>**C++**中，生成的类被包含在C++命名空间里。例如，&lt;code>Open&lt;/code>会在命名空间&lt;code>foo::bar&lt;/code>里&lt;/li>
&lt;li>&lt;strong>Java&lt;/strong>和&lt;strong>Kotlin&lt;/strong>中，&lt;code>package&lt;/code>和Java的包一样，除非你自己显式的在&lt;code>.proto&lt;/code>里指定了&lt;code>option java_package&lt;/code>&lt;/li>
&lt;li>&lt;strong>Python&lt;/strong>中，&lt;code>package&lt;/code>会被忽略，因为Python modules是按照文件位置来组织的&lt;/li>
&lt;li>&lt;strong>Go&lt;/strong>中，&lt;code>package&lt;/code>和Go的包一样，除非你自己显式的在&lt;code>.proto&lt;/code>里指定了&lt;code>option go_package&lt;/code>&lt;/li>
&lt;li>**C#**中，&lt;code>package&lt;/code>的名称先被转变成PascalCase作为命名空间的名称，除非你自己显式的在&lt;code>.proto&lt;/code>里指定了&lt;code>option csharp_namespace&lt;/code>。例如，&lt;code>Open&lt;/code>会放在命名空间&lt;code>Foo.Bar&lt;/code>下&lt;/li>
&lt;/ul>
&lt;h3 id="包和名字解析">包和名字解析&lt;/h3>
&lt;p>在protocol buffer中类型名称的解析就跟C++中类似：从最内部的范围里查找，然后次之以此类推（任何一个包都被当成父包的内部包）。'.'意味着从最外层开始（比如：&lt;code>.foo.bar.Baz&lt;/code>）&lt;/p>
&lt;p>protocol buffer编译器通过解析导入的&lt;code>.proto&lt;/code>文件来解析所有的类型名称。即使不同语言有不同的范围规则，不同语言的代码生成器知道如何找到特定的类型。&lt;/p>
&lt;h2 id="定义服务">定义服务&lt;/h2>
&lt;p>如果你希望在你的RPC服务中使用你定义的消息，你可以在&lt;code>.proto&lt;/code>文件中定义RPC服务接口，而后protocol buffer会生成特定语言的服务接口代码和mock实现。因此，假如你需要定义个RPC服务的方法接受&lt;code>SearchRequest&lt;/code>参数返回&lt;code>SearchResponse&lt;/code>，你可以按如下方式定义：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="kd">service&lt;/span> &lt;span class="n">SearchService&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="k">rpc&lt;/span> &lt;span class="n">Search&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">SearchRequest&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">returns&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">SearchResponse&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://grpc.io/">gRPC&lt;/a>是最直接使用protocol buffer的RPC系统：Google开发的一个语言和平台中立的开源的RPC系统。gRPC能非常好的和protocol buffer工作，使用一个特殊的protocol buffer插件能完美的生成gRPC代码。&lt;/p>
&lt;p>如果你不使用gRPC，也是可以在你自己的RPC实现中使用protocol buffers，你可以参考：&lt;a href="https://developers.google.com/protocol-buffers/docs/proto#services">Proto2 Language Guide&lt;/a>&lt;/p>
&lt;p>有许多基于protocol buffers的RPC项目正在开发中，这里有一个我们所知道的项目的列表：&lt;a href="https://github.com/protocolbuffers/protobuf/blob/master/docs/third_party.md">third-party add-ons wiki page&lt;/a>&lt;/p>
&lt;h2 id="json-mapping">Json Mapping&lt;/h2>
&lt;p>&lt;code>proto3&lt;/code>支持通用的Json编码，这使得它可以很方便地跨系统共享数据。如下表所示，Json编译是按照&lt;code>type-by-type&lt;/code>的方式进行。&lt;/p>
&lt;p>如果在Json编码的数据中缺少值，或者值是&lt;code>null&lt;/code>，那么在解析成protocol buffre数据的时候将被解释成默认值。如果protocol buffer编码的字段的值是对应类型的默认值，那么编码成Json的时候，为了节省空间这些值会被忽略。一种实现或许可以提供选项给用户使得把默认值也包括在Json编码的数据中。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">proto3&lt;/th>
&lt;th style="text-align:left">JSON&lt;/th>
&lt;th style="text-align:left">JSON example&lt;/th>
&lt;th style="text-align:left">Notes&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">message&lt;/td>
&lt;td style="text-align:left">object&lt;/td>
&lt;td style="text-align:left">&lt;code>{&amp;quot;fooBar&amp;quot;: v, &amp;quot;g&amp;quot;: null, …}&lt;/code>&lt;/td>
&lt;td style="text-align:left">Generates JSON objects. Message field names are mapped to lowerCamelCase and become JSON object keys. If the &lt;code>json_name&lt;/code> field option is specified, the specified value will be used as the key instead. Parsers accept both the lowerCamelCase name (or the one specified by the &lt;code>json_name&lt;/code> option) and the original proto field name. &lt;code>null&lt;/code> is an accepted value for all field types and treated as the default value of the corresponding field type.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">enum&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">&lt;code>&amp;quot;FOO_BAR&amp;quot;&lt;/code>&lt;/td>
&lt;td style="text-align:left">The name of the enum value as specified in proto is used. Parsers accept both enum names and integer values.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">map&amp;lt;K,V&amp;gt;&lt;/td>
&lt;td style="text-align:left">object&lt;/td>
&lt;td style="text-align:left">&lt;code>{&amp;quot;k&amp;quot;: v, …}&lt;/code>&lt;/td>
&lt;td style="text-align:left">All keys are converted to strings.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">repeated V&lt;/td>
&lt;td style="text-align:left">array&lt;/td>
&lt;td style="text-align:left">&lt;code>[v, …]&lt;/code>&lt;/td>
&lt;td style="text-align:left">&lt;code>null&lt;/code> is accepted as the empty list &lt;code>[]&lt;/code>.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">bool&lt;/td>
&lt;td style="text-align:left">true, false&lt;/td>
&lt;td style="text-align:left">&lt;code>true, false&lt;/code>&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">&lt;code>&amp;quot;Hello World!&amp;quot;&lt;/code>&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">bytes&lt;/td>
&lt;td style="text-align:left">base64 string&lt;/td>
&lt;td style="text-align:left">&lt;code>&amp;quot;YWJjMTIzIT8kKiYoKSctPUB+&amp;quot;&lt;/code>&lt;/td>
&lt;td style="text-align:left">JSON value will be the data encoded as a string using standard base64 encoding with paddings. Either standard or URL-safe base64 encoding with/without paddings are accepted.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">int32, fixed32, uint32&lt;/td>
&lt;td style="text-align:left">number&lt;/td>
&lt;td style="text-align:left">&lt;code>1, -10, 0&lt;/code>&lt;/td>
&lt;td style="text-align:left">JSON value will be a decimal number. Either numbers or strings are accepted.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">int64, fixed64, uint64&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">&lt;code>&amp;quot;1&amp;quot;, &amp;quot;-10&amp;quot;&lt;/code>&lt;/td>
&lt;td style="text-align:left">JSON value will be a decimal string. Either numbers or strings are accepted.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">float, double&lt;/td>
&lt;td style="text-align:left">number&lt;/td>
&lt;td style="text-align:left">&lt;code>1.1, -10.0, 0, &amp;quot;NaN&amp;quot;, &amp;quot;Infinity&amp;quot;&lt;/code>&lt;/td>
&lt;td style="text-align:left">JSON value will be a number or one of the special string values &amp;quot;NaN&amp;quot;, &amp;quot;Infinity&amp;quot;, and &amp;quot;-Infinity&amp;quot;. Either numbers or strings are accepted. Exponent notation is also accepted. -0 is considered equivalent to 0.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">Any&lt;/td>
&lt;td style="text-align:left">&lt;code>object&lt;/code>&lt;/td>
&lt;td style="text-align:left">&lt;code>{&amp;quot;@type&amp;quot;: &amp;quot;url&amp;quot;, &amp;quot;f&amp;quot;: v, … }&lt;/code>&lt;/td>
&lt;td style="text-align:left">If the Any contains a value that has a special JSON mapping, it will be converted as follows: &lt;code>{&amp;quot;@type&amp;quot;: xxx, &amp;quot;value&amp;quot;: yyy}&lt;/code>. Otherwise, the value will be converted into a JSON object, and the &lt;code>&amp;quot;@type&amp;quot;&lt;/code> field will be inserted to indicate the actual data type.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">Timestamp&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">&lt;code>&amp;quot;1972-01-01T10:00:20.021Z&amp;quot;&lt;/code>&lt;/td>
&lt;td style="text-align:left">Uses RFC 3339, where generated output will always be Z-normalized and uses 0, 3, 6 or 9 fractional digits. Offsets other than &amp;quot;Z&amp;quot; are also accepted.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">Duration&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">&lt;code>&amp;quot;1.000340012s&amp;quot;, &amp;quot;1s&amp;quot;&lt;/code>&lt;/td>
&lt;td style="text-align:left">Generated output always contains 0, 3, 6, or 9 fractional digits, depending on required precision, followed by the suffix &amp;quot;s&amp;quot;. Accepted are any fractional digits (also none) as long as they fit into nano-seconds precision and the suffix &amp;quot;s&amp;quot; is required.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">Struct&lt;/td>
&lt;td style="text-align:left">&lt;code>object&lt;/code>&lt;/td>
&lt;td style="text-align:left">&lt;code>{ … }&lt;/code>&lt;/td>
&lt;td style="text-align:left">Any JSON object. See &lt;code>struct.proto&lt;/code>.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">Wrapper types&lt;/td>
&lt;td style="text-align:left">various types&lt;/td>
&lt;td style="text-align:left">&lt;code>2, &amp;quot;2&amp;quot;, &amp;quot;foo&amp;quot;, true, &amp;quot;true&amp;quot;, null, 0, …&lt;/code>&lt;/td>
&lt;td style="text-align:left">Wrappers use the same representation in JSON as the wrapped primitive type, except that &lt;code>null&lt;/code> is allowed and preserved during data conversion and transfer.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">FieldMask&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">&lt;code>&amp;quot;f.fooBar,h&amp;quot;&lt;/code>&lt;/td>
&lt;td style="text-align:left">See &lt;code>field_mask.proto&lt;/code>.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">ListValue&lt;/td>
&lt;td style="text-align:left">array&lt;/td>
&lt;td style="text-align:left">&lt;code>[foo, bar, …]&lt;/code>&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">Value&lt;/td>
&lt;td style="text-align:left">value&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;td style="text-align:left">Any JSON value. Check &lt;a href="https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.Value">google.protobuf.Value&lt;/a> for details.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">NullValue&lt;/td>
&lt;td style="text-align:left">null&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;td style="text-align:left">JSON null&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">Empty&lt;/td>
&lt;td style="text-align:left">object&lt;/td>
&lt;td style="text-align:left">&lt;code>{}&lt;/code>&lt;/td>
&lt;td style="text-align:left">An empty JSON object&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="json-选项">JSON 选项&lt;/h3>
&lt;p>&lt;code>proto3&lt;/code>的JSON实现可能提供以下选项（&lt;em>这下面说的选项原文也没有说明是什么以及怎么使用&lt;/em>）：&lt;/p>
&lt;ul>
&lt;li>**包含默认值在JSON编码中：**默认情况下，具有默认值的字段在编码成JSON的时候其值被忽略。一种实现或许可以提供一个选项来覆盖这种默认行为使得把默认值包含进去&lt;/li>
&lt;li>**忽略未知字段：**Proto3 JSON解析器默认会拒绝未知的字段，但是可能可以提供一个选项在解析的时候忽略未知字段&lt;/li>
&lt;li>**使用字段名称来代替lowerCamelCase格式的：**默认情况，proto3 JSON printer会把字段名称转换为lowerCamelCase格式作为Json名称。一种实现可能可以提供一个选项来直接使用字段名称作为Json名称。proto3 JSON解析器应该都要接受字段名称和lowerCamelCase格式的名称&lt;/li>
&lt;li>**把枚举解释成值而不是枚举项：**默认情况下，枚举项被解释成Json。一种实现可能可以提供一个选项来直接使用枚举值还是枚举项（枚举项就是枚举名称，枚举值就是枚举项对应的数值）&lt;/li>
&lt;/ul>
&lt;h2 id="选项option">选项option&lt;/h2>
&lt;p>&lt;code>.proto&lt;/code>文件中的声明可以用一些列的&lt;code>option&lt;/code>来标记。&lt;code>option&lt;/code>不会改变这些声明的整体的含义，但是可能会按照某种方式影响这些声明被处理的方式。完整可用的&lt;code>option&lt;/code>是定义在&lt;code>google/protobuf/descriptor.proto&lt;/code>中。&lt;/p>
&lt;p>有些&lt;code>option&lt;/code>是文件级别的，意味着他们应该放在作用范围的顶层而不是放在任何一个消息、枚举或者服务的定义里。有些&lt;code>option&lt;/code>是消息级别的，意味着这些应该放在消息里面。有些则是字段级别的，应该放在字段的定义里。除此之外，还可以放在&lt;code>enum&lt;/code>类型、&lt;code>enum&lt;/code>值、&lt;code>oneof&lt;/code>字段、服务类型和服务方法里，只是目前还有有用的&lt;code>option&lt;/code>作用这以上这些（那原文说这个干啥？！）。&lt;/p>
&lt;p>&lt;em>（原文中列举了一些最重要的&lt;code>option&lt;/code>适用于Java，C++等我不使用的语言我就没有放进来，偷个懒省点翻译的时间）&lt;/em>&lt;/p>
&lt;h3 id="自定义option">自定义Option&lt;/h3>
&lt;p>Protocol Buffers允许你自定义选项然后使用。这是一个大多数人都不需要用到的&lt;strong>高级选项&lt;/strong>。如果你确实觉得你需要这些自定义选项，你可以参考&lt;a href="https://developers.google.com/protocol-buffers/docs/proto#customoptions">Proto2 Language Guide&lt;/a>。注意，创建自定义选项需要扩展&lt;a href="https://developers.google.com/protocol-buffers/docs/proto#extensions">extensions&lt;/a>的支持，这些扩展只能用于在&lt;code>proto3&lt;/code>中自定义选项。&lt;/p>
&lt;h2 id="生成你的类">生成你的类&lt;/h2>
&lt;p>你需要运行Protocol buffer编译器&lt;code>.protoc&lt;/code>来编译你的&lt;code>.proto&lt;/code>文件来生成和消息交互的Java/Kotlin/Python/C++/Go/Ruby/Objective-C/C# 代码。如果你还没哟uanzhuang编译器，&lt;a href="https://developers.google.com/protocol-buffers/docs/downloads">请先下载&lt;/a>然后参考README的说明来安装。对Go语言，你需要安装一个特定的代码生成器插件：你可以从&lt;a href="https://github.com/golang/protobuf/">golang/protobuf&lt;/a> 找到这个插件以及这个插件的安装说明。&lt;/p>
&lt;p>Protocol编译器是按照以下的方式来调用：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="n">protoc&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="n">proto_path&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">IMPORT_PATH&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="n">cpp_out&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">DST_DIR&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="n">java_out&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">DST_DIR&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="n">python_out&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">DST_DIR&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="n">go_out&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">DST_DIR&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="n">ruby_out&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">DST_DIR&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="n">objc_out&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">DST_DIR&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="n">csharp_out&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">DST_DIR&lt;/span> &lt;span class="n">path&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="k">to&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">file.proto&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>&lt;code>IMPORT_PATH&lt;/code>指定了从什么位置导入&lt;code>.proto&lt;/code>文件。如果没有指定，默认从当前位置导入。如果有多个导入位置，可以多次指定&lt;code>--proto_path&lt;/code>并设置路径，这些路径将被按顺序查找和导入。&lt;code>-I=_IMPORT_PATH_&lt;/code>是&lt;code>--proto_path&lt;/code>的简短形式。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>你可以提供以下一个或者多个导出目录（这里我只列举了生成Go语言的目录，其他语言请参考原文）&lt;/p>
&lt;ul>
&lt;li>&lt;code>--go_out&lt;/code>指定生成Go代码于&lt;code>DST_DIR&lt;/code>目录。更多细节请参考&lt;a href="https://developers.google.com/protocol-buffers/docs/reference/go-generated">Go generated code reference&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>你必须指定一个或者多个&lt;code>.proto&lt;/code>文件作为输入。可以同时指定多个&lt;code>.proto&lt;/code>文件，前提是这些文件都位于&lt;code>IMPORT_PATH&lt;/code>，这样编译器才能根据名字找到这些文件。&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>[译]Protocol Buffer Basics Go</title><link>https://www.jonathanlin.top/posts/protocol-buffer-basics-go/</link><pubDate>Thu, 01 Jul 2021 13:54:58 +0800</pubDate><guid>https://www.jonathanlin.top/posts/protocol-buffer-basics-go/</guid><description>
&lt;p>原文链接：&lt;a href="https://developers.google.com/protocol-buffers/docs/gotutorial">Protocol Buffer Basics: Go | Protocol Buffers | Google Developers&lt;/a>&lt;/p>
&lt;p>本教程使用proto3语言为Go程序员介绍了protocol buffers的基本使用。通过一步步创建一个简单的示例应用，你将会了解到：&lt;/p>
&lt;ul>
&lt;li>在&lt;code>.proto&lt;/code>文件中定义消息格式&lt;/li>
&lt;li>使用protocol buffer编译器&lt;/li>
&lt;li>使用Go protocol buffer API读写消息&lt;/li>
&lt;/ul>
&lt;p>这不是一个使用protocol buffers的完全手册。更多更细节的信息，请参看：&lt;a href="https://developers.google.com/protocol-buffers/docs/proto3">Language Guide (proto3)&lt;/a>、&lt;a href="https://pkg.go.dev/google.golang.org/protobuf/proto">Go API Reference&lt;/a>、&lt;a href="https://developers.google.com/protocol-buffers/docs/reference/go-generated">Go Generated Code&lt;/a>和&lt;a href="https://developers.google.com/protocol-buffers/docs/encoding">Encoding Reference&lt;/a>&lt;/p>
&lt;h2 id="为什么使用protocol-buffers">为什么使用protocol buffers？&lt;/h2>
&lt;p>我们将要创建一个简单的“地址簿”应用，该应用可以从文件中读和写联系人的信息。地址簿中的每一个联系人有名字，ID和联系电话。&lt;/p>
&lt;p>你如何序列化和读取这种结构化数据？有这么几种方式可以解决这个问题：&lt;/p>
&lt;ul>
&lt;li>使用&lt;a href="https://golang.org/pkg/encoding/gob/">gobs&lt;/a>序列化Go数据结构。对于Go语言本身而言，这是一个很好的方案，但是如果你需要跨语言平台共享数据，那这种方式并不好&lt;/li>
&lt;li>按照你期望的方式把数据编码成单一的字符串，例如4个int类型的数据编码成“12:3:-23:67”。这是一个简单且灵活的办法，但这要求你编写一次性的编码和转换的代码，同时转化代码会带来一定的运行时消耗。对于比较简单的数据，使用这种方式就比较好&lt;/li>
&lt;li>将数据序列化成XML。XML对人类可读友好且各种语言都有对应的解析工具使得该方法有点吸引人。XML也能比较好的跨应用/项目共享数据。然而，众所周知，XML占用空间比较大，并且解析XML往往比较耗性能。此外，定位XML DOM树通常比直接访问类字段要复杂的多&lt;/li>
&lt;/ul>
&lt;p>Protocol buffers具有灵活、高效、自动化等特点可以解决上述问题。使用Protocol buffer，你需要把数据结构的描述定义在&lt;code>.proto&lt;/code>文件中，然后protocol buffer编译器会为你生成一个类，这个类实现了对protocol buffer二进制数据的编码和解析。这个类提供了对各个字段的getter和setter方法用于读写。protocol buffer很重要的一点是，如果将来数据格式扩展了，那么代码中依然可以读取由旧的格式编码的数据。&lt;/p>
&lt;h2 id="哪里找示例代码">哪里找示例代码&lt;/h2>
&lt;p>我们的例子是一系列的命令行程序，这些程序管理了由protocol buffers编码的地址簿数据文件。&lt;code>add_person_go&lt;/code>这个命令添加一条记录到数据文件。&lt;code>list_people_go&lt;/code>解析数据文件并把结果输出到控制台。&lt;/p>
&lt;p>你可以从Github Repo中找到完整的示例：&lt;a href="https://github.com/protocolbuffers/protobuf/tree/master/examples">protobuf/examples at master · protocolbuffers/protobuf (github.com)&lt;/a>&lt;/p>
&lt;h2 id="定义你的protocol格式">定义你的protocol格式&lt;/h2>
&lt;p>创建你的地址簿应用的第一步是定义你的&lt;code>.proto&lt;/code>文件。&lt;code>.proto&lt;/code>文件中的定义很简单：你为你想要序列化的每一个数据结构添加一个消息，然后为消息中的每个字段指定一个名称和对应的类型。在我们的例子中，在&lt;code>.proto&lt;/code>中定义的消息请参考&lt;a href="https://github.com/protocolbuffers/protobuf/blob/master/examples/addressbook.proto">addressbook.proto&lt;/a>。&lt;/p>
&lt;p>&lt;code>.proto&lt;/code>文件是从一个包声明开始的，包声明用来防止在不同项目中的名字冲突。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="n">syntax&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;proto3&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="kn">package&lt;/span> &lt;span class="nn">tutorial&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">4&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">import&lt;/span> &lt;span class="s">&amp;#34;google/protobuf/timestamp.proto&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>go_package&lt;/code>定义了代码生成所在的路径，包名即路径中的最后一个目录。例如，我们的例子的包名就是”tutorialpb“。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="k">option&lt;/span> &lt;span class="n">go_package&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;github.com/protocolbuffers/protobuf/examples/go/tutorialpb&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来，你就可以定义你的消息了。一个小时是包含一组含有类型的字段的集合。许多标准的简单值类型都是支持的，例如&lt;code>bool&lt;/code> 、&lt;code>int32&lt;/code>、 &lt;code>float&lt;/code>、 &lt;code>double&lt;/code> 和&lt;code>string&lt;/code>。你也可以包含其他消息在你要定义的消息里。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">Person&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="n">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">int32&lt;/span> &lt;span class="n">id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// Unique ID number for this person.
&lt;/span>&lt;span class="ln"> 4&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="n">email&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 5&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 6&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kd">enum&lt;/span> &lt;span class="n">PhoneType&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 7&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">MOBILE&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 8&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">HOME&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 9&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">WORK&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">10&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">11&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">12&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kd">message&lt;/span> &lt;span class="nc">PhoneNumber&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">13&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="n">number&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">14&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">PhoneType&lt;/span> &lt;span class="n">type&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">15&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">16&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">17&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="k">repeated&lt;/span> &lt;span class="n">PhoneNumber&lt;/span> &lt;span class="n">phones&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">18&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">19&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">google.protobuf.Timestamp&lt;/span> &lt;span class="n">last_updated&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">20&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">21&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">22&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c1">// Our address book file is just one of these.
&lt;/span>&lt;span class="ln">23&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">AddressBook&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">24&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="k">repeated&lt;/span> &lt;span class="n">Person&lt;/span> &lt;span class="n">people&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">25&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的例子中，&lt;code>Person&lt;/code>这个消息里包含了&lt;code>PhoneNumber&lt;/code>这个消息，&lt;code>AddressBook&lt;/code>这个消息包含了&lt;code>Person&lt;/code>这个消息。你甚至可以消息里定义另一个消息 - 正如你看到的，&lt;code>PhoneNumber&lt;/code>是定义在&lt;code>Person&lt;/code>里的。如果你希望你的取值是预先定义的一组值里的一个，那么你可以定义&lt;code>enum&lt;/code>类型 - 上面的例子中，你希望电话号码的类型是&lt;code>MOBILE&lt;/code>、 &lt;code>HOME&lt;/code>或者 &lt;code>WORK&lt;/code>。&lt;/p>
&lt;p>在每一个字段上诸如&amp;quot;= 1&amp;quot; &amp;quot;= 2&amp;quot;的标记是用于在二进制编码的时候对字段指定一个唯一的标记。相对于更高的标记号码而言，1 -15号在编码的时候占用的空间小于一个字节，因此一个有优化手段是你可以把经常会用到的字段或者重复类型的字段（例如数组）标记为1 - 15，把高于15的留给那些不怎么常用到的字段或者可选的字段。重复类型字段里的每一个元素都需要重新编码标记号码，因此重复类型的字段往往都会用到这种优化 。（&lt;em>&lt;strong>这块后面需要再理解一下是什么意思&lt;/strong>&lt;/em>）&lt;/p>
&lt;p>如果一个字段的值没有设置，那么将使用对应类型的&lt;a href="https://developers.google.com/protocol-buffers/docs/proto3#default">默认值&lt;/a>：数字类型的默认值是0，字符串默认值是空字符串，布尔类型的默认值是false。对于嵌套的消息，它的默认值是带有各个字段名的默认值。调用访问器（getter）去读取值的时候，如果对应的字段没有明确赋值，那么就返回对应的默认值。&lt;/p>
&lt;p>如果一个字段是重复类型，那么元素的个数可能是任意数目（包括0个）。元素的顺序在protocol buffer中是被保留下来的。可以想象重复类型字段是动态数组。&lt;/p>
&lt;p>你将在&lt;a href="https://developers.google.com/protocol-buffers/docs/proto3">Protocol Buffer Language Guide&lt;/a>中找到如何编写&lt;code>.proto&lt;/code>文件的完整教程（包括所有的类型）。至于类似于类继承这种机制就不要找了，protocol buffer不支持。&lt;/p>
&lt;h2 id="编译protocol-buffers">编译protocol buffers&lt;/h2>
&lt;p>现在你已经有&lt;code>.proto&lt;/code>文件了，接下来你需要基于这个文件去生成访问&lt;code>AddresBook&lt;/code>消息（&lt;code>Person&lt;/code>和&lt;code>PhoneNumber&lt;/code>也是）的类了。你将要使用protocol buffer编译器&lt;code>protoc&lt;/code>来编译你的&lt;code>.proto&lt;/code>文件：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>如果你还未安装编译器，请先&lt;a href="https://developers.google.com/protocol-buffers/docs/downloads">Download Protocol Buffers&lt;/a>，然后参考README进行安装&lt;/p>
&lt;/li>
&lt;li>
&lt;p>运行下面的命令安装Go protocol buffers plugin：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="ln">1&lt;/span>go get github.com/golang/protobuf/protoc-gen-go
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;p>编译器plugin &lt;code>protoc-gen-to&lt;/code>将被安装在&lt;code>$GOBIN&lt;/code>目录，该目录默认是在&lt;code>$GOPATH/bin&lt;/code>。这个目录必须包含在你的&lt;code>$PATH&lt;/code>中。&lt;/p>
&lt;ol start="3">
&lt;li>
&lt;p>现在你可以运行编译器，指定源目录（就是你的源文件所在的目录，如果没有指定就是指当前目录）和目标目录（生成的代码所在的目录）以及&lt;code>.proto&lt;/code>所在的目录。在我们的例子中，你应该运行下面命令：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="ln">1&lt;/span>protoc -I&lt;span class="o">=&lt;/span>&lt;span class="nv">$SRC_DIR&lt;/span> --go_out&lt;span class="o">=&lt;/span>&lt;span class="nv">$DST_DIR&lt;/span> &lt;span class="nv">$SRC_DIR&lt;/span>/addressbook.proto
&lt;/code>&lt;/pre>&lt;/div>&lt;p>由于你是需要生成Go代码，你应该使用&lt;code>--go-out&lt;/code>选项，其他语言则使用对应的选项。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>运行后，你将会在特定的目录看到生成的代码：&lt;code>github.com/protocolbuffers/protobuf/examples/go/tutorialpb/addressbook.pb.go&lt;/code>。&lt;/p>
&lt;h2 id="protocol-buffer-api">Protocol Buffer API&lt;/h2>
&lt;p>生成的&lt;code>addressbook.pb.go&lt;/code>提供了以下有用的类型：&lt;/p>
&lt;ul>
&lt;li>&lt;code>AddressBook&lt;/code>结构体包含了&lt;code>People&lt;/code>类型的字段&lt;/li>
&lt;li>&lt;code>Person&lt;/code>结构体包含了&lt;code>Name&lt;/code>、&lt;code>Id&lt;/code>、&lt;code>Email&lt;/code>和 &lt;code>Phones&lt;/code>字段&lt;/li>
&lt;li>&lt;code>Person_PhoneNumber&lt;/code>结构体包含了&lt;code>Number&lt;/code>和&lt;code>Type&lt;/code>字段&lt;/li>
&lt;li>&lt;code>Person_PhoneType&lt;/code>结构体和&lt;code>Person.PhoneType&lt;/code>枚举&lt;/li>
&lt;/ul>
&lt;p>你可以从&lt;a href="https://developers.google.com/protocol-buffers/docs/reference/go-generated">Go Generated Code guide&lt;/a>了解到代码生成的细节，对于大部分代码你只需要像对待Go类型一样。&lt;/p>
&lt;p>&lt;code>list_people&lt;/code>的单元测试&lt;a href="https://github.com/protocolbuffers/protobuf/blob/master/examples/list_people_test.go">command's unit tests&lt;/a>中展示了你应该如何创建&lt;code>Person&lt;/code>的实例：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln">1&lt;/span>&lt;span class="nx">p&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">pb&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Person&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="nx">Id&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">1234&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="ln">3&lt;/span> &lt;span class="nx">Name&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s">&amp;#34;John Doe&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="ln">4&lt;/span> &lt;span class="nx">Email&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s">&amp;#34;jdoe@example.com&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="ln">5&lt;/span> &lt;span class="nx">Phones&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">pb&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Person_PhoneNumber&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="ln">6&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="nx">Number&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s">&amp;#34;555-4321&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">Type&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">pb&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Person_HOME&lt;/span>&lt;span class="p">},&lt;/span>
&lt;span class="ln">7&lt;/span> &lt;span class="p">},&lt;/span>
&lt;span class="ln">8&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="写消息">写消息&lt;/h2>
&lt;p>使用proptocol buffers的目的是序列化你的数据，而后能够在任何地方解析。Go语言中，你可以使用&lt;code>proto&lt;/code>库的&lt;a href="https://pkg.go.dev/google.golang.org/protobuf/proto?tab=doc#Marshal">Marshal&lt;/a>方法序列化你的protocol buffer数据。protocol buffer消息的指针类型实现了&lt;code>proto.Message&lt;/code>接口。调用&lt;code>proto.Marshal&lt;/code>返回序列化后的编码成wire格式的protocol buffer数据。例如，我们在&lt;a href="https://github.com/protocolbuffers/protobuf/blob/master/examples/add_person.go">&lt;code>add_person&lt;/code> command&lt;/a>中使用了这个方法：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln"> 1&lt;/span>&lt;span class="nx">book&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">pb&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">AddressBook&lt;/span>&lt;span class="p">{}&lt;/span>
&lt;span class="ln"> 2&lt;/span>&lt;span class="c1">// ...
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="c1">// Write the new address book back to disk.
&lt;/span>&lt;span class="ln"> 5&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="nx">out&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">proto&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Marshal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">book&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 6&lt;/span>&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="nx">log&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Fatalln&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Failed to encode address book:&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 8&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="ln"> 9&lt;/span>&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">ioutil&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">WriteFile&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">fname&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">out&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mo">0644&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="nx">log&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Fatalln&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Failed to write address book:&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">11&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="读数据">读数据&lt;/h2>
&lt;p>你可以使用&lt;code>proto&lt;/code>库中的&lt;a href="https://pkg.go.dev/google.golang.org/protobuf/proto?tab=doc#Unmarshal">Unmarshal&lt;/a>方法来解析编码过的数据。调用这个方法将&lt;code>buf&lt;/code>中的protocol buffer数据解析出来存放在&lt;code>pb&lt;/code>中。因此我们使用下面的代码在&lt;a href="https://github.com/protocolbuffers/protobuf/blob/master/examples/list_people.go">&lt;code>list_people&lt;/code> command&lt;/a>中进行解析：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln">1&lt;/span>&lt;span class="c1">// Read the existing address book.
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="nx">in&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">ioutil&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ReadFile&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">fname&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">4&lt;/span> &lt;span class="nx">log&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Fatalln&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Error reading file:&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="ln">6&lt;/span>&lt;span class="nx">book&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">pb&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">AddressBook&lt;/span>&lt;span class="p">{}&lt;/span>
&lt;span class="ln">7&lt;/span>&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">proto&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Unmarshal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">in&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">book&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">8&lt;/span> &lt;span class="nx">log&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Fatalln&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Failed to parse address book:&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">9&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="扩展protocol-buffer">扩展Protocol Buffer&lt;/h2>
&lt;p>在你使用protocol buffer的代码发布之后，或早或晚你总是希望改进你的protocol buffer定义。如果你希望你新的定义能向后兼容，且你的老的定义能向前兼容（你一定总是希望这样），那么你需要遵循一些规则。在新版本的protocol buffer中：&lt;/p>
&lt;ul>
&lt;li>你一定不能修改现在的字段的标签号码&lt;/li>
&lt;li>你可能会删除某些字段&lt;/li>
&lt;li>你可能会新增字段，但是新增的字段一定要使用全新的标签号码（一定是没有被使用过的，包括那些被删除的字段曾经使用过的）。&lt;/li>
&lt;/ul>
&lt;p>（使用这些规则有一些例外&lt;a href="https://developers.google.com/protocol-buffers/docs/proto3#updating">some exceptions&lt;/a>，但这些很少使用到）&lt;/p>
&lt;p>如果你遵循了这些规则，你会发现老代码也可以读取新的消息，只是会忽略新的字段。对于老代码，被删除的非数组字段会有它们的默认值，数组类型为空。新的代码可以透明的读取老的消息。&lt;/p>
&lt;p>需要注意的是，新的字段不会出现在老消息里，因此你需要添加合理的逻辑处理默认值&lt;a href="https://developers.google.com/protocol-buffers/docs/proto3#default">default value&lt;/a>。&lt;/p></description></item></channel></rss>