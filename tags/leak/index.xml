<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>leak on Standing on the Shoulder of Giants</title><link>https://www.jonathanlin.top/tags/leak/</link><description>Recent content in leak on Standing on the Shoulder of Giants</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © {year} Jonathan Lin. All rights reserved.</copyright><lastBuildDate>Wed, 07 Jul 2021 23:24:02 +0800</lastBuildDate><atom:link href="https://www.jonathanlin.top/tags/leak/index.xml" rel="self" type="application/rss+xml"/><item><title>[译]Goroutine Leaks - The Forgotten Sender</title><link>https://www.jonathanlin.top/posts/gorouting-leak-the-forgotten-sender/</link><pubDate>Wed, 07 Jul 2021 23:24:02 +0800</pubDate><guid>https://www.jonathanlin.top/posts/gorouting-leak-the-forgotten-sender/</guid><description>
&lt;p>原文链接：&lt;a href="https://www.ardanlabs.com/blog/2018/11/goroutine-leaks-the-forgotten-sender.html">Goroutine Leaks - The Forgotten Sender (ardanlabs.com)&lt;/a>&lt;/p>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>并发编程可以让程序员以多个执行路径来解决问题，而且通常是试图提高程序性能。并发并不意味着这些执行路径是以并行的方式执行，而是说这些执行路径以无序异步的方式执行而不是同步顺序执行。历史上这种编程模型是通过标准款或者第三方库来实现的。&lt;/p>
&lt;p>Go语言中，并发特性是通过语言内置的Goroutine和channel来实现，这样就减少了对库的依赖。这容易给人一种错觉，觉得使用Go来编写并发程序会很简单。你得非常小心，因为如果你没有正确的使用Go的并发特性，往往会引入特定的边界效应或者调入陷阱。一不小心，这些陷阱就会给你程序带来很多复杂度以及很恶心的bug。&lt;/p>
&lt;p>本文中，我将讨论的可能出现的陷阱是Goroutine泄漏。&lt;/p>
&lt;h2 id="goroutine泄漏">Goroutine泄漏&lt;/h2>
&lt;p>关于内存管理，Go语言为了处理了许许多多的内存管理细节。Go编译器根据逃逸分析来决定值应该存放在内存中的什么地方（原文站点引用了一篇逃逸分析的博文&lt;a href="https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-escape-analysis.html">Language Mechanics On Escape Analysis (ardanlabs.com)&lt;/a>，回头我也会翻译出来）。运行时通过垃圾回收器管理跟踪和管理堆上分配的内存，正因为此，虽然不能完全肯定你的程序不会发生内存泄漏，但这种概率已经被极大降低了。&lt;/p>
&lt;p>一种常见的内存泄漏是由于Goroutine泄漏引起的。如果你启动了一个Goroutine并且你期望它最终会退出，但由于某种原因最终这个Goroutine没有退出，这时候就发生了泄漏。这种情况下，这个Goroutine就存在于你的应用的整个生命周期，分配给这Goroutine的内存也无法释放。这就是Dave Cheney所建议的“&lt;a href="https://dave.cheney.net/2016/12/22/never-start-a-goroutine-without-knowing-how-it-will-stop">Never start a goroutine without knowing how it will stop&lt;/a>”背后的逻辑。&lt;/p>
&lt;p>下面的代码演示了一种非常常见的Goroutine泄漏。&lt;/p>
&lt;p>&lt;strong>Listing 1&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://play.golang.org/p/dsu3PARM24K">https://play.golang.org/p/dsu3PARM24K&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln"> 1&lt;/span>&lt;span class="mi">31&lt;/span> &lt;span class="c1">// leak is a buggy function. It launches a goroutine that
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">32&lt;/span> &lt;span class="c1">// blocks receiving from a channel. Nothing will ever be
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">33&lt;/span> &lt;span class="c1">// sent on that channel and the channel is never closed so
&lt;/span>&lt;span class="ln"> 4&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">34&lt;/span> &lt;span class="c1">// that goroutine will be blocked forever.
&lt;/span>&lt;span class="ln"> 5&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">35&lt;/span> &lt;span class="kd">func&lt;/span> &lt;span class="nf">leak&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 6&lt;/span>&lt;span class="mi">36&lt;/span> &lt;span class="nx">ch&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 7&lt;/span>&lt;span class="mi">37&lt;/span>
&lt;span class="ln"> 8&lt;/span>&lt;span class="mi">38&lt;/span> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 9&lt;/span>&lt;span class="mi">39&lt;/span> &lt;span class="nx">val&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">ch&lt;/span>
&lt;span class="ln">10&lt;/span>&lt;span class="mi">40&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;We received a value:&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">val&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">11&lt;/span>&lt;span class="mi">41&lt;/span> &lt;span class="p">}()&lt;/span>
&lt;span class="ln">12&lt;/span>&lt;span class="mi">42&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Listing 1定义了一个叫&lt;code>leak&lt;/code>的函数。这个函数在第36行创建了一个channel，通过这个channel把数据传递给后面启动的Goroutine。第38行启动了一个Goroutine，然后这个Goroutine在第39行被阻塞以等待接收channel上的来的数据。当这个Goroutine等待的时候，启动它的函数&lt;code>leak&lt;/code>就执行完返回了，&lt;strong>这时候程序中的没有其他任何地方可以给这个channel发送数据&lt;/strong>，这就导致Goroutine被永久的阻塞在了第39行。第40行的&lt;code>fmt.Println&lt;/code>就永远不会执行。&lt;/p>
&lt;p>在这个例子中，这种Goroutine泄漏可以在一次代码审核中很快被识别出来。不幸的是，生成环境Goroutine泄漏往往很难被发现。我没办法穷举Goroutine泄漏的情景，但是本博文会消息讨论你可能会遇到的一种Goroutine泄漏。&lt;/p>
&lt;h2 id="泄漏被遗忘的发送者">泄漏：被遗忘的发送者&lt;/h2>
&lt;p>(&lt;em>注：个人理解，原作者想表达的”被遗忘的发送者“是指 - gorouting阻塞在了往（非缓冲）channel发送数据，因为由于种种原因程序中其他地方没有从channel中接收&lt;/em>)&lt;/p>
&lt;p>&lt;em>&lt;strong>在这个泄漏的例子中，你将看到一个Goroutine被永久阻塞，等待发送数据给channel&lt;/strong>&lt;/em>&lt;/p>
&lt;p>我们将看到的这个程序 - 基于关键字查找记录然后打印。该程序围绕一个&lt;code>search&lt;/code>函数构建：&lt;/p>
&lt;p>&lt;strong>Listing 2&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://play.golang.org/p/o6_eMjxMVFv">https://play.golang.org/p/o6_eMjxMVFv&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln">1&lt;/span>&lt;span class="mi">29&lt;/span> &lt;span class="c1">// search simulates a function that finds a record based
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">30&lt;/span> &lt;span class="c1">// on a search term. It takes 200ms to perform this work.
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">31&lt;/span> &lt;span class="kd">func&lt;/span> &lt;span class="nf">search&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">term&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="mi">32&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">200&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Millisecond&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="mi">33&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="s">&amp;#34;some value&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="ln">6&lt;/span>&lt;span class="mi">34&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Listing 2中的&lt;code>search&lt;/code>函数的第31行，模拟了一个长时间运行的耗时操作，比如数据库查询或者Web调用。在这里，假设这个耗时操作为200ms。调用&lt;code>search&lt;/code>函数的代码在Listing 3中，如下所示：&lt;/p>
&lt;p>&lt;strong>Listing 3&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln"> 1&lt;/span>&lt;span class="mi">17&lt;/span> &lt;span class="c1">// process is the work for the program. It finds a record
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">18&lt;/span> &lt;span class="c1">// then prints it.
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">19&lt;/span> &lt;span class="kd">func&lt;/span> &lt;span class="nf">process&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">term&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="mi">20&lt;/span> &lt;span class="nx">record&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">search&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">term&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 5&lt;/span>&lt;span class="mi">21&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 6&lt;/span>&lt;span class="mi">22&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;span class="ln"> 7&lt;/span>&lt;span class="mi">23&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln"> 8&lt;/span>&lt;span class="mi">24&lt;/span>
&lt;span class="ln"> 9&lt;/span>&lt;span class="mi">25&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Received:&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">record&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">10&lt;/span>&lt;span class="mi">26&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="ln">11&lt;/span>&lt;span class="mi">27&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Listing 3中第19行，定义了一个&lt;code>process&lt;/code>函数，它接受一个字符串类型的参数&lt;code>term&lt;/code>，这个参数就表示搜索关键字。第20行，&lt;code>term&lt;/code>传递给&lt;code>search&lt;/code>函数该函数返回一条记录和错误。如果有错误发生，在第22行返回错误，否则在第25行打印这条记录。&lt;/p>
&lt;p>对于一些应用而言，串行的调用&lt;code>search&lt;/code>带来的时延或许无法接受。假设&lt;code>search&lt;/code>无法更快的运行了，&lt;code>processs&lt;/code>函数可以修改成不必完全消耗在等待&lt;code>search&lt;/code>返回结果。为了达到这个目的，如下面Listing 4所示，可以使用一个Goroutine来解决这个问题。不幸的是，这个尝试是有问题的，它带来了潜在的Goroutine泄漏。&lt;/p>
&lt;p>&lt;strong>Listing 4&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://play.golang.org/p/m0DHuchgX0A">https://play.golang.org/p/m0DHuchgX0A&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln"> 1&lt;/span>&lt;span class="mi">38&lt;/span> &lt;span class="c1">// result wraps the return values from search. It allows us
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">39&lt;/span> &lt;span class="c1">// to pass both values across a single channel.
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">40&lt;/span> &lt;span class="kd">type&lt;/span> &lt;span class="nx">result&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="mi">41&lt;/span> &lt;span class="nx">record&lt;/span> &lt;span class="kt">string&lt;/span>
&lt;span class="ln"> 5&lt;/span>&lt;span class="mi">42&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="kt">error&lt;/span>
&lt;span class="ln"> 6&lt;/span>&lt;span class="mi">43&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln"> 7&lt;/span>&lt;span class="mi">44&lt;/span>
&lt;span class="ln"> 8&lt;/span>&lt;span class="mi">45&lt;/span> &lt;span class="c1">// process is the work for the program. It finds a record
&lt;/span>&lt;span class="ln"> 9&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">46&lt;/span> &lt;span class="c1">// then prints it. It fails if it takes more than 100ms.
&lt;/span>&lt;span class="ln">10&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">47&lt;/span> &lt;span class="kd">func&lt;/span> &lt;span class="nf">process&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">term&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">11&lt;/span>&lt;span class="mi">48&lt;/span>
&lt;span class="ln">12&lt;/span>&lt;span class="mi">49&lt;/span> &lt;span class="c1">// Create a context that will be canceled in 100ms.
&lt;/span>&lt;span class="ln">13&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">50&lt;/span> &lt;span class="nx">ctx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">cancel&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">context&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">WithTimeout&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">context&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Background&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="mi">100&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Millisecond&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">14&lt;/span>&lt;span class="mi">51&lt;/span> &lt;span class="k">defer&lt;/span> &lt;span class="nf">cancel&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="ln">15&lt;/span>&lt;span class="mi">52&lt;/span>
&lt;span class="ln">16&lt;/span>&lt;span class="mi">53&lt;/span> &lt;span class="c1">// Make a channel for the goroutine to report its result.
&lt;/span>&lt;span class="ln">17&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">54&lt;/span> &lt;span class="nx">ch&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="nx">result&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">18&lt;/span>&lt;span class="mi">55&lt;/span>
&lt;span class="ln">19&lt;/span>&lt;span class="mi">56&lt;/span> &lt;span class="c1">// Launch a goroutine to find the record. Create a result
&lt;/span>&lt;span class="ln">20&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">57&lt;/span> &lt;span class="c1">// from the returned values to send through the channel.
&lt;/span>&lt;span class="ln">21&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">58&lt;/span> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">22&lt;/span>&lt;span class="mi">59&lt;/span> &lt;span class="nx">record&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">search&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">term&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">23&lt;/span>&lt;span class="mi">60&lt;/span> &lt;span class="nx">ch&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="nx">result&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="nx">record&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="ln">24&lt;/span>&lt;span class="mi">61&lt;/span> &lt;span class="p">}()&lt;/span>
&lt;span class="ln">25&lt;/span>&lt;span class="mi">62&lt;/span>
&lt;span class="ln">26&lt;/span>&lt;span class="mi">63&lt;/span> &lt;span class="c1">// Block waiting to either receive from the goroutine&amp;#39;s
&lt;/span>&lt;span class="ln">27&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">64&lt;/span> &lt;span class="c1">// channel or for the context to be canceled.
&lt;/span>&lt;span class="ln">28&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">65&lt;/span> &lt;span class="k">select&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">29&lt;/span>&lt;span class="mi">66&lt;/span> &lt;span class="k">case&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Done&lt;/span>&lt;span class="p">():&lt;/span>
&lt;span class="ln">30&lt;/span>&lt;span class="mi">67&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nx">errors&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">New&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;search canceled&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">31&lt;/span>&lt;span class="mi">68&lt;/span> &lt;span class="k">case&lt;/span> &lt;span class="nx">result&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">ch&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="ln">32&lt;/span>&lt;span class="mi">69&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">result&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">33&lt;/span>&lt;span class="mi">70&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nx">result&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">err&lt;/span>
&lt;span class="ln">34&lt;/span>&lt;span class="mi">71&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">35&lt;/span>&lt;span class="mi">72&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Received:&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">result&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">record&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">36&lt;/span>&lt;span class="mi">73&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="ln">37&lt;/span>&lt;span class="mi">74&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">38&lt;/span>&lt;span class="mi">75&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Listing 4的第50行，&lt;code>process&lt;/code>函数创建了一个100ms的&lt;code>Cancel Context&lt;/code>。关于如何使用&lt;code>Context&lt;/code>你可以阅读&lt;a href="https://blog.golang.org/context">golang.org blog post&lt;/a>。&lt;/p>
&lt;p>第54行，程序创建了一个非缓冲（阻塞）channel允许对它发送&lt;code>result&lt;/code>类型数据或者从它接收。第58行到61行定义了一个匿名函数并启动了一个Goroutine开始执行。这个Goroutine调用了&lt;code>search&lt;/code>函数而后在第60行把返回结果发送到channel。在这个Goroutine工作的时候，&lt;code>process&lt;/code>执行第65行的&lt;code>select&lt;/code>代码块，这个代码块有两个&lt;code>case&lt;/code>分支等待从对应的channel接收数据。&lt;/p>
&lt;p>第66行，这个分支从&lt;code>ctx.Done()&lt;/code>这个channel上接收数据，如果对应的&lt;code>Context&lt;/code>由于100ms超时这个case则被执行。如果这个分支被执行，&lt;code>process&lt;/code>函数则返回错误报告&lt;code>seacrh&lt;/code>超时了。或者说，第68行的分支执行了，意味着&lt;code>search&lt;/code>正常返回了并把结果赋给了变量&lt;code>result&lt;/code>。如上面Listing 3中串行调用&lt;code>search&lt;/code>的那样，第69和70行，程序判断&lt;code>search&lt;/code>函数是否返回错误，如果有则处理错误。如果没有错误，那么在第72行打印结果而后最终发挥&lt;code>nil&lt;/code>给上层调用者。&lt;/p>
&lt;p>这个版本的重构，在&lt;code>process&lt;/code>函数中设定了一个等待&lt;code>search&lt;/code>完成的最长时间，也就是100ms。然后，这种方式也带来了潜在的Goroutine泄漏。想一想这个Goroutine做的事情，在第60行发送结果到channel - 这个操作会阻塞直到另一个Goroutine读取了这个channel里的数据。但是考虑超时的情况，如果超时先发生了（&lt;code>search&lt;/code>还没返回结果），那么&lt;code>select&lt;/code>块就结束等待往下进行（&lt;code>case &amp;lt;-ctx.Done()&lt;/code>分支)，由于channel里的数据没有地方消费那么Goroutine就永久阻塞（第60行），这就导致了Goroutine泄漏。&lt;/p>
&lt;h2 id="修复给channel点空间非缓冲---缓冲">修复：给channel点空间（非缓冲 -&amp;gt; 缓冲）&lt;/h2>
&lt;p>上面的泄漏问题，最简单的解决方式就是 - 把原先的非缓冲（阻塞）channel修改为容量为1的缓冲（非阻塞）channel。&lt;/p>
&lt;p>&lt;strong>Listing 5&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://play.golang.org/p/u3xtQ48G3qK">https://play.golang.org/p/u3xtQ48G3qK&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln">1&lt;/span>&lt;span class="mi">53&lt;/span> &lt;span class="c1">// Make a channel for the goroutine to report its result.
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">54&lt;/span> &lt;span class="c1">// Give it capacity so sending doesn&amp;#39;t block.
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">55&lt;/span> &lt;span class="nx">ch&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="nx">result&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在在超时的那个分支，即使由于超时导致&lt;code>select&lt;/code>块结束等待往下进行（&lt;code>case &amp;lt;-ctx.Done()&lt;/code>分支)，启动&lt;code>search&lt;/code>的那个Goroutine最终也会得到搜索结果并发送到channel进而执行完成返回而不阻塞。最终Goroutine以及channel占用的内存都会被释放掉。所有事情自然而然的都解决了。&lt;/p>
&lt;p>在William Kennedy的一片博文&lt;a href="https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html">The Behavior of Channels&lt;/a>中，他给出了一些很不错的关于channel行为的例子，同时也介绍了如何使用channel的哲学。那篇文章中最后一个例子Listing 10中演示的程序和本文中timeout的例子相似。你可以读一读他的博文以了解更多关于如何使用缓冲channel和如何设置容量的建议。&lt;/p>
&lt;h2 id="结论">结论&lt;/h2>
&lt;p>Go语言中很容易去使用Goroutine，但是如何明智的使用是我们的责任。在本文中，我展示一个错误的使用Goroutine的例子。还有许许多多其他陷阱一样，也是有许许多多的方式会造成并发编程中的Goroutine的泄漏。在将来的博文中，我会提供更多关于Goroutine泄漏的例子和陷阱。现在我留给你一个建议：任何时候你需要启动一个Goroutine的时候，你必须要问问你自己：&lt;/p>
&lt;ul>
&lt;li>它何时会终止？&lt;/li>
&lt;li>有哪些情况会阻碍它终止？&lt;/li>
&lt;/ul>
&lt;p>&lt;em>&lt;strong>并发是非常有用的工具，但是你一定要非常小心的使用它。&lt;/strong>&lt;/em>&lt;/p></description></item></channel></rss>