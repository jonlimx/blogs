<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>外文翻译 on Standing on the Shoulder of Giants</title><link>https://www.jonathanlin.top/categories/%E5%A4%96%E6%96%87%E7%BF%BB%E8%AF%91/</link><description>Recent content in 外文翻译 on Standing on the Shoulder of Giants</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © {year} Jonathan Lin. All rights reserved.</copyright><lastBuildDate>Tue, 06 Jul 2021 14:49:22 +0800</lastBuildDate><atom:link href="https://www.jonathanlin.top/categories/%E5%A4%96%E6%96%87%E7%BF%BB%E8%AF%91/index.xml" rel="self" type="application/rss+xml"/><item><title>Protocol Buffer Language Guide (proto3)</title><link>https://www.jonathanlin.top/posts/protocol-buffer-language-guide/</link><pubDate>Tue, 06 Jul 2021 14:49:22 +0800</pubDate><guid>https://www.jonathanlin.top/posts/protocol-buffer-language-guide/</guid><description>
&lt;p>原文链接：&lt;a href="https://developers.google.com/protocol-buffers/docs/proto3">Language Guide (proto3) | Protocol Buffers | Google Developers&lt;/a>&lt;/p>
&lt;p>本指导文档描述了如何使用protocol buffer语言来构建你的protocol buffer数据，包括&lt;code>.proto&lt;/code>文件的语法规则，包括如何从你的&lt;code>.proto&lt;/code>文件中生成数据访问类。本文介绍的是&lt;strong>proto3&lt;/strong>版本的语言规则，关于&lt;strong>proto2&lt;/strong>版本的信息，请参考： &lt;a href="https://developers.google.com/protocol-buffers/docs/proto">Proto2 Language Guide&lt;/a>。&lt;/p>
&lt;p>本文是一个指导性的参考文档，关于如何使用本文中提及的特性的例子，请参考&lt;a href="https://developers.google.com/protocol-buffers/docs/tutorials">tutorial&lt;/a> 并选择你想要的特定编程语言的例子。&lt;/p>
&lt;h2 id="定义一个消息类型">定义一个消息类型&lt;/h2>
&lt;p>首先让我们来看一个非常简单的例子。比如说你想要定义一个搜索请求这样一个消息，这个消息里包含一个查询字符串（query string）、你所感兴趣页面的数量以及每个页面包含的结果。如下是你的&lt;code>.proto&lt;/code>文件定义：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-protobuf" data-lang="protobuf">syntax &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;proto3&amp;#34;&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">message&lt;/span> &lt;span style="color:#a6e22e">SearchRequest&lt;/span> {&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> query &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">int32&lt;/span> page_number &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">int32&lt;/span> result_per_page &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>}&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>第一行说明你使用的是&lt;code>proto3&lt;/code>版本的语言规则。如果没有这一行，那么protocol buffer编译器会认为你是使用&lt;code>proto2&lt;/code> 版本的语言规则。&lt;code>syntax&lt;/code>定义必须是在&lt;code>.proto&lt;/code>文件的第一行&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>SearchRequest&lt;/code>包含了三个字段（键值对），每个字段都有一个名字和对应的数据类型&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="指定字段类型">指定字段类型&lt;/h3>
&lt;p>上面的例子中，三个字段都是&lt;a href="#%E6%A0%87%E9%87%8F%E7%B1%BB%E5%9E%8B">标量类型&lt;/a>（相对与复合类型，比如struct而言)：两个整型变量（&lt;code>page_number&lt;/code>和&lt;code>result_per_page&lt;/code>）和一个字符串变量（&lt;code>query&lt;/code>)。当然，你可以定义你的字段为复合类型，比如&lt;a href="#%E6%9E%9A%E4%B8%BE">枚举&lt;/a>和其他消息类型。&lt;/p>
&lt;h3 id="分配字段号码">分配字段号码&lt;/h3>
&lt;p>正如你所见，消息定义中的每一个字段都一个唯一的号码。这些字段号码是在二进制消息格式中（&lt;a href="https://developers.google.com/protocol-buffers/docs/encoding">message binary format&lt;/a>）的标识，一旦你开始使用你定义的消息，这些字段号码都不应该再改变。注意，字段号码为1到15的字段在编码的时候占用一个字节（包括字段号码和字段类型，关于这点的更多细节，请参看：&lt;a href="https://developers.google.com/protocol-buffers/docs/encoding#structure">Protocol Buffer Encoding&lt;/a>）。字段号码从16到2047的字段会占用两个字节。因此你应该将1到15范围的号码留给那些在消息里经常用到的字段。并且要考虑预留一些该范围的号码，以便将来扩展你的消息。&lt;/p>
&lt;p>你可以使用的最小字段号码是1，最大字段2&lt;!-- raw HTML omitted -->29&lt;!-- raw HTML omitted --> - 1或者536,870,911。你不可以使用字段号码为19000到19999的部分（&lt;code>FieldDescriptor::kFirstReservedNumber&lt;/code> 到 &lt;code>FieldDescriptor::kLastReservedNumber&lt;/code>），这些是为protocol buffer本身的实现所保留的 - 如果你在&lt;code>.proto&lt;/code>文件中使用了这些保留范围内的字段号码，编译器报错。同样的，如果你使用了那些被标记为&lt;code>reserved&lt;/code>的字段号码，编译器也会报错。&lt;/p>
&lt;h3 id="指定字段规则">指定字段规则&lt;/h3>
&lt;p>消息的字段可以是下面两种形式：&lt;/p>
&lt;ul>
&lt;li>单数形式：一个良好组织的消息可以有零个或者一个这种字段（不能超过一个）。这是&lt;code>proto3&lt;/code>版本的默认字段规则。（个人理解，这里不是说只能定义零个或者一个这种单数形式的字段，而是说定义为单数形式的字段里最多包含一个元素。这个要对应&lt;code>repeated&lt;/code>来理解）&lt;/li>
&lt;li>&lt;code>repeated&lt;/code>：这种字段对应的元素在一个消息里可以重复任意多次。&lt;code>repeated&lt;/code>中的元素的顺序是固定的。&lt;/li>
&lt;/ul>
&lt;p>在&lt;code>proto3&lt;/code>中，标量类型的&lt;code>repeated&lt;/code>字段是默认是使用&lt;code>packed&lt;/code>来编码的。你可以从&lt;a href="https://developers.google.com/protocol-buffers/docs/encoding#packed">Protocol Buffer Encoding&lt;/a>中了解更多关于&lt;code>packed&lt;/code>编码的信息。&lt;/p>
&lt;h3 id="添加更多的消息类型">添加更多的消息类型&lt;/h3>
&lt;p>在一个&lt;code>.proto&lt;/code>文件中你可以定义多种不同的消息类型，如果你奥定义多个相关的消息，这就非常有用 - 比如你想要定义和&lt;code>SearchRequest&lt;/code>相对应的&lt;code>SearchResponse&lt;/code>消息，你可以在同一个&lt;code>.proto&lt;/code>文件中添加：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span style="color:#66d9ef">message&lt;/span> &lt;span style="color:#a6e22e">SearchRequest&lt;/span> {&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> query &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">int32&lt;/span> page_number &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">int32&lt;/span> result_per_page &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>}&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">message&lt;/span> &lt;span style="color:#a6e22e">SearchResponse&lt;/span> {&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#f92672">...&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>}&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="添加注释">添加注释&lt;/h3>
&lt;p>在&lt;code>.proto&lt;/code>中添加注释，你可以使用C/C++风格的语法：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span style="color:#75715e">/* SearchRequest represents a search query, with pagination options to
&lt;/span>&lt;span style="color:#75715e"> * indicate which results to include in the response. */&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">message&lt;/span> &lt;span style="color:#a6e22e">SearchRequest&lt;/span> {&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> query &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">int32&lt;/span> page_number &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>; &lt;span style="color:#75715e">// Which page number do we want?
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int32&lt;/span> result_per_page &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>; &lt;span style="color:#75715e">// Number of results to return per page.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="保留字段">保留字段&lt;/h3>
&lt;p>如果你&lt;a href="#%E6%9B%B4%E6%96%B0%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B">更新息类型&lt;/a>的时候删除了一个字段，或者把一个字段注释掉，将来其他人在更新相同的消息的时候是可以重用之前字段的号码。之后在他们使用老版本的&lt;code>.proto&lt;/code>时将会导致许多问题，包括数据出错，privacy bugs等。为了确保这些问题不会发生，有一个办法是把那些你删除的字段的使用过的字段号码（和/或名称）标记为&lt;code>reserved&lt;/code>。如果你使用了这些被&lt;code>reserved&lt;/code>标记的号码，编译器会报错。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span style="color:#66d9ef">message&lt;/span> &lt;span style="color:#a6e22e">Foo&lt;/span> {&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> reserved &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">15&lt;/span>, &lt;span style="color:#ae81ff">9&lt;/span> &lt;span style="color:#66d9ef">to&lt;/span> &lt;span style="color:#ae81ff">11&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> reserved &lt;span style="color:#e6db74">&amp;#34;foo&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;bar&amp;#34;&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>}&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意，你不可以在同一个&lt;code>reserved&lt;/code>语句中同时制定字段号码和字段名称。&lt;/p>
&lt;h3 id="从proto文件中生成的代码">从&lt;code>.proto&lt;/code>文件中生成的代码&lt;/h3>
&lt;p>当你编译&lt;code>.proto&lt;/code>文件时，编译器会生成你指定的语言代码来和你定义在&lt;code>.proto&lt;/code>文件中消息交互，包括访问和设置字段的值、序列化你的消息问输出流以及从输入流中解析为消息。&lt;/p>
&lt;ul>
&lt;li>**C++**语言：生成&lt;code>.h&lt;/code>和&lt;code>.cc&lt;/code>文件，每个消息都会生成一个对应的类&lt;/li>
&lt;li>&lt;strong>Java&lt;/strong>语言，每个消息都会生成一个包含对应类的&lt;code>.java&lt;/code>文件，以及创建对应类实例的&lt;code>Builder&lt;/code>类&lt;/li>
&lt;li>&lt;strong>Kotlin&lt;/strong>语言，除了和Java语言生成的一样的代码以外，还会生成一个&lt;code>.kt&lt;/code>文件包含一个用例创建类型实例的DSL&lt;/li>
&lt;li>&lt;strong>Pytyon&lt;/strong>语言少许不同，生成一个包含了每个消息对应的静态描述器的模块，这些被用来在运行时创建必要的Python数据访问类&lt;/li>
&lt;li>&lt;strong>Go&lt;/strong>语言，生成一个包含所有消息的&lt;code>.pb.go&lt;/code>代码文件&lt;/li>
&lt;li>&lt;strong>Ruby&lt;/strong>语言，生成一个包含所有消息的&lt;code>.rb&lt;/code>代码文件&lt;/li>
&lt;li>&lt;strong>Object-C&lt;/strong>语言，生成一个&lt;code>probjc.h&lt;/code>和&lt;code>projc.m&lt;/code>文件，每一个消息对应了一个类&lt;/li>
&lt;li>**C#**语言，生成一个&lt;code>.cs&lt;/code>文件，每一个消息对应了一个类&lt;/li>
&lt;li>&lt;strong>Dart&lt;/strong>，生成一个&lt;code>.pb.dart&lt;/code>文件，每一个消息对应了一个类&lt;/li>
&lt;/ul>
&lt;p>关于特定语言的API的使用，你可以参考：&lt;a href="https://developers.google.com/protocol-buffers/docs/reference/overview">API reference&lt;/a>。&lt;/p>
&lt;h2 id="标量类型">标量类型&lt;/h2>
&lt;p>标量类型即下表中的一种类型。下表展示了&lt;code>.proto&lt;/code>中支持的标量类型和特定语言标量类型的对应关系（原文有更多的编程语言的对应关系，译文中我只选取我关心的语言☺）：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">.proto Type&lt;/th>
&lt;th style="text-align:left">Notes&lt;/th>
&lt;th style="text-align:left">C++ Type&lt;/th>
&lt;th style="text-align:left">Java/Kotlin Type[1]&lt;/th>
&lt;th style="text-align:left">Python Type[3]&lt;/th>
&lt;th style="text-align:left">Go Type&lt;/th>
&lt;th style="text-align:left">C# Type&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">double&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;td style="text-align:left">double&lt;/td>
&lt;td style="text-align:left">double&lt;/td>
&lt;td style="text-align:left">float&lt;/td>
&lt;td style="text-align:left">float64&lt;/td>
&lt;td style="text-align:left">double&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">float&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;td style="text-align:left">float&lt;/td>
&lt;td style="text-align:left">float&lt;/td>
&lt;td style="text-align:left">float&lt;/td>
&lt;td style="text-align:left">float32&lt;/td>
&lt;td style="text-align:left">float&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">int32&lt;/td>
&lt;td style="text-align:left">Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead.&lt;/td>
&lt;td style="text-align:left">int32&lt;/td>
&lt;td style="text-align:left">int&lt;/td>
&lt;td style="text-align:left">int&lt;/td>
&lt;td style="text-align:left">int32&lt;/td>
&lt;td style="text-align:left">int&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">int64&lt;/td>
&lt;td style="text-align:left">Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead.&lt;/td>
&lt;td style="text-align:left">int64&lt;/td>
&lt;td style="text-align:left">long&lt;/td>
&lt;td style="text-align:left">int/long[4]&lt;/td>
&lt;td style="text-align:left">int64&lt;/td>
&lt;td style="text-align:left">long&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">uint32&lt;/td>
&lt;td style="text-align:left">Uses variable-length encoding.&lt;/td>
&lt;td style="text-align:left">uint32&lt;/td>
&lt;td style="text-align:left">int[2]&lt;/td>
&lt;td style="text-align:left">int/long[4]&lt;/td>
&lt;td style="text-align:left">uint32&lt;/td>
&lt;td style="text-align:left">uint&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">uint64&lt;/td>
&lt;td style="text-align:left">Uses variable-length encoding.&lt;/td>
&lt;td style="text-align:left">uint64&lt;/td>
&lt;td style="text-align:left">long[2]&lt;/td>
&lt;td style="text-align:left">int/long[4]&lt;/td>
&lt;td style="text-align:left">uint64&lt;/td>
&lt;td style="text-align:left">ulong&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">sint32&lt;/td>
&lt;td style="text-align:left">Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s.&lt;/td>
&lt;td style="text-align:left">int32&lt;/td>
&lt;td style="text-align:left">int&lt;/td>
&lt;td style="text-align:left">int&lt;/td>
&lt;td style="text-align:left">int32&lt;/td>
&lt;td style="text-align:left">int&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">sint64&lt;/td>
&lt;td style="text-align:left">Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s.&lt;/td>
&lt;td style="text-align:left">int64&lt;/td>
&lt;td style="text-align:left">long&lt;/td>
&lt;td style="text-align:left">int/long[4]&lt;/td>
&lt;td style="text-align:left">int64&lt;/td>
&lt;td style="text-align:left">long&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">fixed32&lt;/td>
&lt;td style="text-align:left">Always four bytes. More efficient than uint32 if values are often greater than 228.&lt;/td>
&lt;td style="text-align:left">uint32&lt;/td>
&lt;td style="text-align:left">int[2]&lt;/td>
&lt;td style="text-align:left">int/long[4]&lt;/td>
&lt;td style="text-align:left">uint32&lt;/td>
&lt;td style="text-align:left">uint&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">fixed64&lt;/td>
&lt;td style="text-align:left">Always eight bytes. More efficient than uint64 if values are often greater than 256.&lt;/td>
&lt;td style="text-align:left">uint64&lt;/td>
&lt;td style="text-align:left">long[2]&lt;/td>
&lt;td style="text-align:left">int/long[4]&lt;/td>
&lt;td style="text-align:left">uint64&lt;/td>
&lt;td style="text-align:left">ulong&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">sfixed32&lt;/td>
&lt;td style="text-align:left">Always four bytes.&lt;/td>
&lt;td style="text-align:left">int32&lt;/td>
&lt;td style="text-align:left">int&lt;/td>
&lt;td style="text-align:left">int&lt;/td>
&lt;td style="text-align:left">int32&lt;/td>
&lt;td style="text-align:left">int&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">sfixed64&lt;/td>
&lt;td style="text-align:left">Always eight bytes.&lt;/td>
&lt;td style="text-align:left">int64&lt;/td>
&lt;td style="text-align:left">long&lt;/td>
&lt;td style="text-align:left">int/long[4]&lt;/td>
&lt;td style="text-align:left">int64&lt;/td>
&lt;td style="text-align:left">long&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">bool&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;td style="text-align:left">bool&lt;/td>
&lt;td style="text-align:left">boolean&lt;/td>
&lt;td style="text-align:left">bool&lt;/td>
&lt;td style="text-align:left">bool&lt;/td>
&lt;td style="text-align:left">bool&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">A string must always contain UTF-8 encoded or 7-bit ASCII text, and cannot be longer than 232.&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">String&lt;/td>
&lt;td style="text-align:left">str/unicode[5]&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">bytes&lt;/td>
&lt;td style="text-align:left">May contain any arbitrary sequence of bytes no longer than 232.&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">ByteString&lt;/td>
&lt;td style="text-align:left">str&lt;/td>
&lt;td style="text-align:left">[]byte&lt;/td>
&lt;td style="text-align:left">ByteString&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>你可以从&lt;a href="https://developers.google.com/protocol-buffers/docs/encoding">Protocol Buffer Encoding&lt;/a>了解更多关于消息序列化时的编码相关的信息。&lt;/p>
&lt;h2 id="默认值">默认值&lt;/h2>
&lt;p>解析消息的时候，如果原先经过编码的消息里没有包含特定的单数形式的元素（原文很拗口，个人觉得这里就是说从编码的消息里解析的时候找不到特定的字段），那些这些字段就被赋值成对应类型的默认值，规则如下：&lt;/p>
&lt;ul>
&lt;li>strings类型的默认值是空字符串&lt;/li>
&lt;li>bytes类型的默认值是空字节&lt;/li>
&lt;li>bools类型的默认值是false&lt;/li>
&lt;li>数字类型的默认值是0&lt;/li>
&lt;li>&lt;a href="#%E6%9E%9A%E4%B8%BE">枚举类型&lt;/a>类型的默认值是枚举的第一个元素，也就是枚举值为0的元素&lt;/li>
&lt;li>如果字段类型是其他的消息，那么其默认值跟特定的语言相关，详见：&lt;a href="https://developers.google.com/protocol-buffers/docs/reference/overview">generated code guide&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;code>repeated&lt;/code>类型的字段的默认值一般是对应语言里的空列表。&lt;/p>
&lt;p>对于标量类型的字段，实际上消息解析以后是没办法确定字段的值是人为设置的还是由于根本就没有赋值，而后解析的时候被解析成了默认值 - 你在定义消息的时候需要牢记这一点。例如说，不要定义一个boolean类型的开关是的当值为false的时候执行某些动作（如果你不希望这个动作默认是要执行的，因为boolean类型的默认值就是false）。同时还需要注意，当一个标量字段被设置为默认值的时候，值是不会被序列化的。&lt;/p>
&lt;h2 id="枚举">枚举&lt;/h2>
&lt;p>当你定义你的消息的时候，你可能希望某些字段的值只能从一些预先定义好的值里来。例如，你想为你的&lt;code>SearchRequest&lt;/code>添加一个&lt;code>corpus&lt;/code>字段，这个字段的值可以是&lt;code>UNIVERSAL&lt;/code>, &lt;code>WEB&lt;/code>, &lt;code>IMAGES&lt;/code>, &lt;code>LOCAL&lt;/code>, &lt;code>NEWS&lt;/code>, &lt;code>PRODUCTS&lt;/code> 或者 &lt;code>VIDEO&lt;/code>。你可以通过定义枚举类满足你的需求，枚举中所有可能的值都是一个常量。&lt;/p>
&lt;p>下面的例子中我们添加了一个名为&lt;code>Corpus&lt;/code>的枚举，这个枚举中定义了它可能的值，同时也定义类型为&lt;code>Corpus&lt;/code>的字段：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span style="color:#66d9ef">message&lt;/span> &lt;span style="color:#a6e22e">SearchRequest&lt;/span> {&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> query &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">int32&lt;/span> page_number &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">int32&lt;/span> result_per_page &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">enum&lt;/span> Corpus {&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> UNIVERSAL &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> WEB &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> IMAGES &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> LOCAL &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> NEWS &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> PRODUCTS &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> VIDEO &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> }&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> Corpus corpus &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>}&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如你所见，枚举&lt;code>Corpus&lt;/code>中的第一个值&lt;code>UNIVERSAL&lt;/code>是常量0：实际上所有的枚举的第一个常量值都应该是0，这是因为：&lt;/p>
&lt;ul>
&lt;li>一定得有0值，这样枚举可以当成数字类型，默认值就是0&lt;/li>
&lt;li>0值作为枚举的第一个元素，这个和&lt;code>proto2&lt;/code>的语言兼容，即第一个元素的值总是默认值&lt;/li>
&lt;/ul>
&lt;p>你可以通过给不同的枚举元素赋相同的值来定义别名，前提是你需要把&lt;code>allow_alias&lt;/code>选项设置为&lt;code>true&lt;/code>，否者编译器遇到这样的别名设置会报错。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span style="color:#66d9ef">message&lt;/span> &lt;span style="color:#a6e22e">MyMessage1&lt;/span> {&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">enum&lt;/span> EnumAllowingAlias {&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">option&lt;/span> allow_alias &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> UNKNOWN &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> STARTED &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> RUNNING &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> }&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>}&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">message&lt;/span> &lt;span style="color:#a6e22e">MyMessage2&lt;/span> {&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">enum&lt;/span> EnumNotAllowingAlias {&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> UNKNOWN &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> STARTED &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#75715e">// RUNNING = 1; // Uncommenting this line will cause a compile error inside Google and a warning message outside.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> }&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>}&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>枚举元素的值不能超过32位整型的范围。由于枚举值是使用&lt;a href="https://developers.google.com/protocol-buffers/docs/encoding">varint encoding&lt;/a> 编码，负值是无效的因此也不建议使用负值。你可以在一个消息内部定义枚举（如上面的例子所示）或者外部定义，然后可以在&lt;code>.proto&lt;/code>中定义的任意消息里使用内部或者外部定义的枚举。你可以像使用消息里的字段一样来使用定义在一个消息内部的枚举：&lt;code>_MessageType_._EnumType_&lt;/code>。&lt;/p>
&lt;p>在&lt;code>.proto&lt;/code>中定义的&lt;code>enum&lt;/code>，对应生成的代码中，比如Java，Kotlin，C++也会有对应的&lt;code>enum&lt;/code>，Pyton语言是&lt;code>EnumDescriptor&lt;/code>类。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>注意:&lt;/strong> 对于枚举类型的值的个数限制，这个是和编程语言本身相关，关于这个限制请查看特定的语言说明。&lt;/p>
&lt;/blockquote>
&lt;p>在反序列化的时候，对于无法识别的枚举值，也会在消息中保留下来，至于保留下来以何种方式展现，这个就和语言相关了。对于那些允许枚举值越界的变成语言，比如C++和Go，这些未知的枚举值就是被简单的以整型形式保留。对于不允许枚举值越界的语言，比如Java，可以通过特定的访问器来访问底层的整型值。不管何种情况，消息序列化的时候，会把无法识别的枚举值包含进去。&lt;/p>
&lt;p>更多关于如何使用&lt;code>enum&lt;/code>的信息，请参考：&lt;a href="https://developers.google.com/protocol-buffers/docs/reference/overview">generated code guide&lt;/a>中特定编程语言的部分。&lt;/p>
&lt;h3 id="枚举保留值">枚举保留值&lt;/h3>
&lt;p>如果你&lt;a href="#%E6%9B%B4%E6%96%B0%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B">更新消息类型&lt;/a>的时候删除了一个枚举项或者注释掉，后面其他人在更新这个枚举的时候可以重用原枚举项对应的数值。之后在他们使用老版本的&lt;code>.proto&lt;/code>时将会导致许多问题，包括数据出错，privacy bugs等。为了确保这些问题不会发生，有一个办法是把那些你删除的枚举项的使用过的数值（和/或名称）标记为&lt;code>reserved&lt;/code>。如果你使用了这些被&lt;code>reserved&lt;/code>标记的号码，编译器会报错。你可以指定你保留的枚举数值的范围，你可以使用&lt;code>max&lt;/code>关键字来指定范围的最大值。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span style="color:#66d9ef">enum&lt;/span> Foo {&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> reserved &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">15&lt;/span>, &lt;span style="color:#ae81ff">9&lt;/span> &lt;span style="color:#66d9ef">to&lt;/span> &lt;span style="color:#ae81ff">11&lt;/span>, &lt;span style="color:#ae81ff">40&lt;/span> &lt;span style="color:#66d9ef">to&lt;/span> &lt;span style="color:#66d9ef">max&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> reserved &lt;span style="color:#e6db74">&amp;#34;FOO&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;BAR&amp;#34;&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>}&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意，你不可以在同一个&lt;code>reserved&lt;/code>语句中同时指定枚举项的名称和枚举值。&lt;/p>
&lt;h2 id="使用其他消息类型">使用其他消息类型&lt;/h2>
&lt;p>你可以使用其他消息作为你的字段的类型。例如，你希望你的&lt;code>SearchResponse&lt;/code>中包含&lt;code>Result&lt;/code>类型的字段 - 你可以在同一个&lt;code>.proto&lt;/code>文件找那个定义&lt;code>Result&lt;/code>消息，然后指定&lt;code>SearchResponse&lt;/code>的字段为&lt;code>Result&lt;/code>类型：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span style="color:#66d9ef">message&lt;/span> &lt;span style="color:#a6e22e">SearchResponse&lt;/span> {&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">repeated&lt;/span> Result results &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>}&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">message&lt;/span> &lt;span style="color:#a6e22e">Result&lt;/span> {&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> url &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> title &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">repeated&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> snippets &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>}&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="导入定义">导入定义&lt;/h3>
&lt;p>&lt;strong>注意，这个特性不适用于Java&lt;/strong>&lt;/p>
&lt;p>在上面的例子中，&lt;code>Result&lt;/code>是和&lt;code>SearchResponse&lt;/code>位于相同的&lt;code>.proto&lt;/code>文件中 - 如果你想要使用的消息类型是定义在其他&lt;code>.proto&lt;/code>文件中呢？&lt;/p>
&lt;p>你可以通过导入&lt;code>.proto&lt;/code>文件来使用定义在其他&lt;code>.proto&lt;/code>文件中的消息类型。你可以在文件头部添加import语句来导入：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span style="color:#66d9ef">import&lt;/span> &lt;span style="color:#e6db74">&amp;#34;myproject/other_protos.proto&amp;#34;&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>默认情况下，你只能使用直接导入的&lt;code>.proto&lt;/code>文件中定义的消息类型。但是，有时候你可能需要把&lt;code>.proto&lt;/code>文件移动到一个新的位置。你可以直接移动&lt;code>.proto&lt;/code>文件到一个新的位置，然后然后更新所有的import语句指向&lt;code>.proto&lt;/code>的新位置，你现在也可以在原来的位置放一个”假“的&lt;code>.proto&lt;/code>然后使用&lt;code>import public&lt;/code>语句把老的&lt;code>.proto&lt;/code>中的import语句重定向到新的位置。任何导入了包含&lt;code>import public&lt;/code>的&lt;code>.proto&lt;/code>文件也就把&lt;code>import public&lt;/code>的依赖也导入了。例如：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span style="color:#75715e">// new.proto
&lt;/span>&lt;span style="color:#75715e">// All definitions are moved here
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span style="color:#75715e">// old.proto
&lt;/span>&lt;span style="color:#75715e">// This is the proto that all clients are importing.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">import&lt;/span> public &lt;span style="color:#e6db74">&amp;#34;new.proto&amp;#34;&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">import&lt;/span> &lt;span style="color:#e6db74">&amp;#34;other.proto&amp;#34;&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span style="color:#75715e">// client.proto
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">import&lt;/span> &lt;span style="color:#e6db74">&amp;#34;old.proto&amp;#34;&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#75715e">// You use definitions from old.proto and new.proto, but not other.proto
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>protocol buffer编译器从命令行参数&lt;code>-I&lt;/code>/&lt;code>--proto_path&lt;/code>指定的一系列路径中查找导入的&lt;code>.proto&lt;/code>文件。如果这个参数没有指定一个值，编译器就从运行的目录里查找。通常地，你应该把&lt;code>--proto_path&lt;/code>的值设置为你项目的根目录，然后在import语句中使用完整的名称。&lt;/p>
&lt;h3 id="使用proto2的消息类型">使用&lt;code>proto2&lt;/code>的消息类型&lt;/h3>
&lt;p>在&lt;code>proto3&lt;/code>的消息中导入并使用&lt;code>proto2&lt;/code>的消息类型是可以的，相反也是可以。但是&lt;code>proto2&lt;/code>的枚举是无法在&lt;code>proto3&lt;/code>中使用（如果&lt;code>proto2&lt;/code>的消息体中使用&lt;code>proto2&lt;/code>枚举是可以的）&lt;/p>
&lt;h2 id="嵌套类型">嵌套类型&lt;/h2>
&lt;p>你可以在一个消息类型里定义嵌套的消息类型并使用它，如下面的例子所示 - &lt;code>Result&lt;/code>消息是定义在&lt;code>SearchResponse&lt;/code>里的：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span style="color:#66d9ef">message&lt;/span> &lt;span style="color:#a6e22e">SearchResponse&lt;/span> {&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">message&lt;/span> &lt;span style="color:#a6e22e">Result&lt;/span> {&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> url &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> title &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">repeated&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> snippets &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> }&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">repeated&lt;/span> Result results &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>}&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果你想在定义嵌套消息的父消息外使用，你可以通过&lt;code>_Parent_._Type_&lt;/code>来使用：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span style="color:#66d9ef">message&lt;/span> &lt;span style="color:#a6e22e">SomeOtherMessage&lt;/span> {&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> SearchResponse.Result result &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>}&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>你可以多层嵌套消息，如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span style="color:#66d9ef">message&lt;/span> &lt;span style="color:#a6e22e">Outer&lt;/span> { &lt;span style="color:#75715e">// Level 0
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">message&lt;/span> &lt;span style="color:#a6e22e">MiddleAA&lt;/span> { &lt;span style="color:#75715e">// Level 1
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">message&lt;/span> &lt;span style="color:#a6e22e">Inner&lt;/span> { &lt;span style="color:#75715e">// Level 2
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int64&lt;/span> ival &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> booly &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> }&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> }&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">message&lt;/span> &lt;span style="color:#a6e22e">MiddleBB&lt;/span> { &lt;span style="color:#75715e">// Level 1
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">message&lt;/span> &lt;span style="color:#a6e22e">Inner&lt;/span> { &lt;span style="color:#75715e">// Level 2
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int32&lt;/span> ival &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> booly &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> }&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> }&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>}&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="更新消息类型">更新消息类型&lt;/h2>
&lt;p>如果当前的消息已经不能满足你的需要，例如你希望你的消息里添加一个额外的字段，但是你仍然希望使用基于老的格式生成的代码。不用担心，更新消息类型而不破坏现有的代码是很简单的。你只需要记住以下规则：&lt;/p>
&lt;ul>
&lt;li>不要更改现有字段的字段号码&lt;/li>
&lt;li>如果你添加了&lt;/li>
&lt;/ul></description></item><item><title>Protocol Buffer Basics Go</title><link>https://www.jonathanlin.top/posts/protocol-buffer-basics-go/</link><pubDate>Thu, 01 Jul 2021 13:54:58 +0800</pubDate><guid>https://www.jonathanlin.top/posts/protocol-buffer-basics-go/</guid><description>
&lt;p>原文链接：&lt;a href="https://developers.google.com/protocol-buffers/docs/gotutorial">Protocol Buffer Basics: Go | Protocol Buffers | Google Developers&lt;/a>&lt;/p>
&lt;p>本教程使用proto3语言为Go程序员介绍了protocol buffers的基本使用。通过一步步创建一个简单的示例应用，你将会了解到：&lt;/p>
&lt;ul>
&lt;li>在&lt;code>.proto&lt;/code>文件中定义消息格式&lt;/li>
&lt;li>使用protocol buffer编译器&lt;/li>
&lt;li>使用Go protocol buffer API读写消息&lt;/li>
&lt;/ul>
&lt;p>这不是一个使用protocol buffers的完全手册。更多更细节的信息，请参看：&lt;a href="https://developers.google.com/protocol-buffers/docs/proto3">Language Guide (proto3)&lt;/a>、&lt;a href="https://pkg.go.dev/google.golang.org/protobuf/proto">Go API Reference&lt;/a>、&lt;a href="https://developers.google.com/protocol-buffers/docs/reference/go-generated">Go Generated Code&lt;/a>和&lt;a href="https://developers.google.com/protocol-buffers/docs/encoding">Encoding Reference&lt;/a>&lt;/p>
&lt;h2 id="为什么使用protocol-buffers">为什么使用protocol buffers？&lt;/h2>
&lt;p>我们将要创建一个简单的“地址簿”应用，该应用可以从文件中读和写联系人的信息。地址簿中的每一个联系人有名字，ID和联系电话。&lt;/p>
&lt;p>你如何序列化和读取这种结构化数据？有这么几种方式可以解决这个问题：&lt;/p>
&lt;ul>
&lt;li>使用&lt;a href="https://golang.org/pkg/encoding/gob/">gobs&lt;/a>序列化Go数据结构。对于Go语言本身而言，这是一个很好的方案，但是如果你需要跨语言平台共享数据，那这种方式并不好&lt;/li>
&lt;li>按照你期望的方式把数据编码成单一的字符串，例如4个int类型的数据编码成“12:3:-23:67”。这是一个简单且灵活的办法，但这要求你编写一次性的编码和转换的代码，同时转化代码会带来一定的运行时消耗。对于比较简单的数据，使用这种方式就比较好&lt;/li>
&lt;li>将数据序列化成XML。XML对人类可读友好且各种语言都有对应的解析工具使得该方法有点吸引人。XML也能比较好的跨应用/项目共享数据。然而，众所周知，XML占用空间比较大，并且解析XML往往比较耗性能。此外，定位XML DOM树通常比直接访问类字段要复杂的多&lt;/li>
&lt;/ul>
&lt;p>Protocol buffers具有灵活、高效、自动化等特点可以解决上述问题。使用Protocol buffer，你需要把数据结构的描述定义在&lt;code>.proto&lt;/code>文件中，然后protocol buffer编译器会为你生成一个类，这个类实现了对protocol buffer二进制数据的编码和解析。这个类提供了对各个字段的getter和setter方法用于读写。protocol buffer很重要的一点是，如果将来数据格式扩展了，那么代码中依然可以读取由旧的格式编码的数据。&lt;/p>
&lt;h2 id="哪里找示例代码">哪里找示例代码&lt;/h2>
&lt;p>我们的例子是一系列的命令行程序，这些程序管理了由protocol buffers编码的地址簿数据文件。&lt;code>add_person_go&lt;/code>这个命令添加一条记录到数据文件。&lt;code>list_people_go&lt;/code>解析数据文件并把结果输出到控制台。&lt;/p>
&lt;p>你可以从Github Repo中找到完整的示例：&lt;a href="https://github.com/protocolbuffers/protobuf/tree/master/examples">protobuf/examples at master · protocolbuffers/protobuf (github.com)&lt;/a>&lt;/p>
&lt;h2 id="定义你的protocol格式">定义你的protocol格式&lt;/h2>
&lt;p>创建你的地址簿应用的第一步是定义你的&lt;code>.proto&lt;/code>文件。&lt;code>.proto&lt;/code>文件中的定义很简单：你为你想要序列化的每一个数据结构添加一个消息，然后为消息中的每个字段指定一个名称和对应的类型。在我们的例子中，在&lt;code>.proto&lt;/code>中定义的消息请参考&lt;a href="https://github.com/protocolbuffers/protobuf/blob/master/examples/addressbook.proto">addressbook.proto&lt;/a>。&lt;/p>
&lt;p>&lt;code>.proto&lt;/code>文件是从一个包声明开始的，包声明用来防止在不同项目中的名字冲突。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-protobuf" data-lang="protobuf">syntax &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;proto3&amp;#34;&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#f92672">package&lt;/span> tutorial;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">import&lt;/span> &lt;span style="color:#e6db74">&amp;#34;google/protobuf/timestamp.proto&amp;#34;&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>go_package&lt;/code>定义了代码生成所在的路径，包名即路径中的最后一个目录。例如，我们的例子的包名就是”tutorialpb“。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span style="color:#66d9ef">option&lt;/span> go_package &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;github.com/protocolbuffers/protobuf/examples/go/tutorialpb&amp;#34;&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来，你就可以定义你的消息了。一个小时是包含一组含有类型的字段的集合。许多标准的简单值类型都是支持的，例如&lt;code>bool&lt;/code> 、&lt;code>int32&lt;/code>、 &lt;code>float&lt;/code>、 &lt;code>double&lt;/code> 和&lt;code>string&lt;/code>。你也可以包含其他消息在你要定义的消息里。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span style="color:#66d9ef">message&lt;/span> &lt;span style="color:#a6e22e">Person&lt;/span> {&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">int32&lt;/span> id &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>; &lt;span style="color:#75715e">// Unique ID number for this person.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> email &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">enum&lt;/span> PhoneType {&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> MOBILE &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> HOME &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> WORK &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> }&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">message&lt;/span> &lt;span style="color:#a6e22e">PhoneNumber&lt;/span> {&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> number &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> PhoneType type &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> }&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">repeated&lt;/span> PhoneNumber phones &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> google.protobuf.Timestamp last_updated &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>}&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#75715e">// Our address book file is just one of these.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">message&lt;/span> &lt;span style="color:#a6e22e">AddressBook&lt;/span> {&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">repeated&lt;/span> Person people &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>}&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的例子中，&lt;code>Person&lt;/code>这个消息里包含了&lt;code>PhoneNumber&lt;/code>这个消息，&lt;code>AddressBook&lt;/code>这个消息包含了&lt;code>Person&lt;/code>这个消息。你甚至可以消息里定义另一个消息 - 正如你看到的，&lt;code>PhoneNumber&lt;/code>是定义在&lt;code>Person&lt;/code>里的。如果你希望你的取值是预先定义的一组值里的一个，那么你可以定义&lt;code>enum&lt;/code>类型 - 上面的例子中，你希望电话号码的类型是&lt;code>MOBILE&lt;/code>、 &lt;code>HOME&lt;/code>或者 &lt;code>WORK&lt;/code>。&lt;/p>
&lt;p>在每一个字段上诸如&amp;quot;= 1&amp;quot; &amp;ldquo;= 2&amp;quot;的标记是用于在二进制编码的时候对字段指定一个唯一的标记。相对于更高的标记号码而言，1 -15号在编码的时候占用的空间小于一个字节，因此一个有优化手段是你可以把经常会用到的字段或者重复类型的字段（例如数组）标记为1 - 15，把高于15的留给那些不怎么常用到的字段或者可选的字段。重复类型字段里的每一个元素都需要重新编码标记号码，因此重复类型的字段往往都会用到这种优化 。（&lt;em>&lt;strong>这块后面需要再理解一下是什么意思&lt;/strong>&lt;/em>）&lt;/p>
&lt;p>如果一个字段的值没有设置，那么将使用对应类型的&lt;a href="https://developers.google.com/protocol-buffers/docs/proto3#default">默认值&lt;/a>：数字类型的默认值是0，字符串默认值是空字符串，布尔类型的默认值是false。对于嵌套的消息，它的默认值是带有各个字段名的默认值。调用访问器（getter）去读取值的时候，如果对应的字段没有明确赋值，那么就返回对应的默认值。&lt;/p>
&lt;p>如果一个字段是重复类型，那么元素的个数可能是任意数目（包括0个）。元素的顺序在protocol buffer中是被保留下来的。可以想象重复类型字段是动态数组。&lt;/p>
&lt;p>你将在&lt;a href="https://developers.google.com/protocol-buffers/docs/proto3">Protocol Buffer Language Guide&lt;/a>中找到如何编写&lt;code>.proto&lt;/code>文件的完整教程（包括所有的类型）。至于类似于类继承这种机制就不要找了，protocol buffer不支持。&lt;/p>
&lt;h2 id="编译protocol-buffers">编译protocol buffers&lt;/h2>
&lt;p>现在你已经有&lt;code>.proto&lt;/code>文件了，接下来你需要基于这个文件去生成访问&lt;code>AddresBook&lt;/code>消息（&lt;code>Person&lt;/code>和&lt;code>PhoneNumber&lt;/code>也是）的类了。你将要使用protocol buffer编译器&lt;code>protoc&lt;/code>来编译你的&lt;code>.proto&lt;/code>文件：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>如果你还未安装编译器，请先&lt;a href="https://developers.google.com/protocol-buffers/docs/downloads">Download Protocol Buffers&lt;/a>，然后参考README进行安装&lt;/p>
&lt;/li>
&lt;li>
&lt;p>运行下面的命令安装Go protocol buffers plugin：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">go get github.com/golang/protobuf/protoc-gen-go
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;p>编译器plugin &lt;code>protoc-gen-to&lt;/code>将被安装在&lt;code>$GOBIN&lt;/code>目录，该目录默认是在&lt;code>$GOPATH/bin&lt;/code>。这个目录必须包含在你的&lt;code>$PATH&lt;/code>中。&lt;/p>
&lt;ol start="3">
&lt;li>
&lt;p>现在你可以运行编译器，指定源目录（就是你的源文件所在的目录，如果没有指定就是指当前目录）和目标目录（生成的代码所在的目录）以及&lt;code>.proto&lt;/code>所在的目录。在我们的例子中，你应该运行下面命令：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">protoc -I&lt;span style="color:#f92672">=&lt;/span>$SRC_DIR --go_out&lt;span style="color:#f92672">=&lt;/span>$DST_DIR $SRC_DIR/addressbook.proto
&lt;/code>&lt;/pre>&lt;/div>&lt;p>由于你是需要生成Go代码，你应该使用&lt;code>--go-out&lt;/code>选项，其他语言则使用对应的选项。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>运行后，你将会在特定的目录看到生成的代码：&lt;code>github.com/protocolbuffers/protobuf/examples/go/tutorialpb/addressbook.pb.go&lt;/code>。&lt;/p>
&lt;h2 id="protocol-buffer-api">Protocol Buffer API&lt;/h2>
&lt;p>生成的&lt;code>addressbook.pb.go&lt;/code>提供了以下有用的类型：&lt;/p>
&lt;ul>
&lt;li>&lt;code>AddressBook&lt;/code>结构体包含了&lt;code>People&lt;/code>类型的字段&lt;/li>
&lt;li>&lt;code>Person&lt;/code>结构体包含了&lt;code>Name&lt;/code>、&lt;code>Id&lt;/code>、&lt;code>Email&lt;/code>和 &lt;code>Phones&lt;/code>字段&lt;/li>
&lt;li>&lt;code>Person_PhoneNumber&lt;/code>结构体包含了&lt;code>Number&lt;/code>和&lt;code>Type&lt;/code>字段&lt;/li>
&lt;li>&lt;code>Person_PhoneType&lt;/code>结构体和&lt;code>Person.PhoneType&lt;/code>枚举&lt;/li>
&lt;/ul>
&lt;p>你可以从&lt;a href="https://developers.google.com/protocol-buffers/docs/reference/go-generated">Go Generated Code guide&lt;/a>了解到代码生成的细节，对于大部分代码你只需要像对待Go类型一样。&lt;/p>
&lt;p>&lt;code>list_people&lt;/code>的单元测试&lt;a href="https://github.com/protocolbuffers/protobuf/blob/master/examples/list_people_test.go">command&amp;rsquo;s unit tests&lt;/a>中展示了你应该如何创建&lt;code>Person&lt;/code>的实例：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">pb&lt;/span>.&lt;span style="color:#a6e22e">Person&lt;/span>{
&lt;span style="color:#a6e22e">Id&lt;/span>: &lt;span style="color:#ae81ff">1234&lt;/span>,
&lt;span style="color:#a6e22e">Name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;John Doe&amp;#34;&lt;/span>,
&lt;span style="color:#a6e22e">Email&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;jdoe@example.com&amp;#34;&lt;/span>,
&lt;span style="color:#a6e22e">Phones&lt;/span>: []&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">pb&lt;/span>.&lt;span style="color:#a6e22e">Person_PhoneNumber&lt;/span>{
{&lt;span style="color:#a6e22e">Number&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;555-4321&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">Type&lt;/span>: &lt;span style="color:#a6e22e">pb&lt;/span>.&lt;span style="color:#a6e22e">Person_HOME&lt;/span>},
},
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="写消息">写消息&lt;/h2>
&lt;p>使用proptocol buffers的目的是序列化你的数据，而后能够在任何地方解析。Go语言中，你可以使用&lt;code>proto&lt;/code>库的&lt;a href="https://pkg.go.dev/google.golang.org/protobuf/proto?tab=doc#Marshal">Marshal&lt;/a>方法序列化你的protocol buffer数据。protocol buffer消息的指针类型实现了&lt;code>proto.Message&lt;/code>接口。调用&lt;code>proto.Marshal&lt;/code>返回序列化后的编码成wire格式的protocol buffer数据。例如，我们在&lt;a href="https://github.com/protocolbuffers/protobuf/blob/master/examples/add_person.go">&lt;code>add_person&lt;/code> command&lt;/a>中使用了这个方法：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#a6e22e">book&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">pb&lt;/span>.&lt;span style="color:#a6e22e">AddressBook&lt;/span>{}
&lt;span style="color:#75715e">// ...
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">// Write the new address book back to disk.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">proto&lt;/span>.&lt;span style="color:#a6e22e">Marshal&lt;/span>(&lt;span style="color:#a6e22e">book&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#a6e22e">log&lt;/span>.&lt;span style="color:#a6e22e">Fatalln&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Failed to encode address book:&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
}
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">ioutil&lt;/span>.&lt;span style="color:#a6e22e">WriteFile&lt;/span>(&lt;span style="color:#a6e22e">fname&lt;/span>, &lt;span style="color:#a6e22e">out&lt;/span>, &lt;span style="color:#ae81ff">0644&lt;/span>); &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#a6e22e">log&lt;/span>.&lt;span style="color:#a6e22e">Fatalln&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Failed to write address book:&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="读数据">读数据&lt;/h2>
&lt;p>你可以使用&lt;code>proto&lt;/code>库中的&lt;a href="https://pkg.go.dev/google.golang.org/protobuf/proto?tab=doc#Unmarshal">Unmarshal&lt;/a>方法来解析编码过的数据。调用这个方法将&lt;code>buf&lt;/code>中的protocol buffer数据解析出来存放在&lt;code>pb&lt;/code>中。因此我们使用下面的代码在&lt;a href="https://github.com/protocolbuffers/protobuf/blob/master/examples/list_people.go">&lt;code>list_people&lt;/code> command&lt;/a>中进行解析：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#75715e">// Read the existing address book.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">in&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">ioutil&lt;/span>.&lt;span style="color:#a6e22e">ReadFile&lt;/span>(&lt;span style="color:#a6e22e">fname&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#a6e22e">log&lt;/span>.&lt;span style="color:#a6e22e">Fatalln&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Error reading file:&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
}
&lt;span style="color:#a6e22e">book&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">pb&lt;/span>.&lt;span style="color:#a6e22e">AddressBook&lt;/span>{}
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">proto&lt;/span>.&lt;span style="color:#a6e22e">Unmarshal&lt;/span>(&lt;span style="color:#a6e22e">in&lt;/span>, &lt;span style="color:#a6e22e">book&lt;/span>); &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#a6e22e">log&lt;/span>.&lt;span style="color:#a6e22e">Fatalln&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Failed to parse address book:&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="扩展protocol-buffer">扩展Protocol Buffer&lt;/h2>
&lt;p>在你使用protocol buffer的代码发布之后，或早或晚你总是希望改进你的protocol buffer定义。如果你希望你新的定义能向后兼容，且你的老的定义能向前兼容（你一定总是希望这样），那么你需要遵循一些规则。在新版本的protocol buffer中：&lt;/p>
&lt;ul>
&lt;li>你一定不能修改现在的字段的标签号码&lt;/li>
&lt;li>你可能会删除某些字段&lt;/li>
&lt;li>你可能会新增字段，但是新增的字段一定要使用全新的标签号码（一定是没有被使用过的，包括那些被删除的字段曾经使用过的）。&lt;/li>
&lt;/ul>
&lt;p>（使用这些规则有一些例外&lt;a href="https://developers.google.com/protocol-buffers/docs/proto3#updating">some exceptions&lt;/a>，但这些很少使用到）&lt;/p>
&lt;p>如果你遵循了这些规则，你会发现老代码也可以读取新的消息，只是会忽略新的字段。对于老代码，被删除的非数组字段会有它们的默认值，数组类型为空。新的代码可以透明的读取老的消息。&lt;/p>
&lt;p>需要注意的是，新的字段不会出现在老消息里，因此你需要添加合理的逻辑处理默认值&lt;a href="https://developers.google.com/protocol-buffers/docs/proto3#default">default value&lt;/a>。&lt;/p></description></item></channel></rss>