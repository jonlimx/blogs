<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Notes on Standing on the Shoulder of Giants</title><link>https://www.jonathanlin.top/categories/notes/</link><description>Recent content in Notes on Standing on the Shoulder of Giants</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © {year} Jonathan Lin. All rights reserved.</copyright><lastBuildDate>Wed, 08 Sep 2021 20:14:21 +0800</lastBuildDate><atom:link href="https://www.jonathanlin.top/categories/notes/index.xml" rel="self" type="application/rss+xml"/><item><title>C Primer Plus读书笔记（三）</title><link>https://www.jonathanlin.top/posts/c-primer-plus-notes-03/</link><pubDate>Wed, 08 Sep 2021 20:14:21 +0800</pubDate><guid>https://www.jonathanlin.top/posts/c-primer-plus-notes-03/</guid><description>
&lt;p>&lt;em>本文是《C Primer Plus》第九章至第十一章读书笔记，持续更新中。&lt;/em>&lt;/p>
&lt;h2 id="ch09-函数">ch09. 函数&lt;/h2>
&lt;blockquote>
&lt;ol>
&lt;li>函数原型、函数定义和函数调用&lt;/li>
&lt;li>函数的参数列表和返回值&lt;/li>
&lt;li>形参和实参&lt;/li>
&lt;li>函数类型&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>函数原型：任何程序在使用函数之前都要声明改函数的类型。&lt;strong>在函数调用前需要声明函数原型&lt;/strong>。函数原型是告诉编译器函数的类型。对于较小的函数，也可以把函数定义放在主调函数之前，这时候的函数定义也就是函数声明&lt;/p>
&lt;/li>
&lt;li>
&lt;p>函数定义：提供函数的实际代码&lt;/p>
&lt;/li>
&lt;li>
&lt;p>声明带有参数的函数时，可以只给定参数的类型而不需要提供参数的名字，比如：&lt;code>void show_n_char(char, int);&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>函数参数 - 主调函数通过参数将值传递给被调函数&lt;/p>
&lt;ul>
&lt;li>形式参数(formal argument) - 函数定义和声明中，参数列表里定义的参数&lt;/li>
&lt;li>实际参数(actual argument) - 具体的值，是主调函数赋值给形式参数的值，可以是常量、变量或者表达式。&lt;strong>在被调函数中使用的实际参数的值，是主调函数以拷贝的方式传递给被调函数，因此在被调函数中需值的修改不会影响原始数据&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>返回值 - 被调函数通过返回值将值传递给主调函数&lt;/p>
&lt;/li>
&lt;li>
&lt;p>函数类型，实际上是指函数的返回值类型&lt;/p>
&lt;/li>
&lt;li>
&lt;p>递归&lt;/p>
&lt;ul>
&lt;li>每一级递归函数里的变量都是私有的，即都属于对应层级的递归&lt;/li>
&lt;li>递归函数可能会快速消耗计算机内存，甚至耗尽。因此递归函数的层级受限于内存空间&lt;/li>
&lt;li>此外，递归本质是函数调用，由于递归引发的多次函数调用，对性能会有一定的影响&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>头文件 - 把函数原型和已定义的字符常量（#define)放在头文件中是一个良好的习惯，这样只需要在使用这些函数或者字符常量的地方通过#include引入头文件即可，避免了重复声明函数原型&lt;/p>
&lt;/li>
&lt;li>
&lt;p>指针&lt;/p>
&lt;ul>
&lt;li>是一个值为内存地址的变量，也称为指针变量&lt;/li>
&lt;li>取地址操作：&lt;code>ptr = &amp;amp;pooh&lt;/code>，将&lt;code>pooh&lt;/code>地址赋给指针变量&lt;code>ptr&lt;/code>&lt;/li>
&lt;li>取值操作/间接运算法操作/解引用操作：&lt;code>val = *ptr&lt;/code>。实际上&lt;code>ptr = &amp;amp;pooh; val = *ptr;&lt;/code> 等价于&lt;code>val = pooh&lt;/code>&lt;/li>
&lt;li>声明指针：&lt;code>int * pi; char * pc; float pf&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>函数参数的值传递和地址传递&lt;/p>
&lt;ul>
&lt;li>&lt;code>function(int num)&lt;/code> - 值传递，一般用于基于值进行计算&lt;/li>
&lt;li>&lt;code>function(int* num)&lt;/code> - 地址传递，一般用于在被调函数中修改主调函数的值&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>MongoDB学习笔记（二）</title><link>https://www.jonathanlin.top/posts/mongo-notes-02/</link><pubDate>Fri, 03 Sep 2021 15:03:57 +0800</pubDate><guid>https://www.jonathanlin.top/posts/mongo-notes-02/</guid><description/></item><item><title>Regex Cheatsheet</title><link>https://www.jonathanlin.top/posts/regex-cheatsheet/</link><pubDate>Thu, 02 Sep 2021 13:59:45 +0800</pubDate><guid>https://www.jonathanlin.top/posts/regex-cheatsheet/</guid><description>
&lt;h2 id="regular-expressions-cheat-sheet">Regular Expressions Cheat Sheet&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">符号&lt;/th>
&lt;th style="text-align:left">解释&lt;/th>
&lt;th>示例&lt;/th>
&lt;th>示例说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">.&lt;/td>
&lt;td style="text-align:left">匹配任意字符&lt;/td>
&lt;td>b.t&lt;/td>
&lt;td>可以匹配bat/but/b#t/b1t等&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">\w&lt;/td>
&lt;td style="text-align:left">匹配字母，数字和下划线&lt;/td>
&lt;td>b\wt&lt;/td>
&lt;td>可以匹配but/b1t/b_1，但不能匹配b#t&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">\s&lt;/td>
&lt;td style="text-align:left">匹配空白字符，包括\r，\n，\t&lt;/td>
&lt;td>love\syou&lt;/td>
&lt;td>匹配love you&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">\d&lt;/td>
&lt;td style="text-align:left">匹配数字&lt;/td>
&lt;td>\d\d&lt;/td>
&lt;td>可以匹配01，23等&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">\b&lt;/td>
&lt;td style="text-align:left">限定字符串边界&lt;/td>
&lt;td>\bThe\b&lt;/td>
&lt;td>匹配The这个单词，不能匹配There。也就是The的前面和后面只能是空格&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">^&lt;/td>
&lt;td style="text-align:left">根据字符串的开头部分匹配&lt;/td>
&lt;td>^The&lt;/td>
&lt;td>匹配以The开头的字符串&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">$&lt;/td>
&lt;td style="text-align:left">根据字符串的结束部分匹配&lt;/td>
&lt;td>.exe$&lt;/td>
&lt;td>匹配以.exe结尾的字符串&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">\W&lt;/td>
&lt;td style="text-align:left">匹配非字母，非数字和非下划线&lt;/td>
&lt;td>b\Wt&lt;/td>
&lt;td>可以匹配b#t，b@t等，但不能匹配but/b1t/b_1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">\S&lt;/td>
&lt;td style="text-align:left">匹配非空白字符&lt;/td>
&lt;td>love\Syou&lt;/td>
&lt;td>可以匹配love#you，但不能匹配love you&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">\D&lt;/td>
&lt;td style="text-align:left">匹配非数字&lt;/td>
&lt;td>\d\D&lt;/td>
&lt;td>可以匹配9$，3#等&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">\B&lt;/td>
&lt;td style="text-align:left">与\b相反，匹配的字符串不处于边界&lt;/td>
&lt;td>\Bio\B&lt;/td>
&lt;td>可以匹配biological，因为io的前后都不是空格&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">[]&lt;/td>
&lt;td style="text-align:left">匹配字符集（中括号内）里的任意单一字符&lt;/td>
&lt;td>[aeiou]&lt;/td>
&lt;td>匹配a，e，i，o，u这几个元音字符&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">[^]&lt;/td>
&lt;td style="text-align:left">匹配不在字符集（中括号内）里的任意单一字符&lt;/td>
&lt;td>[^aeiou]&lt;/td>
&lt;td>匹配除了a，e，i，o，u这几个原因字符以外的字符&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">*&lt;/td>
&lt;td style="text-align:left">匹配0次或者多次&lt;/td>
&lt;td>bee*&lt;/td>
&lt;td>匹配be，bee或者beeeeee等&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">+&lt;/td>
&lt;td style="text-align:left">匹配1次或者多次&lt;/td>
&lt;td>bee+&lt;/td>
&lt;td>匹配bee，beee或者beeeeee等&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">?&lt;/td>
&lt;td style="text-align:left">匹配0次或者1次&lt;/td>
&lt;td>bee?&lt;/td>
&lt;td>匹配be或者bee&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">{N}&lt;/td>
&lt;td style="text-align:left">匹配N次&lt;/td>
&lt;td>be{3}&lt;/td>
&lt;td>匹配beee&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">{M,}&lt;/td>
&lt;td style="text-align:left">至少匹配M次&lt;/td>
&lt;td>be{3,}&lt;/td>
&lt;td>匹配beee，beeeeeee等&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">{N,M}&lt;/td>
&lt;td style="text-align:left">匹配至少M次，至多N次&lt;/td>
&lt;td>be{3,5}&lt;/td>
&lt;td>匹配beee，beeee，beeeee&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">|&lt;/td>
&lt;td style="text-align:left">分支&lt;/td>
&lt;td>foo|bar&lt;/td>
&lt;td>匹配foo或者bar&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">(exp)&lt;/td>
&lt;td style="text-align:left">匹配exp并且捕获到自动命名的组中&lt;/td>
&lt;td>&lt;/td>
&lt;td>这里的重点是自动命名的组里，至于如何匹配完全取决于exp如何定义&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">(?&lt;name>exp)&lt;/td>
&lt;td style="text-align:left">匹配exp并且捕获到名为name的组中&lt;/td>
&lt;td>&lt;/td>
&lt;td>这里的重点是命名组，至于如何匹配完全取决于exp如何定义&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">(?:exp)&lt;/td>
&lt;td style="text-align:left">匹配exp但是不捕获匹配的文本&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">(?=exp)&lt;/td>
&lt;td style="text-align:left">对exp前面的文本进行匹配&lt;/td>
&lt;td>\b\w+(?=ing)&lt;/td>
&lt;td>匹配I'm reading中的read&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">(?&amp;lt;=exp)&lt;/td>
&lt;td style="text-align:left">对exp后面的文本进行匹配&lt;/td>
&lt;td>(?&amp;lt;=\bread)\w+\b&lt;/td>
&lt;td>匹配I'm reading中的ing&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">*？&lt;/td>
&lt;td style="text-align:left">重复任意次，但尽可能少重复&lt;/td>
&lt;td>b\w*?p&lt;/td>
&lt;td>bephellobeep会匹配出bep和beep。但是如果正则为b\w*p，那么匹配的结果是bephellobeep&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">+？&lt;/td>
&lt;td style="text-align:left">重复1次或者多次，但尽可能少重复&lt;/td>
&lt;td>&lt;/td>
&lt;td>原理同上&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">??&lt;/td>
&lt;td style="text-align:left">重复0次或者1次，但尽可能少重复&lt;/td>
&lt;td>&lt;/td>
&lt;td>原理同上&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">{M,N}?&lt;/td>
&lt;td style="text-align:left">重复M到N次，但尽可能少重复&lt;/td>
&lt;td>&lt;/td>
&lt;td>原理同上&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">{M,}?&lt;/td>
&lt;td style="text-align:left">重复M次以及以上，但尽可能少重复&lt;/td>
&lt;td>&lt;/td>
&lt;td>原理同上&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>MongoDB学习笔记（一）</title><link>https://www.jonathanlin.top/posts/mongo-notes-01/</link><pubDate>Thu, 05 Aug 2021 13:48:47 +0800</pubDate><guid>https://www.jonathanlin.top/posts/mongo-notes-01/</guid><description>
&lt;h2 id="安装mongodb">安装mongodb&lt;/h2>
&lt;p>我使用的是macOS bigsur，因此这里记录的是在mac下安装mongodb社区版。在mac下最便捷的安装方式就是使用&lt;code>brew&lt;/code>来安装，使用以下命令：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>添加官方tap&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="ln">1&lt;/span>brew tap mongodb/brew
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>安装mongo全家桶，包括社区版服务端，Shell和数据库相关工具&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="ln">1&lt;/span>brew install mongodb-community
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;p>安装完成后，对应的二进制文件和配置文件的位置如下：（Inter处理器）&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>文件&lt;/th>
&lt;th>位置&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>二进制可执行文件&lt;/td>
&lt;td>/usr/local/Cellar/mongodb-community/5.0.1/bin&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>配置文件&lt;/td>
&lt;td>/usr/local/etc/mongod.conf&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>日志文件&lt;/td>
&lt;td>/usr/local/var/log/mongodb&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>数据文件&lt;/td>
&lt;td>/usr/local/var/mongodb&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>MongoDB官方提供了以供学习用的示例数据集合，可以从https://atlas-education.s3.amazonaws.com/sampledata.archive下载，关于示例数据集的详细信息，可以参考：&lt;a href="https://www.mongodb.com/developer/article/atlas-sample-datasets/#std-label-atlas-sample-data-local-installation">The MongoDB Atlas Sample Datasets&lt;/a>。&lt;/p>
&lt;h2 id="以服务的方式启动停止mongodb">以服务的方式启动/停止mongodb&lt;/h2>
&lt;p>启动mongodb服务：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="ln">1&lt;/span>brew services start mongodb-community@5.0
&lt;/code>&lt;/pre>&lt;/div>&lt;p>服务启动后，可以通过&lt;code>mongo&lt;/code>命令连接并进入shell。&lt;/p>
&lt;p>停止mongodb服务：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="ln">1&lt;/span>brew services stop mongodb-community@5.0
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="mongodb查询操作">mongodb查询操作&lt;/h2>
&lt;p>这里介绍的关于mongodb的查询操作（&lt;strong>MQL&lt;/strong>）是通过&lt;code>mongosh&lt;/code>方法来实现的，这些方法底层是基于&lt;code>JavaScript&lt;/code>，但是如果你使用&lt;code>JavaScript&lt;/code>来连接那么你应该参考相应语言的包（&lt;a href="https://docs.mongodb.com/drivers/">idiomatic driver&lt;/a> ）。关于新增、删除和更新的方法相对来说比较简单，可以自行查看文档：&lt;a href="https://docs.mongodb.com/manual/reference/method/">mongosh Methods — MongoDB Manual&lt;/a>。这里重点记录一下查找方法的使用。&lt;/p>
&lt;h3 id="方法定义">方法定义&lt;/h3>
&lt;p>方法定义：&lt;code>db.collection.find(query, projection)&lt;/code>&lt;/p>
&lt;p>参数列表如下：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>参数&lt;/th>
&lt;th>参数类型&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>query&lt;/td>
&lt;td>document&lt;/td>
&lt;td>可选参数。使用&lt;a href="#%E6%9F%A5%E8%AF%A2%E9%80%89%E6%8B%A9%E5%99%A8">查询选择器&lt;/a>构建查询条件。如果你希望返回集合里的所有文档，那么忽略这个参数，或者传递一个空的文档(&lt;code>{}&lt;/code>)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>projecttion&lt;/td>
&lt;td>document&lt;/td>
&lt;td>可选参数。对查询结果进行筛选，选择性的返回指定的字段而不是包含文档里的所有字段。如果希望返回文档里的所有字段，则忽略该参数。关于更多细节，请参看：&lt;a href="#Projection(%E6%8A%95%E5%BD%B1)">Projection(投影)&lt;/a>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>构建query的时候，会涉及到字段或者嵌套字段。所谓嵌套字段是指子文档里的字段。指定嵌套的字段的方式有两种：&lt;/p>
&lt;ul>
&lt;li>点标记法：&lt;code>&amp;quot;field.nestedfield&amp;quot;: &amp;lt;value&amp;gt;&lt;/code>&lt;/li>
&lt;li>嵌套的方式：&lt;code>{ field: { nestedfield: &amp;lt;value&amp;gt; } }&lt;/code> （**注意：**这种方式和点标记法不一样，这种方式将匹配名称为&lt;code>filed&lt;/code>的子文档，子文档只包含一个名为&lt;code>nestedfield&lt;/code>的字段）&lt;/li>
&lt;/ul>
&lt;h3 id="查询选择器">查询选择器&lt;/h3>
&lt;p>这部分官网有很好的解释说明，详见：&lt;a href="https://docs.mongodb.com/manual/reference/operator/query/#query-selectors">Query and Projection Operators — MongoDB Manual&lt;/a>&lt;/p>
&lt;h4 id="比较">比较&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>数学运算符（SQL）&lt;/th>
&lt;th>MQL运算符&lt;/th>
&lt;th>语法说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>=&lt;/td>
&lt;td>$eq&lt;/td>
&lt;td>&lt;code>{ &amp;lt;field&amp;gt;: { $eq: &amp;lt;value&amp;gt; } }&lt;/code> 如果&lt;code>value&lt;/code>不是正则表达式，也可以写成&lt;code>{ field: &amp;lt;value&amp;gt; }&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;gt;&lt;/td>
&lt;td>$gt&lt;/td>
&lt;td>&lt;code>{field: {$gt: value} }&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;gt;=&lt;/td>
&lt;td>$gte&lt;/td>
&lt;td>&lt;code>{field: {$gte: value} }&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>in&lt;/td>
&lt;td>$in&lt;/td>
&lt;td>&lt;code>{ field: { $in: [&amp;lt;value1&amp;gt;, &amp;lt;value2&amp;gt;, ... &amp;lt;valueN&amp;gt; ] } }&lt;/code> 字段的值&lt;strong>在&lt;/strong>给定的数组里&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;lt;&lt;/td>
&lt;td>$lt&lt;/td>
&lt;td>&lt;code>{field: {$lt: value} }&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;lt;=&lt;/td>
&lt;td>$lte&lt;/td>
&lt;td>&lt;code>{ field: { $lte: value} }&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>!=&lt;/td>
&lt;td>$ne&lt;/td>
&lt;td>&lt;code>{field: {$ne: value} }&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>not in&lt;/td>
&lt;td>$nin&lt;/td>
&lt;td>&lt;code>{ field: { $nin: [ &amp;lt;value1&amp;gt;, &amp;lt;value2&amp;gt; ... &amp;lt;valueN&amp;gt; ]} }&lt;/code>字段的值&lt;strong>不在&lt;/strong>给定的数组里&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>***注意：***在进行比较的时候，比较操作符两边的数据需要是相同的BSON类型（&lt;a href="https://docs.mongodb.com/manual/reference/bson-type-comparison-order/#std-label-bson-types-comparison-order">Comparison/Sort Order — MongoDB Manual&lt;/a>）&lt;/p>
&lt;h4 id="逻辑运算">逻辑运算&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>MQL运算符&lt;/th>
&lt;th>语法说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>$and&lt;/td>
&lt;td>&lt;code>{ $and: [ { &amp;lt;expression1&amp;gt; }, { &amp;lt;expression2&amp;gt; } , ... , { &amp;lt;expressionN&amp;gt; } ] }&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$not&lt;/td>
&lt;td>&lt;code>{ field: { $not: { &amp;lt;operator-expression&amp;gt; } } }&lt;/code>注意&lt;code>{ $not: { $gt: 1.99 } }&lt;/code>和&lt;code>{ $lte: 1.99 }&lt;/code>不一样，&lt;strong>如果字段不存在，前者会匹配到，但是后者得存在才能匹配到&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$nor&lt;/td>
&lt;td>&lt;code>{ $nor: [ { &amp;lt;expression1&amp;gt; }, { &amp;lt;expression2&amp;gt; }, ... { &amp;lt;expressionN&amp;gt; } ] }&lt;/code>匹配表达式列列表都不满足情况，&lt;strong>如果表达式中涉及到的所有字段都不存在，也会匹配出来&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$or&lt;/td>
&lt;td>&lt;code>{ $or: [ { &amp;lt;expression1&amp;gt; }, { &amp;lt;expression2&amp;gt; }, ... , { &amp;lt;expressionN&amp;gt; } ] }&lt;/code>匹配表达式列表中的一个或者多个&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="元素element">元素（Element）&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>MQL运算符&lt;/th>
&lt;th>语法说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>$exists&lt;/td>
&lt;td>&lt;code>{ field: { $exists: &amp;lt;boolean&amp;gt; } }&lt;/code>匹配某个字段是否存在。如果值是&lt;code>true&lt;/code>那么会匹配到字段存在的或者值为&lt;code>null&lt;/code>的&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$type&lt;/td>
&lt;td>&lt;code>{ field: { $type: &amp;lt;BSON type&amp;gt; } }&lt;/code>或者&lt;code>{ field: { $type: [ &amp;lt;BSON type1&amp;gt; , &amp;lt;BSON type2&amp;gt;, ... ] } }&lt;/code>根据字段的类型匹配，可以匹配某种特定类型，或者几种类型中的一种。&lt;code>BSON&lt;/code>的支持的类型：&lt;a href="https://docs.mongodb.com/manual/reference/operator/query/type/#std-label-document-type-available-types">$type — MongoDB Manual&lt;/a>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="评估evaluation">评估（Evaluation）&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>MQL运算符&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>$expr&lt;/td>
&lt;td>在query中使用复杂表达式来查询文档 &lt;a href="https://docs.mongodb.com/manual/reference/operator/query/expr/">$expr — MongoDB Manual&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$jsonSchema&lt;/td>
&lt;td>校验文档的schema&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$mod&lt;/td>
&lt;td>取模运算&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$regex&lt;/td>
&lt;td>使用正则表达式来匹配 &lt;a href="https://docs.mongodb.com/manual/reference/operator/query/regex/">$regex — MongoDB Manual&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$text&lt;/td>
&lt;td>使用文本搜索来匹配字段，前提是这个字段上有text索引&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$where&lt;/td>
&lt;td>使用自定义的JS表达式或者方法进行匹配&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="projection投影">Projection(投影)&lt;/h3>
&lt;p>投影的目的是将query的结果按要求返回，比如需要返回哪些字段、返回几个符合条件的数组元素。&lt;strong>注意&lt;/strong>：&lt;/p>
&lt;ol>
&lt;li>包含或者排除，&lt;strong>这二者在投影里是互斥的&lt;/strong>。即指定了包含的字段，那么结果仅返回指定的字段，如果指定了排除的字段，那么返回的结果不包含被排除的字段&lt;/li>
&lt;li>&lt;code>_id&lt;/code>是特例，默认是包含在返回结果里，如果不希望结果里返回，是需要在投影里排除掉。&lt;code>_id&lt;/code>的排除是可以和其他字段的包含同时存在&lt;/li>
&lt;/ol>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Projection&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>&amp;lt;field&amp;gt;: &amp;lt;1 or true&amp;gt;&lt;/code>&lt;/td>
&lt;td>结果中包含某个字段。只要是非0的整型数字，都会被当成&lt;code>true&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>&amp;lt;field&amp;gt;: &amp;lt;0 or false&amp;gt;&lt;/code>&lt;/td>
&lt;td>结果中&lt;strong>排除&lt;/strong>某个字段&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>&amp;lt;field&amp;gt;: &amp;lt;aggregation expression&amp;gt;&lt;/code>&lt;/td>
&lt;td>&lt;em>TODO - 待补充&lt;/em>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>关于对于数组的投影，参考以下操作符：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>MQL运算符&lt;/th>
&lt;th>语法说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>$&lt;/td>
&lt;td>&lt;code>db.collection.find( { &amp;lt;array&amp;gt;: &amp;lt;condition&amp;gt; ... },{ &amp;quot;&amp;lt;array&amp;gt;.$&amp;quot;: 1 } )&lt;/code> &lt;code>db.collection.find( { &amp;lt;array.field&amp;gt;: &amp;lt;condition&amp;gt; ...}, { &amp;quot;&amp;lt;array&amp;gt;.$&amp;quot;: 1 } )&lt;/code> 查找条件是基于文档内部的数组元素，通过&lt;code>$&lt;/code>投影出符合条件的第一个数组元素&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$elemMatch&lt;/td>
&lt;td>与&lt;code>$&lt;/code>类似，投影出符合条件的第一个数组元素。&lt;code>$elemMatch&lt;/code>是在query的结果上，对数组元组的一个或者多个进行继续过滤：&lt;code>db.collection.find( { query, array: {$elemMatch: {condition ...}} ... }&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$meta&lt;/td>
&lt;td>获取文档相关的元数据，包括&lt;code>textScore&lt;/code>和&lt;code>indexKey&lt;/code>。&lt;code>textScore&lt;/code>和query中的&lt;code>text&lt;/code>一起使用，表示文档和query的匹配程度；&lt;code>indexKey&lt;/code>顾名思义获取文档对应的非text类型的索引键，主要用于调试目的（??）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$slice&lt;/td>
&lt;td>返回符合query条件的数组元素的切片。&lt;code>db.collection.find(&amp;lt;query&amp;gt;,{ &amp;lt;arrayField&amp;gt;: { $slice: &amp;lt;number&amp;gt; } });&lt;/code>或者&lt;code>db.collection.find(&amp;lt;query&amp;gt;,{ &amp;lt;arrayField&amp;gt;: { $slice: [ &amp;lt;number&amp;gt;, &amp;lt;number&amp;gt; ] } });&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="查询示例">查询示例&lt;/h2>
&lt;p>这个部分的数据来源是官方&lt;code>bios&lt;/code>数据集：&lt;a href="https://docs.mongodb.com/manual/reference/bios-example-collection/">The bios Example Collection — MongoDB Manual&lt;/a>&lt;/p>
&lt;p>&lt;strong>查询所有文档&lt;/strong>&lt;/p>
&lt;p>&lt;code>find()&lt;/code>方法的query部分不传值，或者传递一个空的文档，那么返回的接口就是所有文档。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="ln">1&lt;/span>db.bios.find&lt;span class="o">()&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>按照特定的值查询&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>查找&lt;code>_id&lt;/code>为5的文档：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="ln">1&lt;/span>db.bios.find&lt;span class="o">({&lt;/span>_id: 5&lt;span class="o">})&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>查找&lt;code>name&lt;/code>子文档里&lt;code>last&lt;/code>的值为&amp;quot;Hopper&amp;quot;的文档：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="ln">1&lt;/span>db.bios.find&lt;span class="o">({&lt;/span>&lt;span class="s2">&amp;#34;name.last&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;Hopper&amp;#34;&lt;/span>&lt;span class="o">})&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>使用&lt;a href="#%E6%9F%A5%E8%AF%A2%E9%80%89%E6%8B%A9%E5%99%A8%5D">查询选择器&lt;/a>&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>查找&lt;code>_id&lt;/code>的值等于5或者等于&lt;code>ObjectId(&amp;quot;51e062189c6ae665454e301d&amp;quot;)&lt;/code>的文档：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="ln">1&lt;/span>db.bios.find&lt;span class="o">({&lt;/span>_id: &lt;span class="o">{&lt;/span>&lt;span class="nv">$in&lt;/span>: &lt;span class="o">[&lt;/span>5, ObjectId&lt;span class="o">(&lt;/span>&lt;span class="s2">&amp;#34;51e062189c6ae665454e301d&amp;#34;&lt;/span>&lt;span class="o">)]}})&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>查找&lt;code>birth&lt;/code>在1950之后的文档：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="ln">1&lt;/span>db.bios.find&lt;span class="o">({&lt;/span>birth: &lt;span class="o">{&lt;/span>&lt;span class="nv">$gt&lt;/span>: new Date&lt;span class="o">(&lt;/span>&lt;span class="s2">&amp;#34;1950-01-01&amp;#34;&lt;/span>&lt;span class="o">)}})&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>使用正则表达式查找&lt;code>name&lt;/code>子文档下&lt;code>last&lt;/code>以N开头的文档：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="ln">1&lt;/span>db.bios.find&lt;span class="o">(&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="o">{&lt;/span> &lt;span class="s2">&amp;#34;name.last&amp;#34;&lt;/span>: &lt;span class="o">{&lt;/span> &lt;span class="nv">$regex&lt;/span>: /^N/ &lt;span class="o">}&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>&lt;code>$regex&lt;/code>的语法格式如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="ln">1&lt;/span>&lt;span class="o">{&lt;/span> &amp;lt;field&amp;gt;: &lt;span class="o">{&lt;/span> &lt;span class="nv">$regex&lt;/span>: /pattern/, &lt;span class="nv">$options&lt;/span>: &lt;span class="s1">&amp;#39;&amp;lt;options&amp;gt;&amp;#39;&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="o">{&lt;/span> &amp;lt;field&amp;gt;: &lt;span class="o">{&lt;/span> &lt;span class="nv">$regex&lt;/span>: &lt;span class="s1">&amp;#39;pattern&amp;#39;&lt;/span>, &lt;span class="nv">$options&lt;/span>: &lt;span class="s1">&amp;#39;&amp;lt;options&amp;gt;&amp;#39;&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="o">{&lt;/span> &amp;lt;field&amp;gt;: &lt;span class="o">{&lt;/span> &lt;span class="nv">$regex&lt;/span>: /pattern/&amp;lt;options&amp;gt; &lt;span class="o">}&lt;/span> &lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>按照值范围查询&lt;/strong>&lt;/p>
&lt;p>查找&lt;code>birth&lt;/code>在1940和1960之间的文档：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="ln">1&lt;/span>db.bios.find&lt;span class="o">({&lt;/span>birth: &lt;span class="o">{&lt;/span>&lt;span class="nv">$gt&lt;/span>: new Date&lt;span class="o">(&lt;/span>&lt;span class="s2">&amp;#34;1940-01-01&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>, &lt;span class="nv">$lt&lt;/span>: new Date&lt;span class="o">(&lt;/span>&lt;span class="s2">&amp;#34;1960-01-01&amp;#34;&lt;/span>&lt;span class="o">)}})&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>根据多个条件查询&lt;/strong>&lt;/p>
&lt;p>查找&lt;code>birth&lt;/code>在1920之后，且&lt;code>death&lt;/code>为false的文档：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="ln">1&lt;/span>db.bios.find&lt;span class="o">(&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">2&lt;/span> birth: &lt;span class="o">{&lt;/span> &lt;span class="nv">$gt&lt;/span>: new Date&lt;span class="o">(&lt;/span>&lt;span class="s1">&amp;#39;1920-01-01&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">}&lt;/span>,
&lt;span class="ln">3&lt;/span> death: &lt;span class="o">{&lt;/span> &lt;span class="nv">$exists&lt;/span>: &lt;span class="nb">false&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="o">}&lt;/span> &lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或者使用&lt;code>$and&lt;/code>操作符&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="ln">1&lt;/span>db.bios.find&lt;span class="o">({&lt;/span>&lt;span class="nv">$and&lt;/span>: &lt;span class="o">[&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="o">{&lt;/span>birth: &lt;span class="o">{&lt;/span>&lt;span class="nv">$gt&lt;/span>: new Date&lt;span class="o">(&lt;/span>&lt;span class="s2">&amp;#34;1920-01-01&amp;#34;&lt;/span>&lt;span class="o">)}}&lt;/span>,
&lt;span class="ln">3&lt;/span> &lt;span class="o">{&lt;/span>death: &lt;span class="o">{&lt;/span>&lt;span class="nv">$exists&lt;/span>: false&lt;span class="o">}}&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="o">]})&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>精确匹配子文档&lt;/strong>&lt;/p>
&lt;p>所谓精确匹配是指&lt;strong>要求子文档的字段的个数以及字段顺序与给定的查询条件中的子文档一致&lt;/strong>。下面的例子中，要求匹配&lt;code>name&lt;/code>子文档的&lt;code>first&lt;/code>为Yukihiro，&lt;code>last&lt;/code>为Matsumoto，文档中这两个字段的顺序也是要匹配上&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="ln">1&lt;/span>db.bios.find&lt;span class="o">(&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="o">{&lt;/span> name: &lt;span class="o">{&lt;/span> first: &lt;span class="s2">&amp;#34;Yukihiro&amp;#34;&lt;/span>, last: &lt;span class="s2">&amp;#34;Matsumoto&amp;#34;&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>下面的两种情况无法匹配成功：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="ln"> 1&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="err">first:&lt;/span> &lt;span class="nt">&amp;#34;Yukihiro&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="err">aka:&lt;/span> &lt;span class="nt">&amp;#34;Matz&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="err">last:&lt;/span> &lt;span class="nt">&amp;#34;Matsumoto&amp;#34;&lt;/span>
&lt;span class="ln"> 5&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="ln"> 6&lt;/span>
&lt;span class="ln"> 7&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="err">last:&lt;/span> &lt;span class="nt">&amp;#34;Matsumoto&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="err">first:&lt;/span> &lt;span class="nt">&amp;#34;Yukihiro&amp;#34;&lt;/span>
&lt;span class="ln">10&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>匹配子文档的字段&lt;/strong>&lt;/p>
&lt;p>使用点标记法匹配子文档字段。例如查找&lt;code>name&lt;/code>子文档下&lt;code>first&lt;/code>为Yukihiro以及&lt;code>last&lt;/code>为Matsumoto的文档&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="ln">1&lt;/span>db.bios.find&lt;span class="o">(&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">3&lt;/span> &lt;span class="s2">&amp;#34;name.first&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;Yukihiro&amp;#34;&lt;/span>,
&lt;span class="ln">4&lt;/span> &lt;span class="s2">&amp;#34;name.last&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;Matsumoto&amp;#34;&lt;/span>
&lt;span class="ln">5&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">6&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>根据数组元素(数组元素类型为简单类型)来查找&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>查找&lt;code>contribs&lt;/code>数组里含有&lt;code>UNIX&lt;/code>元素的文档：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="ln">1&lt;/span>db.bios.find&lt;span class="o">({&lt;/span>contribs: &lt;span class="s2">&amp;#34;UNIX&amp;#34;&lt;/span>&lt;span class="o">})&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>查找&lt;code>contribs&lt;/code>数组里含有&lt;code>ALGOL&lt;/code>或者&lt;code>Lisp&lt;/code>元素的文档：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="ln">1&lt;/span>db.bios.find&lt;span class="o">({&lt;/span>contribs: &lt;span class="o">{&lt;/span>&lt;span class="nv">$in&lt;/span>: &lt;span class="o">[&lt;/span>&lt;span class="s2">&amp;#34;ALGOL&amp;#34;&lt;/span>, &lt;span class="s2">&amp;#34;Lisp&amp;#34;&lt;/span>&lt;span class="o">]}})&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>查找&lt;code>contribs&lt;/code>数组里含有&lt;code>ALGOL&lt;/code>和&lt;code>Lisp&lt;/code>元素的文档：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="ln">1&lt;/span>db.bios.find&lt;span class="o">({&lt;/span>contribs: &lt;span class="o">{&lt;/span>&lt;span class="nv">$all&lt;/span>: &lt;span class="o">[&lt;/span>&lt;span class="s2">&amp;#34;ALGOL&amp;#34;&lt;/span>, &lt;span class="s2">&amp;#34;Lisp&amp;#34;&lt;/span>&lt;span class="o">]}})&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>查找&lt;code>contribs&lt;/code>数组大小为4的文档：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="ln">1&lt;/span>db.bios.find&lt;span class="o">({&lt;/span>contribs: &lt;span class="o">{&lt;/span>&lt;span class="nv">$size&lt;/span>: 4&lt;span class="o">}})&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>根据数组元素(数组元素类型为文档类型)来查找&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>查找&lt;code>awards&lt;/code>数组下的子文档中的&lt;code>award&lt;/code>的值为&lt;code>Turing Award&lt;/code>的文档：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="ln">1&lt;/span>db.bios.find&lt;span class="o">(&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="o">{&lt;/span> &lt;span class="s2">&amp;#34;awards.award&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;Turing Award&amp;#34;&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>查找&lt;code>awards&lt;/code>数组下的子文档中的&lt;code>award&lt;/code>的值为&lt;code>Turing Award&lt;/code>且&lt;code>year&lt;/code>(这里必须要在一个子文档里同时满足)大于1999的文档：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="ln">1&lt;/span>db.bios.find&lt;span class="o">(&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="o">{&lt;/span> awards: &lt;span class="o">{&lt;/span> &lt;span class="nv">$elemMatch&lt;/span>: &lt;span class="o">{&lt;/span> award: &lt;span class="s2">&amp;#34;Turing Award&amp;#34;&lt;/span>, year: &lt;span class="o">{&lt;/span> &lt;span class="nv">$gt&lt;/span>: &lt;span class="m">1980&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果这里不使用&lt;code>elemMatch&lt;/code>而是使用下面的方式，结果返回的是&lt;code>awards&lt;/code>元素里包含&lt;code>award&lt;/code>为”Turing Award“和&lt;code>year&lt;/code>大于1975的元素。这两个条件是要求&lt;code>awards&lt;/code>下的所有元素里，满足这两个条件之一即可。这两个条件是限制在&lt;code>awards&lt;/code>上，不是限制在单一的数组元素上。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="ln">1&lt;/span>db.bios.find&lt;span class="o">(&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">3&lt;/span> &lt;span class="s2">&amp;#34;awards.award&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;Turing Award&amp;#34;&lt;/span> ,
&lt;span class="ln">4&lt;/span> &lt;span class="s2">&amp;#34;awards.year&amp;#34;&lt;/span>: &lt;span class="o">{&lt;/span>&lt;span class="nv">$gt&lt;/span>: 1975&lt;span class="o">}&lt;/span>
&lt;span class="ln">5&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">6&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="投影示例">投影示例&lt;/h2>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>指定要包含的字段&lt;/strong>&lt;/p>
&lt;p>查找&lt;code>bios&lt;/code>集合里所有文档并返回文档的&lt;code>name&lt;/code>和&lt;code>contribs&lt;/code>字段：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="ln">1&lt;/span>db.bios.find&lt;span class="o">(&lt;/span> &lt;span class="o">{&lt;/span> &lt;span class="o">}&lt;/span>, &lt;span class="o">{&lt;/span> name: 1, contribs: &lt;span class="m">1&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>指定要排除的字段&lt;/strong>&lt;/p>
&lt;p>查找&lt;code>bios&lt;/code>集合里&lt;code>contribs&lt;/code>为OOP的集合，返回的时候排除掉&lt;code>name.first&lt;/code>和&lt;code>birth&lt;/code>字段：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="ln">1&lt;/span>db.bios.find&lt;span class="o">(&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="o">{&lt;/span> contribs: &lt;span class="s1">&amp;#39;OOP&amp;#39;&lt;/span> &lt;span class="o">}&lt;/span>,
&lt;span class="ln">3&lt;/span> &lt;span class="o">{&lt;/span> &lt;span class="s1">&amp;#39;name.first&amp;#39;&lt;/span>: 0, birth: &lt;span class="m">0&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>显式排除&lt;code>_id&lt;/code>字段&lt;/strong>&lt;/p>
&lt;p>查找&lt;code>bios&lt;/code>集合里所有文档并返回文档的&lt;code>name&lt;/code>和&lt;code>contribs&lt;/code>字段但不包括&lt;code>_id&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="ln">1&lt;/span>db.bios.find&lt;span class="o">(&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="o">{&lt;/span> &lt;span class="o">}&lt;/span>,
&lt;span class="ln">3&lt;/span> &lt;span class="o">{&lt;/span> name: 1, contribs: 1, _id: &lt;span class="m">0&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>对子文档和数组投影&lt;/strong>&lt;/p>
&lt;p>查找&lt;code>bios&lt;/code>集合里的所有文档并返回&lt;code>name.last&lt;/code>，以及&lt;code>contribs&lt;/code>数组里的前两个元素&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="ln">1&lt;/span>db.bios.find&lt;span class="o">(&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="o">{}&lt;/span>,
&lt;span class="ln">3&lt;/span> &lt;span class="o">{&lt;/span>_id: 0, &lt;span class="s1">&amp;#39;name.last&amp;#39;&lt;/span>: 1, contribs: &lt;span class="o">{&lt;/span>&lt;span class="nv">$slice&lt;/span>: 2&lt;span class="o">}}&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>C Primer Plus 编程练习</title><link>https://www.jonathanlin.top/posts/c-primer-plus-handson/</link><pubDate>Fri, 23 Jul 2021 23:35:03 +0800</pubDate><guid>https://www.jonathanlin.top/posts/c-primer-plus-handson/</guid><description>
&lt;h2 id="ch06-c控制语句循环">ch06. C控制语句：循环&lt;/h2>
&lt;blockquote>
&lt;ol start="5">
&lt;li>
&lt;p>编写一个程序，提示用户输入大写字母。使用嵌套循环以下面金字塔型的格式打印字母：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="ln">1&lt;/span> &lt;span class="n">A&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="n">ABA&lt;/span>
&lt;span class="ln">3&lt;/span> &lt;span class="n">ABCBA&lt;/span>
&lt;span class="ln">4&lt;/span> &lt;span class="n">ABCDCBA&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="n">ABCDEDCBA&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>提示：用外层循环处理行，每行使用3个内层循环，分别处理空格、以升序打印字母、以降序打印字母。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>思考：外层循环处理行容易实现，但是使用3个内层循环控制空格、升序字母和降序空格字母似乎有点多。这里可以结合条件判断，是的内层只需要一个循环搞定空格、升降序字母的打印。这里有几点比较关键&lt;/p>
&lt;ul>
&lt;li>每行有多少个空格&lt;/li>
&lt;li>每个一共要打印的字符是多少个，是包括每行的空格加上字符&lt;/li>
&lt;li>每行都是对称的，要找到每行对称中心的字符&lt;/li>
&lt;li>每行的空格数、字符数和对称中心的字符都是不一样的，这个要内循环中处理好&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="ln"> 1&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;#34;stdio.h&amp;#34;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="ln"> 3&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">middle&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">start&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="sc">&amp;#39;A&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Please input a char (A - Z):&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="n">scanf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%c&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">middle&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">middle&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="sc">&amp;#39;A&amp;#39;&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">middle&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="sc">&amp;#39;Z&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">lines&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">middle&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">start&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 总的行数
&lt;/span>&lt;span class="ln">12&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">spaces&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">chars&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 定义变量保存内循环里的空格数以及自字符。字符数实际上是等差数列 - 1，3，5，7...
&lt;/span>&lt;span class="ln">13&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">lines&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="n">spaces&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">lines&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 计算每行的空格数
&lt;/span>&lt;span class="ln">16&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="n">chars&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 计算每行的字符数
&lt;/span>&lt;span class="ln">18&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">asc_start&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">start&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 每行升序部分的起始字符
&lt;/span>&lt;span class="ln">19&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">middle_of_line&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">middle&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">spaces&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 每行的对称中心的字符
&lt;/span>&lt;span class="ln">20&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">desc_start&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">middle_of_line&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 每行的降序部分起始字符
&lt;/span>&lt;span class="ln">21&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">spaces&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">chars&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">22&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">23&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">spaces&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">24&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34; &amp;#34;&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 打印空格
&lt;/span>&lt;span class="ln">25&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">else&lt;/span>
&lt;span class="ln">26&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">27&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">asc_start&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">middle_of_line&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">28&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%c&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">asc_start&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 打印升序部分
&lt;/span>&lt;span class="ln">29&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">else&lt;/span>
&lt;span class="ln">30&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%c&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="n">desc_start&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 打印降序部分
&lt;/span>&lt;span class="ln">31&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">32&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">33&lt;/span>
&lt;span class="ln">34&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln">35&lt;/span>
&lt;span class="ln">36&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">37&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">38&lt;/span> &lt;span class="k">else&lt;/span>
&lt;span class="ln">39&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">40&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Your input is invalid!&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln">41&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">42&lt;/span>
&lt;span class="ln">43&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">44&lt;/span>
&lt;span class="ln">45&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="ln">46&lt;/span>
&lt;span class="ln">47&lt;/span>&lt;span class="c1">// 结果输出
&lt;/span>&lt;span class="ln">48&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">Please&lt;/span> &lt;span class="n">input&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">A&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">Z&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="n">G&lt;/span>
&lt;span class="ln">49&lt;/span> &lt;span class="n">A&lt;/span>
&lt;span class="ln">50&lt;/span> &lt;span class="n">ABA&lt;/span>
&lt;span class="ln">51&lt;/span> &lt;span class="n">ABCBA&lt;/span>
&lt;span class="ln">52&lt;/span> &lt;span class="n">ABCDCBA&lt;/span>
&lt;span class="ln">53&lt;/span> &lt;span class="n">ABCDEDCBA&lt;/span>
&lt;span class="ln">54&lt;/span> &lt;span class="n">ABCDEFEDCBA&lt;/span>
&lt;span class="ln">55&lt;/span>&lt;span class="n">ABCDEFGFEDCBA&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;ol start="7">
&lt;li>编写一个程序把一个单词读入一个字符数组中，然后倒序打印这个单词。提示：&lt;code>strlen()&lt;/code>函数。&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>思考：&lt;/p>
&lt;ul>
&lt;li>&lt;code>strlen()&lt;/code>和&lt;code>sizeof&lt;/code>的区别是 - &lt;code>strlen&lt;/code>输出的字符串的长度，即一个字符串里字符的个数（不包括）末尾的占位符；&lt;code>sizeof&lt;/code>输出的是字符数组的长度&lt;/li>
&lt;li>&lt;code>scanf&lt;/code>读入字符串的时候，遇到空格就停止读入了，也就是读入的只是空格前字符&lt;/li>
&lt;li>实际上，字符串是通过字符数组存放。如果输入的字符串长度超过的数组长度，那么也不会报错且存放的数据也都是正确的，本章和前面的章节还没给出答案，后面专门的字符串章节应该会介绍&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="ln"> 1&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;#34;stdio.h&amp;#34;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;#34;string.h&amp;#34;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 5&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">word&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Please input a word: &amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="n">scanf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%s&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">word&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;sizeof: %zd, string length: %ld&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">word&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">strlen&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">word&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="ln">10&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Magic - &amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">strlen&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">word&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%c&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">word&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln">17&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">19&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="ln">20&lt;/span>
&lt;span class="ln">21&lt;/span>&lt;span class="c1">// 结果输出
&lt;/span>&lt;span class="ln">22&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">Please&lt;/span> &lt;span class="n">input&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="nl">word&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">congratulation&lt;/span>
&lt;span class="ln">23&lt;/span>&lt;span class="k">sizeof&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">string&lt;/span> &lt;span class="nl">length&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">14&lt;/span>
&lt;span class="ln">24&lt;/span>&lt;span class="n">Magic&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">noitalutargnoc&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;ol start="11">
&lt;li>编写一个程序，在数组中读入8个整数，然后按照倒序打印这个8个整数&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>思考：这个考察的是通过循环从&lt;code>scanf&lt;/code>输入字符元素，输入的时候&lt;code>scanf&lt;/code>通过空格分隔。实际上&lt;code>scanf&lt;/code>遇到与期望的数据类型不一致的时候就停止输入，然后继续把不合格的类型的数据传递给下一次&lt;code>scanf&lt;/code>，这个要注意&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="ln"> 1&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;#34;stdio.h&amp;#34;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="cp">#define SIZE 8
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 5&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">SIZE&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Enter 8 numbers(int): &amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">SIZE&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="n">scanf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Numbers in reverse: &amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">SIZE&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d &amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">18&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="ln">19&lt;/span>
&lt;span class="ln">20&lt;/span>&lt;span class="c1">// 结果输出
&lt;/span>&lt;span class="ln">21&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">Enter&lt;/span> &lt;span class="mi">8&lt;/span> &lt;span class="n">numbers&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="mi">3&lt;/span> &lt;span class="mi">4&lt;/span> &lt;span class="mi">5&lt;/span> &lt;span class="mi">6&lt;/span> &lt;span class="mi">7&lt;/span> &lt;span class="mi">8&lt;/span>
&lt;span class="ln">22&lt;/span>&lt;span class="n">Numbers&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="nl">reverse&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">8&lt;/span> &lt;span class="mi">7&lt;/span> &lt;span class="mi">6&lt;/span> &lt;span class="mi">5&lt;/span> &lt;span class="mi">4&lt;/span> &lt;span class="mi">3&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">%&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="ch07-c控制语句分支和跳转">ch07. C控制语句：分支和跳转&lt;/h2>
&lt;blockquote>
&lt;ol>
&lt;li>编写一个程序读取输入，读到#字符停止，然后报告读取的空格数、换行符数和所有其他字符的数量&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>思考：&lt;/p>
&lt;ul>
&lt;li>可以使用&lt;code>getchar&lt;/code>或者&lt;code>scanf&lt;/code>来获取输入的字符&lt;/li>
&lt;li>可以使用&lt;code>switch...case...&lt;/code>或者&lt;code>if...else...&lt;/code>来判断字符&lt;/li>
&lt;li>&lt;code>ctype.h&lt;/code>中提供了一系列判断字符类型的函数，要加以利用。但是在&lt;code>switch...case..&lt;/code> 的&lt;code>case&lt;/code>语句中，不能使用函数判断字符类型，因为&lt;code>case&lt;/code>分支值必须是整型常量后者常量表达式&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="ln"> 1&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;#34;stdio.h&amp;#34;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="ln"> 3&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Input # to end...&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">spaces&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">returns&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">others&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="n">spaces&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">returns&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">others&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">ch&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">ch&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">getchar&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="sc">&amp;#39;#&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="k">switch&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">ch&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="k">case&lt;/span> &lt;span class="sc">&amp;#39; &amp;#39;&lt;/span>&lt;span class="o">:&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">spaces&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="k">case&lt;/span> &lt;span class="sc">&amp;#39;\n&amp;#39;&lt;/span>&lt;span class="o">:&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">returns&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">19&lt;/span> &lt;span class="k">default&lt;/span>&lt;span class="o">:&lt;/span>
&lt;span class="ln">20&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">others&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">21&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">22&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">23&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;char counts:&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">spaces : %d&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">returns: %d&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">others: %d&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">spaces&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">returns&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">others&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln">24&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;ol start="6">
&lt;li>编写程序读取输入，读到#停止，报告ei出现的次数&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>思考：&lt;/p>
&lt;ol>
&lt;li>需要记录上一次和当前的字符，当上次字符是&lt;code>e&lt;/code>且当前字符是&lt;code>i&lt;/code>的时候，计数器加1&lt;/li>
&lt;li>需要使用逻辑与运算&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="ln"> 1&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;#34;stdio.h&amp;#34;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="cp">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 3&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">current&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">previous&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="sc">&amp;#39; &amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">repeat&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Input # to end...&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln"> 7&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">current&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">getchar&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="sc">&amp;#39;#&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">previous&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="sc">&amp;#39;e&amp;#39;&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">current&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="sc">&amp;#39;i&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">repeat&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="n">previous&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">current&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;ei counts: %d&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">repeat&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln">15&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;ol start="7">
&lt;li>
&lt;p>编写一个程序，提示用户输入一周工作的小时数，然后打印工资总额、税金和净收入。做如下假设：&lt;/p>
&lt;p>a. 基本工资 = 10.00美元/小时&lt;/p>
&lt;p>b. 加班（超过40小时）= 1.5倍的时间&lt;/p>
&lt;p>c. 税率： 前300美元为15%&lt;/p>
&lt;p>​ 续150美元为20%&lt;/p>
&lt;p>​ 余下的为25%&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="ln"> 1&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;#34;stdio.h&amp;#34;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="cp">#define BASIC_SALARY 10.00
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="cp">#define RATE_300 0.15
&lt;/span>&lt;span class="ln"> 4&lt;/span>&lt;span class="cp">#define RATE_450 0.2
&lt;/span>&lt;span class="ln"> 5&lt;/span>&lt;span class="cp">#define RATE_OVER_450 0.25
&lt;/span>&lt;span class="ln"> 6&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="ln"> 7&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 8&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="kt">double&lt;/span> &lt;span class="n">working_hours&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Please input your working hours: &amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">scanf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%lf&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">working_hours&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Bad input, please try again!&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">getchar&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="sc">&amp;#39;\n&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 过滤掉不符合要求的字符，否则不符合规则字符会一直传递给scanf导致死循环
&lt;/span>&lt;span class="ln">15&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">continue&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Please input your working hours: &amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">18&lt;/span>
&lt;span class="ln">19&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">working_hours&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">40&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">20&lt;/span> &lt;span class="n">working_hours&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">40&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mf">1.5&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">working_hours&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">40&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln">21&lt;/span>
&lt;span class="ln">22&lt;/span> &lt;span class="kt">double&lt;/span> &lt;span class="n">total_salary&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">working_hours&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">BASIC_SALARY&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">23&lt;/span> &lt;span class="kt">double&lt;/span> &lt;span class="n">tax&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">24&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">total_salary&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">450&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">25&lt;/span> &lt;span class="n">tax&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">300&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">RATE_300&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">150&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">RATE_450&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">total_salary&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">450&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">RATE_OVER_450&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">26&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">total_salary&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">300&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">27&lt;/span> &lt;span class="n">tax&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">300&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">RATE_300&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">total_salary&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">300&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">RATE_OVER_450&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">28&lt;/span> &lt;span class="k">else&lt;/span>
&lt;span class="ln">29&lt;/span> &lt;span class="n">tax&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">total_salary&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">RATE_300&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">30&lt;/span>
&lt;span class="ln">31&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Total Salary: %4.2lf&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">Tax: %4.2lf&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">Net Salary: %4.2lf&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">total_salary&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">total_salary&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">tax&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln">32&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="ch08-字符输入输出和输入验证">ch08. 字符输入/输出和输入验证&lt;/h2>
&lt;blockquote>
&lt;ol start="4">
&lt;li>编写一个程序，在遇到EOF之前，把输入作为字符流读取。该程序要报告每个单词的字母数，不要把空白和标点统计为单词的字母&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="ln"> 1&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;#34;stdio.h&amp;#34;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;#34;ctype.h&amp;#34;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="ln"> 5&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">ch&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">chCount&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">width&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">ch&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">getchar&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">EOF&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">ispunct&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ch&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="k">continue&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">ch&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="sc">&amp;#39; &amp;#39;&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">ch&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="sc">&amp;#39;\t&amp;#39;&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">ch&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="sc">&amp;#39;\n&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="n">putchar&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ch&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="n">chCount&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="k">else&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">19&lt;/span> &lt;span class="n">width&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">10&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">chCount&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">20&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%*d&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">width&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">chCount&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln">21&lt;/span> &lt;span class="n">chCount&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">22&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">23&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">24&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">25&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>C Primer Plus读书笔记（二）</title><link>https://www.jonathanlin.top/posts/c-primer-plus-notes-02/</link><pubDate>Mon, 19 Jul 2021 21:24:20 +0800</pubDate><guid>https://www.jonathanlin.top/posts/c-primer-plus-notes-02/</guid><description>
&lt;p>&lt;em>本文是《C Primer Plus》第六章至第八章读书笔记，持续更新中。&lt;/em>&lt;/p>
&lt;h2 id="ch06-c控制语句循环">ch06. C控制语句：循环&lt;/h2>
&lt;blockquote>
&lt;ol>
&lt;li>C语言支持哪些循环控制关键字&lt;/li>
&lt;li>循环体中（里）变量的作用域&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>可以通过&lt;code>scanf&lt;/code>函数控制循环 - 如果输入数据无法转换成指定类型的时候，&lt;code>scanf&lt;/code>函数返回0&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>while&lt;/code>循环部分要点：&lt;strong>只有测试条件之后的单独语句（简单或者符合语句）才是循环部分&lt;/strong> （一般编程习惯好的都不会出现这种情况，但是也得了解如果出现这种情况到底是因为什么。现代高级的IDE都会有相应的提醒）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="ln">1&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">3&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;n is %d&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln">4&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 这里的n++已经不是循环体的一部分了，这个程序会陷入死循环
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="ln">1&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="o">++&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 这里的分号是一个完整的语句了，一个空语句，只有这个空语句是while的循环体，因此这个程序只会打印 - n is 4
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;n is %d&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>关系表达式 - 浮点数比较时尽量只使用&lt;code>&amp;gt;&lt;/code>和&lt;code>&amp;lt;&lt;/code>，因为浮点数的舍入误差会导致逻辑上应该相等的两个数不相等&lt;/p>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>TIP - 在构建是否相等的关系表示式的时候，可以如果是比价是否和一个常量相等，这时候可以把常量放左边，这可以避免误把赋值操作当做了比较操作&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="ln">1&lt;/span>&lt;span class="mi">5&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">canoes&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 语法错误，编译器不允许这么做
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">5&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">canose&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>C语言中，数值可以作为测试表达式（真值），但是C语言的真值的逻辑是：&lt;strong>所有非0都视为真，只有0被视为假&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="ln"> 1&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln"> 2&lt;/span>&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%2d is true. | &amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%2d is false.&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln"> 5&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln"> 6&lt;/span>&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%2d is true. | &amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln"> 8&lt;/span>&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%2d is false.&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln"> 9&lt;/span>
&lt;span class="ln">10&lt;/span>&lt;span class="c1">// Output:
&lt;/span>&lt;span class="ln">11&lt;/span>&lt;span class="c1">// 3 is true. | 2 is true. | 1 is true. | 0 is false.
&lt;/span>&lt;span class="ln">12&lt;/span>&lt;span class="c1">// -3 is true. | -2 is true. | -1 is true. | 0 is false.
&lt;/span>&lt;span class="ln">13&lt;/span>&lt;span class="c1">&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>C99之前，用&lt;code>int&lt;/code>表示真/假值。C99之后引入了&lt;code>_Bool&lt;/code>类型，该类型只能存储1（真）或0（假）。如果把非0的数值赋值给&lt;code>_Bool&lt;/code>类型变量，改变量自动被设置成1&lt;/p>
&lt;/li>
&lt;li>
&lt;p>**关系运算符优先级：**关系运算符的优先级比算术运算符（包括+和-）&lt;strong>低&lt;/strong>，&lt;strong>比赋值运算符高&lt;/strong> (优先级：&lt;a href="https://www.jonathanlin.top/posts/c-primer-plus-notes-01/#ch05%E8%BF%90%E7%AE%97%E7%AC%A6%E8%A1%A8%E8%BE%BE%E7%AC%A6%E5%92%8C%E8%AF%AD%E5%8F%A5">C Primer Plus读书笔记（一） | Standing on the Shoulder of Giants (jonathanlin.top)&lt;/a>)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="ch07-c控制语句分支和跳转">ch07. C控制语句：分支和跳转&lt;/h2>
&lt;blockquote>
&lt;ol>
&lt;li>支持分支、跳转的关键字有哪些&lt;/li>
&lt;li>字符I/O函数&lt;code>getchar&lt;/code>和&lt;code>putchar&lt;/code>有什么特别之处&lt;/li>
&lt;li>&lt;code>goto&lt;/code>语句是否应该使用，应该注意哪些事项&lt;/li>
&lt;li>&lt;code>if...else&lt;/code>的配对问题&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>&lt;code>ch = getchar()&lt;/code> - 与&lt;code>scanf(&amp;quot;%c&amp;quot;, &amp;amp;ch)&lt;/code>类似，读取下一个字符赋值给变量&lt;code>ch&lt;/code>&lt;/p>
&lt;ul>
&lt;li>&lt;code>getchar&lt;/code> - 读取每个字符，包括空格、制表符和换行符&lt;/li>
&lt;li>&lt;code>scanf&lt;/code> - 读取数字时会跳过空格、制表符和换行符&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>putchar(ch)&lt;/code> - 与&lt;code>printf(&amp;quot;%c&amp;quot;, ch)&lt;/code>类似，打印一个字符&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>ctype.h&lt;/code>系列字符函数 - 接受一个字符作为输入，如果该字符属于某个特殊的类型，则返回一个非零值（&lt;code>True&lt;/code>），否则返回零值（&lt;code>False&lt;/code>)。这些函数可以判断是否为字母、数字、空白字符等&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;em>&lt;strong>C编译器是忽略缩进的&lt;/strong>&lt;/em>，当出现多个&lt;code>if...else&lt;/code>的时候，一定要注意它们之间的配对。配对的原则是：&lt;em>&lt;strong>如果没有花括号，&lt;code>else&lt;/code>和离它最近的&lt;code>if&lt;/code>配对&lt;/strong>&lt;/em>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>逻辑表达式（有逻辑运算符&lt;code>&amp;amp;&amp;amp; || !&lt;/code>参与的表达式）的求值顺序是从左往右，&lt;em>一旦发现有使整个表达式为假的因素&lt;/em>，立即停止求值&lt;/p>
&lt;/li>
&lt;li>
&lt;p>范围测试，例如判断&lt;code>score&lt;/code>是否在90和100之间&lt;/p>
&lt;ul>
&lt;li>&lt;code>score &amp;gt;= 90 &amp;amp;&amp;amp; score&amp;lt;=100&lt;/code> ✔️&lt;/li>
&lt;li>&lt;code>90 &amp;lt;= score &amp;lt;= 100&lt;/code> ❌ 由于&lt;code>&amp;lt;=&lt;/code>的求值顺序是从左到右，因此这里会先计算&lt;code>90 &amp;lt;= score&lt;/code>，而整个关系表达值的值要么是0（False）要么是1（True），都是小于100，因此整个表达式的结果是&lt;code>True&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>条件运算符&lt;code>?:&lt;/code> - &lt;code>expression1 ? expression2: expression3&lt;/code>&lt;/p>
&lt;ul>
&lt;li>如果&lt;code>expression1&lt;/code>的值为&lt;code>True&lt;/code>，那么整个表达式的值为&lt;code>expression2&lt;/code>&lt;/li>
&lt;li>如果&lt;code>expression1&lt;/code>的值为&lt;code>False&lt;/code>，那么整个表达式的值为&lt;code>expression3&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>switch...case...&lt;/code>&lt;/p>
&lt;ul>
&lt;li>&lt;code>switch&lt;/code>括号表达式中的值应该是一个整数值（包括&lt;code>char&lt;/code>）&lt;/li>
&lt;li>&lt;code>case&lt;/code>标签必须是整数类型（包括&lt;code>char&lt;/code>)的常量或者整数型常量表达式&lt;/li>
&lt;li>不能用变量作为&lt;code>case&lt;/code>标签&lt;/li>
&lt;li>如果没有添加&lt;code>break&lt;/code>，那么匹配到某个标签以及之后所有的&lt;code>case&lt;/code>都会匹配上&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="ln"> 1&lt;/span>&lt;span class="k">switch&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="err">整型表达式&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 2&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="k">case&lt;/span> &lt;span class="err">常量&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="o">:&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="err">语句&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="k">case&lt;/span> &lt;span class="err">常量&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="o">:&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="err">语句&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="k">default&lt;/span>&lt;span class="o">:&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="err">语句&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">12&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>尽量避免或者不使用&lt;code>goto&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="ln">1&lt;/span>&lt;span class="k">goto&lt;/span> &lt;span class="n">label&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="p">...&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="nl">label&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">statement&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="ch08-字符输入输出和输入验证">ch08. 字符输入/输出和输入验证&lt;/h2>
&lt;blockquote>
&lt;ol>
&lt;li>输入和输出跟缓冲区有什么关系？&lt;/li>
&lt;li>有缓冲和无缓冲有什么区别？&lt;/li>
&lt;li>是否可以手动刷新输入输出缓冲区？&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>无缓冲区：当用户输入字符后立即重复打印该字符，这是无缓冲区&lt;/p>
&lt;/li>
&lt;li>
&lt;p>有缓冲区：用户输入的字符被收集保存在一个被称为&lt;code>缓冲区(buffer)&lt;/code>的临时存储区，按下Enter后打印，这是有缓冲区&lt;/p>
&lt;/li>
&lt;li>
&lt;p>缓冲类型：&lt;/p>
&lt;ul>
&lt;li>完全缓冲I/O：当缓冲区满的时候才刷新缓冲区&lt;/li>
&lt;li>行缓冲I/O：出现换行符时刷新缓冲区&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>文件和流&lt;/p>
&lt;ul>
&lt;li>文件：&lt;strong>存储器中存储信息的区域，不同的操作系统存储信息方式不同，因此文件的底层表示形式也不一样。有的分块有的不分块，有的块大有的块小&lt;/strong>&lt;/li>
&lt;li>流：C程序处理的是流，而不是文件。流或者说数据流是对输入输出的映射，换句话说，输入转换成数据流，数据流映射到文件，输出也是类似，文件映射成数据流。这样上层就忽略了底层因为操作系统不同带来的差异&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>文件结尾EOF&lt;/p>
&lt;ul>
&lt;li>可以用处理文件的方式来处理键盘输入（原因是C语言处理的都是流）&lt;/li>
&lt;li>以往判断文件结尾的一种方式是，&lt;strong>在文件末尾放一个特殊字符ctrl+z标记文件结尾&lt;/strong>&lt;/li>
&lt;li>无论操作系统实际使用何种方法检测文件结尾，C语言中检测到文件末尾的时候，会返回一个&lt;strong>特殊的值EOF&lt;/strong>（&lt;strong>注意，EOF是一个值，并不是一个字符&lt;/strong>）&lt;/li>
&lt;li>EOF的值不在&lt;code>char&lt;/code>的值表示的范围内&lt;/li>
&lt;li>在终端中，UNIX风格的操作系统通过&lt;code>ctrl+d&lt;/code>模拟EOF&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>stdin和stdout&lt;/p>
&lt;ul>
&lt;li>C语言上层处理的是&lt;strong>数据流&lt;/strong>，至于数据流的源头和目的地是哪，实际上对上层语言是透明的&lt;/li>
&lt;li>stdin - 程序从stdin获取到的数据流，数据的来源可能是键盘输入，也可能是来自文件，程序本身不知道源头，只知道处理的是数据流。stdin默认来源是键盘输入，可以通过重定向使得数据来源于文件&lt;/li>
&lt;li>stdout - 程序将数据流发送给stdout，数据流的去处对程序是透明的。数据流经由stdout，可能输出到显示设备，也可能保存到文件。默认是输出到显示设备&lt;/li>
&lt;li>&lt;code>&amp;lt;&lt;/code>和&lt;code>&amp;gt;&lt;/code>是重定向符号&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>C Primer Plus读书笔记（一）</title><link>https://www.jonathanlin.top/posts/c-primer-plus-notes-01/</link><pubDate>Mon, 05 Jul 2021 19:41:09 +0800</pubDate><guid>https://www.jonathanlin.top/posts/c-primer-plus-notes-01/</guid><description>
&lt;p>&lt;em>本文是《C Primer Plus》第三章至第五章读书笔记。&lt;/em>&lt;/p>
&lt;h2 id="ch03-数据和c">ch03. 数据和C&lt;/h2>
&lt;blockquote>
&lt;p>思考问题：&lt;/p>
&lt;ol>
&lt;li>各种类型的数据占用多少空间&lt;/li>
&lt;li>各种类型的数据是如何格式化输出的&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;ul>
&lt;li>一般而言，存储int需要占用一个机器字长&lt;/li>
&lt;li>C语言中的byte不是8个bit，而是和一个char占用的位长一样&lt;/li>
&lt;li>char根据编译器不同，可能被处理成有符号也可能被处理成无符号。具体可以查看头文件limits.h&lt;/li>
&lt;li>整数类型一般都被存储为int类型，当超过int最大范围，编译器会自动将其视为高一个等级的类型，直到越界&lt;/li>
&lt;li>2^16 = 65536 / 2^8 = 256&lt;/li>
&lt;li>浮点数的存储：有效数和指数部分（包括符号），3.16e^7，有效数部分就是3.16&lt;/li>
&lt;li>float至少能表示6位有效数字，double至少能表示10位有效数字&lt;/li>
&lt;li>表达式中，float会自动转化成double&lt;/li>
&lt;li>浮点数和整型数在计算机内部，虽然都是二进制表示，但是二进制的表示形式不一样，浮点数是把有效数字和指数部分分别表示。因此，在处理浮点数和整型的时候，计算机会做自动的转换，这个很危险&lt;/li>
&lt;/ul>
&lt;h2 id="ch04-字符串和格式化输入输出">ch04. 字符串和格式化输入/输出&lt;/h2>
&lt;blockquote>
&lt;p>思考问题：&lt;/p>
&lt;ol>
&lt;li>字符串是如何存取的&lt;/li>
&lt;li>字符串底层的数据结构是怎样的&lt;/li>
&lt;li>输入输出函数如何格式化&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>C语言中，没有专门的数据结构存放字符串。字符串是存放在char数组中，且数组的末尾是存放占位符'\0'，这个占位符是自动添加到数组末尾&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用scanf读取字符串的时候，&lt;strong>输入空格则停止读取&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用scanf读取字符串的时候，变量不需要通过&amp;amp;取地址（因为字符数组本身就是一个指针？？）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&amp;quot;x&amp;quot;和'x'的区别：前者是char数组，实际占用两个字符，后者是char类型，一个字符&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sizeof - 字节长度 / strlen - 字符串长度&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用sizeof计算字符串，会把结束字符（空字符'\0'）也算进去得到总共占用的字节数；而strlen计算字符串长度的时候，不会把末尾的结束字符计算进去&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sizeof结果返回size_t类型，一个无符号整型&lt;/p>
&lt;/li>
&lt;li>
&lt;p>limits.h和float.h中分别定义了各种类型的最大值和最小值，这个会由于操作系统以及其字长的不同而不同&lt;/p>
&lt;/li>
&lt;li>
&lt;p>#define NAME value - 使用预处理器定义了一个明示常量，通常用大写来命名；const定义的实际是变量，可读变量&lt;/p>
&lt;/li>
&lt;li>
&lt;p>printf&lt;em>&lt;strong>转换说明：把以二进制格式存储在计算机中的值转换成一系列字符串然后打印&lt;/strong>&lt;/em>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>转换如果和底层的数据类型不匹配会发生很奇怪的事情，如下代码：&lt;/p>
&lt;ol>
&lt;li>n1是float类型，但是在存储的时候会自动转换成double，因此占用8个字节，但是&lt;code>%ld&lt;/code>导致在转换说明的时候，只读取了前4个字节&lt;/li>
&lt;li>以上，导致每一次&lt;code>%ld&lt;/code>的转换都发生错位，四次的&lt;code>%ld&lt;/code>仅读取了16个字节，但是&lt;code>n1&lt;/code>到&lt;code>n4&lt;/code>一共占用了24个字节&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="ln">1&lt;/span>&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%ld %ld %ld %ld&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n4&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jonlimx/blogs/image/printf-incompatiable.png" alt="转换不匹配">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>格式化字符串转换说明 （关于转换说明符修饰符P71）&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>转换说明&lt;/th>
&lt;th>输出&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>%a %A&lt;/td>
&lt;td>浮点数、十六进制数和p记数法&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%c&lt;/td>
&lt;td>单个字符&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%d&lt;/td>
&lt;td>有符号十进制整数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%e %E&lt;/td>
&lt;td>浮点数，e&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%f&lt;/td>
&lt;td>浮点数，十进制记数法&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%g %G&lt;/td>
&lt;td>根据值的不同，自动选择%f或%e。%e格式用于指数小于-4或者大于或等于精度时&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%i&lt;/td>
&lt;td>有符号十进制整数（与%d相同）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%o&lt;/td>
&lt;td>无符号八进制整数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%p&lt;/td>
&lt;td>指针&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%s&lt;/td>
&lt;td>字符串&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%u&lt;/td>
&lt;td>无符号十进制整数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%x&lt;/td>
&lt;td>无符号十六进制整数，使用十六进制数0f&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%X&lt;/td>
&lt;td>无符号十六进制整数，使用十六进制数0F&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%%&lt;/td>
&lt;td>打印一个百分号&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%zd&lt;/td>
&lt;td>打印size_t类型&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;li>
&lt;p>scanf与printf正好相反，从键盘输入的都是字符串，scanf通过制定数据类型然后将字符串转换成对应的数据类型。注意：&lt;strong>除了字符串类型及char数组，其他所有的类型都要通过指针来接收值&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>scanf通过空格或者回车将输入分割成多个字段（%c是例外，也会把空字符作为输入存储）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>scanf的返回值是成功读取的项数（个数）&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>*修饰符&lt;/p>
&lt;ul>
&lt;li>
&lt;p>对于printf而言，*修饰符用于代替字段。如下面代码所示，*修饰符用与替换width和precision表示宽度和精度&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于scanf而言，把*放在%和转换字符之间，则会跳过相应的输入项。下面代码所示，scanf跳过了第一个和第二个输入，把第三个输入赋值给n&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="ln"> 1&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="n">width&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">precision&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">number&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">256&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="kt">double&lt;/span> &lt;span class="n">weight&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">242.5&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%*d&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">width&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">number&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%*.*f&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">width&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">precision&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">weight&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln"> 7&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="n">scanf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%*d %*d %d&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln">11&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">13&lt;/span>
&lt;span class="ln">14&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="ch05-运算符表达符和语句">ch05. 运算符、表达符和语句&lt;/h2>
&lt;blockquote>
&lt;p>思考问题：&lt;/p>
&lt;ol>
&lt;li>C语言中有哪些运算符和表达符，运算符的优先级是怎么样的&lt;/li>
&lt;li>C语言中有哪些特殊的语句&lt;/li>
&lt;li>自动类型转换和强制类型转换&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>赋值表达式的目的是把值存储到内存位置上&lt;/p>
&lt;/li>
&lt;li>
&lt;p>浮点数除法的结果是浮点数，整数除法的结果是整数（小数部分直接被截断，不会四舍五入 ），整数和浮点数的除法是浮点数&lt;/p>
&lt;/li>
&lt;li>
&lt;p>运算符优先级&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>运算符&lt;/th>
&lt;th>结合律 - 运算符符合与运算对象结合&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>（）&lt;/td>
&lt;td>从左到右&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>+ - （一元）++ -- sizeof ！&lt;/td>
&lt;td>从右到左&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>* / %&lt;/td>
&lt;td>从左到右&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>+ - （二元）&lt;/td>
&lt;td>从左到右&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;lt; &amp;gt; &amp;lt;= &amp;gt;=&lt;/td>
&lt;td>从左到右&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>== !=&lt;/td>
&lt;td>从左到右&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>=&lt;/td>
&lt;td>从右到左&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>上表结合律只适用于共享同一运算对象的运算符&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>6*3 + 4*5 - 可以肯定*优先级比+高，但是这例子中，6*3和4*5的运算先后顺序不确定，不同硬件平台可能顺序不一样（&lt;em>发生指令重排？？&lt;/em>）&lt;/li>
&lt;li>12/3*2 - 这个例子中，/和*的优先级一样，但是3是共享运算对象，因此遵循结合律从左到右，所以先算12/3，然后4*2&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>求模运算只能用于整数，不能用于浮点数&lt;/p>
&lt;/li>
&lt;li>
&lt;p>a%b &amp;lt;=&amp;gt; a - (a/b)*b&lt;/p>
&lt;/li>
&lt;li>
&lt;p>自增和自减运算符 ++/--&lt;/p>
&lt;ul>
&lt;li>前缀模式：&lt;strong>先完成自增或者自减&lt;/strong>，然后再用结果参与同一语句中的其他运算&lt;/li>
&lt;li>后缀模式：先完成同一语句的其他预算，&lt;strong>然后再完成自增或者自减&lt;/strong>&lt;/li>
&lt;li>如果只是单独使用，也就是不和其他运算对象以及运算符一起的时候，前缀和后缀模式都没有区别，就是要完成自增或者自减&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>下面两种情况不要使用自增后者自减（由于可能指令重排导致计算没有按预期的顺序进行）&lt;/p>
&lt;ul>
&lt;li>一个变量出现在一个函数的多个参数中，那么不要对该变量使用自增或者自减&lt;/li>
&lt;li>一个变量多次出现表达式中，那么不要对该变量使用自增或者自减 - ans = num/2 + 5*(1+num++)，&lt;em>这里可能因为指令重排导致num++先算，那么前面的num/2就和预期不一样了&lt;/em>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>序列点：程序执行的点，在一个语句中，赋值运算符、自增自减运算符对运算对象做的改变必须在程序执行下一条语句之前完成&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>自动类型转换（&lt;strong>通常应该要避免&lt;/strong>）：&lt;/p>
&lt;ul>
&lt;li>升级：较小类型转换成较大类型&lt;/li>
&lt;li>降级：较大类型转换成较小类型 - &lt;strong>这种情况可能会发生数据截断&lt;/strong>&lt;/li>
&lt;li>升级发生在表达式中运算对象数据类型不同，这时候发生自动自动类型转换。运算结束后，会根据目标类型可能会发生降级，这时候可能就会发生数据截断&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>强制类型转换：(type)variable&lt;/p>
&lt;/li>
&lt;li>
&lt;p>实参和形参&lt;/p>
&lt;ul>
&lt;li>实参 argument - 调用函数时传递给形参的实际的值&lt;/li>
&lt;li>形参 parameter - 函数签名上定义的变量&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>引用书中关于自动类型转换的一段：&lt;/p>
&lt;p>在C语言中，许多类型转换都是自动进行的。当&lt;code>char&lt;/code>和&lt;code>short&lt;/code>类型出现在表达式里或者作为函数的参数（函数原型除外）时，都会被升级为&lt;code>int&lt;/code>类型；当&lt;code>float&lt;/code>类型在函数参数中时，会被升级为&lt;code>double&lt;/code>类型&lt;/p>
&lt;p>当把一种值赋给另一种类型的变量时，值将被转换成与变量的类型相同&lt;/p>
&lt;p>当把较大类型转换成较小类型时，可能会丢失数据&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>函数声明 - 在调用函数的时候，编译器首先需要知道函数的返回类型，所以需要先声明函数，至于函数的实现可以放在后面&lt;/li>
&lt;/ul></description></item></channel></rss>