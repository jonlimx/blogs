<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Standing on the Shoulder of Giants</title><link>https://www.jonathanlin.top/</link><description>Recent content on Standing on the Shoulder of Giants</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © {year} Jonathan Lin. All rights reserved.</copyright><lastBuildDate>Mon, 05 Jul 2021 19:41:09 +0800</lastBuildDate><atom:link href="https://www.jonathanlin.top/index.xml" rel="self" type="application/rss+xml"/><item><title>C Primer Plus读书笔记</title><link>https://www.jonathanlin.top/posts/c-primer-plus-notes/</link><pubDate>Mon, 05 Jul 2021 19:41:09 +0800</pubDate><guid>https://www.jonathanlin.top/posts/c-primer-plus-notes/</guid><description>
&lt;p>&lt;em>本文是《C Primer Plus》读书笔记，持续更新中。&lt;/em>&lt;/p>
&lt;h2 id="ch03-数据和c">ch03. 数据和C&lt;/h2>
&lt;blockquote>
&lt;p>思考问题：&lt;/p>
&lt;ol>
&lt;li>各种类型的数据占用多少空间&lt;/li>
&lt;li>各种类型的数据是如何格式化输出的&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;ul>
&lt;li>一般而言，存储int需要占用一个机器字长&lt;/li>
&lt;li>C语言中的byte不是8个bit，而是和一个char占用的位长一样&lt;/li>
&lt;li>char根据编译器不同，可能被处理成有符号也可能被处理成无符号。具体可以查看头文件limits.h&lt;/li>
&lt;li>整数类型一般都被存储为int类型，当超过int最大范围，编译器会自动将其视为高一个等级的类型，直到越界&lt;/li>
&lt;li>2^16 = 65536 / 2^8 = 256&lt;/li>
&lt;li>浮点数的存储：有效数和指数部分（包括符号），3.16e^7，有效数部分就是3.16&lt;/li>
&lt;li>float至少能表示6位有效数字，double至少能表示10位有效数字&lt;/li>
&lt;li>表达式中，float会自动转化成double&lt;/li>
&lt;li>浮点数和整型数在计算机内部，虽然都是二进制表示，但是二进制的表示形式不一样，浮点数是把有效数字和指数部分分别表示。因此，在处理浮点数和整型的时候，计算机会做自动的转换，这个很危险&lt;/li>
&lt;/ul>
&lt;h2 id="ch04-字符串和格式化输入输出">ch04. 字符串和格式化输入/输出&lt;/h2>
&lt;blockquote>
&lt;p>思考问题：&lt;/p>
&lt;ol>
&lt;li>字符串是如何存取的&lt;/li>
&lt;li>字符串底层的数据结构是怎样的&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;ul>
&lt;li>C语言中，没有专门的数据结构存放字符串。字符串是存放在char数组中，且数组的末尾是存放占位符'\0'，这个占位符是自动添加到数组末尾&lt;/li>
&lt;li>使用scanf读取字符串的时候，输入空格则停止读取&lt;/li>
&lt;li>&amp;ldquo;x&amp;quot;和&amp;rsquo;x&amp;rsquo;的区别：前者是char数组，实际占用两个字符，后者是char类型，一个字符&lt;/li>
&lt;li>sizeof - 字节长度 / strlen - 字符串长度&lt;/li>
&lt;li>使用sizeof计算字符串，会把结束字符（空字符'\0'）也算进去得到总共占用的字节数；而strlen计算字符串长度的时候，不会把末尾的结束字符计算进去&lt;/li>
&lt;li>limits.h和float.h中分别定义了各种类型的最大值和最小值，这个会由于操作系统以及其字长的不同而不同&lt;/li>
&lt;li>#define NAME value - 使用预处理器定义了一个明示常量，通常用大写来命名；const定义的实际是变量，可读变量&lt;/li>
&lt;li>&lt;em>&lt;strong>转换说明：把以二进制格式存储在计算机中的值转换成一系列字符串然后打印&lt;/strong>&lt;/em>&lt;/li>
&lt;li>转换如果和底层的数据类型不匹配会发生很奇怪的事情，如下代码：
&lt;ol>
&lt;li>n1是float类型，但是在存储的时候会自动转换成double，因此占用8个字节，但是&lt;code>%ld&lt;/code>导致在转换说明的时候，只读取了前4个字节&lt;/li>
&lt;li>以上，导致每一次&lt;code>%ld&lt;/code>的转换都发生错位，四次的&lt;code>%ld&lt;/code>仅读取了16个字节，但是&lt;code>n1&lt;/code>到&lt;code>n4&lt;/code>一共占用了24个字节&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">printf(&lt;span style="color:#e6db74">&amp;#34;%ld %ld %ld %ld&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, n1, n2, n3, n4);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jonlimx/blogs/image/printf-incompatiable.png" alt="转换不匹配">&lt;/p>
&lt;/li>
&lt;li>格式化字符串转换说明 （关于转换说明符修饰符P71）
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>转换说明&lt;/th>
&lt;th>输出&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>%a %A&lt;/td>
&lt;td>浮点数、十六进制数和p记数法&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%c&lt;/td>
&lt;td>单个字符&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%d&lt;/td>
&lt;td>有符号十进制整数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%e %E&lt;/td>
&lt;td>浮点数，e&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%f&lt;/td>
&lt;td>浮点数，十进制记数法&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%g %G&lt;/td>
&lt;td>根据值的不同，自动选择%f或%e。%e格式用于指数小于-4或者大于或等于精度时&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%i&lt;/td>
&lt;td>有符号十进制整数（与%d相同）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%o&lt;/td>
&lt;td>无符号八进制整数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%p&lt;/td>
&lt;td>指针&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%s&lt;/td>
&lt;td>字符串&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%u&lt;/td>
&lt;td>无符号十进制整数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%x&lt;/td>
&lt;td>无符号十六进制整数，使用十六进制数0f&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%X&lt;/td>
&lt;td>无符号十六进制整数，使用十六进制数0F&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%%&lt;/td>
&lt;td>打印一个百分号&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;/ul></description></item><item><title>Protocol Buffer Basics Go</title><link>https://www.jonathanlin.top/posts/protocol-buffer-basics-go/</link><pubDate>Thu, 01 Jul 2021 13:54:58 +0800</pubDate><guid>https://www.jonathanlin.top/posts/protocol-buffer-basics-go/</guid><description>
&lt;p>原文链接：&lt;a href="https://developers.google.com/protocol-buffers/docs/gotutorial">Protocol Buffer Basics: Go | Protocol Buffers | Google Developers&lt;/a>&lt;/p>
&lt;p>本教程使用proto3语言为Go程序员介绍了protocol buffers的基本使用。通过一步步创建一个简单的示例应用，你将会了解到：&lt;/p>
&lt;ul>
&lt;li>在&lt;code>.proto&lt;/code>文件中定义消息格式&lt;/li>
&lt;li>使用protocol buffer编译器&lt;/li>
&lt;li>使用Go protocol buffer API读写消息&lt;/li>
&lt;/ul>
&lt;p>这不是一个使用protocol buffers的完全手册。更多更细节的信息，请参看：&lt;a href="https://developers.google.com/protocol-buffers/docs/proto3">Language Guide (proto3)&lt;/a>、&lt;a href="https://pkg.go.dev/google.golang.org/protobuf/proto">Go API Reference&lt;/a>、&lt;a href="https://developers.google.com/protocol-buffers/docs/reference/go-generated">Go Generated Code&lt;/a>和&lt;a href="https://developers.google.com/protocol-buffers/docs/encoding">Encoding Reference&lt;/a>&lt;/p>
&lt;h2 id="为什么使用protocol-buffers">为什么使用protocol buffers？&lt;/h2>
&lt;p>我们将要创建一个简单的“地址簿”应用，该应用可以从文件中读和写联系人的信息。地址簿中的每一个联系人有名字，ID和联系电话。&lt;/p>
&lt;p>你如何序列化和读取这种结构化数据？有这么几种方式可以解决这个问题：&lt;/p>
&lt;ul>
&lt;li>使用&lt;a href="https://golang.org/pkg/encoding/gob/">gobs&lt;/a>序列化Go数据结构。对于Go语言本身而言，这是一个很好的方案，但是如果你需要跨语言平台共享数据，那这种方式并不好&lt;/li>
&lt;li>按照你期望的方式把数据编码成单一的字符串，例如4个int类型的数据编码成“12:3:-23:67”。这是一个简单且灵活的办法，但这要求你编写一次性的编码和转换的代码，同时转化代码会带来一定的运行时消耗。对于比较简单的数据，使用这种方式就比较好&lt;/li>
&lt;li>将数据序列化成XML。XML对人类可读友好且各种语言都有对应的解析工具使得该方法有点吸引人。XML也能比较好的跨应用/项目共享数据。然而，众所周知，XML占用空间比较大，并且解析XML往往比较耗性能。此外，定位XML DOM树通常比直接访问类字段要复杂的多&lt;/li>
&lt;/ul>
&lt;p>Protocol buffers具有灵活、高效、自动化等特点可以解决上述问题。使用Protocol buffer，你需要把数据结构的描述定义在&lt;code>.proto&lt;/code>文件中，然后protocol buffer编译器会为你生成一个类，这个类实现了对protocol buffer二进制数据的编码和解析。这个类提供了对各个字段的getter和setter方法用于读写。protocol buffer很重要的一点是，如果将来数据格式扩展了，那么代码中依然可以读取由旧的格式编码的数据。&lt;/p>
&lt;h2 id="哪里找示例代码">哪里找示例代码&lt;/h2>
&lt;p>我们的例子是一系列的命令行程序，这些程序管理了由protocol buffers编码的地址簿数据文件。&lt;code>add_person_go&lt;/code>这个命令添加一条记录到数据文件。&lt;code>list_people_go&lt;/code>解析数据文件并把结果输出到控制台。&lt;/p>
&lt;p>你可以从Github Repo中找到完整的示例：&lt;a href="https://github.com/protocolbuffers/protobuf/tree/master/examples">protobuf/examples at master · protocolbuffers/protobuf (github.com)&lt;/a>&lt;/p>
&lt;h2 id="定义你的protocol格式">定义你的protocol格式&lt;/h2>
&lt;p>创建你的地址簿应用的第一步是定义你的&lt;code>.proto&lt;/code>文件。&lt;code>.proto&lt;/code>文件中的定义很简单：你为你想要序列化的每一个数据结构添加一个消息，然后为消息中的每个字段指定一个名称和对应的类型。在我们的例子中，在&lt;code>.proto&lt;/code>中定义的消息请参考&lt;a href="https://github.com/protocolbuffers/protobuf/blob/master/examples/addressbook.proto">addressbook.proto&lt;/a>。&lt;/p>
&lt;p>&lt;code>.proto&lt;/code>文件是从一个包声明开始的，包声明用来防止在不同项目中的名字冲突。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-protobuf" data-lang="protobuf">syntax &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;proto3&amp;#34;&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#f92672">package&lt;/span> tutorial;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">import&lt;/span> &lt;span style="color:#e6db74">&amp;#34;google/protobuf/timestamp.proto&amp;#34;&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>go_package&lt;/code>定义了代码生成所在的路径，包名即路径中的最后一个目录。例如，我们的例子的包名就是”tutorialpb“。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span style="color:#66d9ef">option&lt;/span> go_package &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;github.com/protocolbuffers/protobuf/examples/go/tutorialpb&amp;#34;&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来，你就可以定义你的消息了。一个小时是包含一组含有类型的字段的集合。许多标准的简单值类型都是支持的，例如&lt;code>bool&lt;/code> 、&lt;code>int32&lt;/code>、 &lt;code>float&lt;/code>、 &lt;code>double&lt;/code> 和&lt;code>string&lt;/code>。你也可以包含其他消息在你要定义的消息里。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span style="color:#66d9ef">message&lt;/span> &lt;span style="color:#a6e22e">Person&lt;/span> {&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">int32&lt;/span> id &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>; &lt;span style="color:#75715e">// Unique ID number for this person.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> email &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">enum&lt;/span> PhoneType {&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> MOBILE &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> HOME &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> WORK &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> }&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">message&lt;/span> &lt;span style="color:#a6e22e">PhoneNumber&lt;/span> {&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> number &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> PhoneType type &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> }&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">repeated&lt;/span> PhoneNumber phones &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> google.protobuf.Timestamp last_updated &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>}&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#75715e">// Our address book file is just one of these.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">message&lt;/span> &lt;span style="color:#a6e22e">AddressBook&lt;/span> {&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">repeated&lt;/span> Person people &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>}&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的例子中，&lt;code>Person&lt;/code>这个消息体里包含了&lt;code>PhoneNumber&lt;/code>这个消息体，&lt;code>AddressBook&lt;/code>这个消息体包含了&lt;code>Person&lt;/code>这个消息。你甚至可以消息体里定义另一个消息体 - 正如你看到的，&lt;code>PhoneNumber&lt;/code>是定义在&lt;code>Person&lt;/code>里的。如果你希望你的取值是预先定义的一组值里的一个，那么你可以定义&lt;code>enum&lt;/code>类型 - 上面的例子中，你希望电话号码的类型是&lt;code>MOBILE&lt;/code>、 &lt;code>HOME&lt;/code>或者 &lt;code>WORK&lt;/code>。&lt;/p>
&lt;p>在每一个字段上诸如&amp;quot;= 1&amp;quot; &amp;ldquo;= 2&amp;quot;的标记是用于在二进制编码的时候对字段指定一个唯一的标记。相对于更高的标记号码而言，1 -15号在编码的时候占用的空间小于一个字节，因此一个有优化手段是你可以把经常会用到的字段或者重复类型的字段（例如数组）标记为1 - 15，把高于15的留给那些不怎么常用到的字段或者可选的字段。重复类型字段里的每一个元素都需要重新编码标记号码，因此重复类型的字段往往都会用到这种优化 。（&lt;em>&lt;strong>这块后面需要再理解一下是什么意思&lt;/strong>&lt;/em>）&lt;/p>
&lt;p>如果一个字段的值没有设置，那么将使用对应类型的&lt;a href="https://developers.google.com/protocol-buffers/docs/proto3#default">默认值&lt;/a>：数字类型的默认值是0，字符串默认值是空字符串，布尔类型的默认值是false。对于嵌套的消息体，它的默认值是带有各个字段名的默认值。调用访问器（getter）去读取值的时候，如果对应的字段没有明确赋值，那么就返回对应的默认值。&lt;/p>
&lt;p>如果一个字段是重复类型，那么元素的个数可能是任意数目（包括0个）。元素的顺序在protocol buffer中是被保留下来的。可以想象重复类型字段是动态数组。&lt;/p>
&lt;p>你将在&lt;a href="https://developers.google.com/protocol-buffers/docs/proto3">Protocol Buffer Language Guide&lt;/a>中找到如何编写&lt;code>.proto&lt;/code>文件的完整教程（包括所有的类型）。至于类似于类继承这种机制就不要找了，protocol buffer不支持。&lt;/p>
&lt;h2 id="编译protocol-buffers">编译protocol buffers&lt;/h2>
&lt;p>现在你已经有&lt;code>.proto&lt;/code>文件了，接下来你需要基于这个文件去生成访问&lt;code>AddresBook&lt;/code>消息体（&lt;code>Person&lt;/code>和&lt;code>PhoneNumber&lt;/code>也是）的类了。你将要使用protocol buffer编译器&lt;code>protoc&lt;/code>来编译你的&lt;code>.proto&lt;/code>文件：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>如果你还未安装编译器，请先&lt;a href="https://developers.google.com/protocol-buffers/docs/downloads">Download Protocol Buffers&lt;/a>，然后参考README进行安装&lt;/p>
&lt;/li>
&lt;li>
&lt;p>运行下面的命令安装Go protocol buffers plugin：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">go get github.com/golang/protobuf/protoc-gen-go
&lt;/code>&lt;/pre>&lt;/div>&lt;p>编译器plugin &lt;code>protoc-gen-to&lt;/code>将被安装在&lt;code>$GOBIN&lt;/code>目录，该目录默认是在&lt;code>$GOPATH/bin&lt;/code>。这个目录必须包含在你的&lt;code>$PATH&lt;/code>中。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>现在你可以运行编译器，指定源目录（就是你的源文件所在的目录，如果没有指定就是指当前目录）和目标目录（生成的代码所在的目录）以及&lt;code>.proto&lt;/code>所在的目录。在我们的例子中，你应该运行下面命令：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">protoc -I&lt;span style="color:#f92672">=&lt;/span>$SRC_DIR --go_out&lt;span style="color:#f92672">=&lt;/span>$DST_DIR $SRC_DIR/addressbook.proto
&lt;/code>&lt;/pre>&lt;/div>&lt;p>由于你是需要生成Go代码，你应该使用&lt;code>--go-out&lt;/code>选项，其他语言则使用对应的选项。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>运行后，你将会在特定的目录看到生成的代码：&lt;code>github.com/protocolbuffers/protobuf/examples/go/tutorialpb/addressbook.pb.go&lt;/code>。&lt;/p>
&lt;h2 id="protocol-buffer-api">Protocol Buffer API&lt;/h2>
&lt;p>生成的&lt;code>addressbook.pb.go&lt;/code>提供了以下有用的类型：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>AddressBook&lt;/code>结构体包含了&lt;code>People&lt;/code>类型的字段&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Person&lt;/code>结构体包含了&lt;code>Name&lt;/code>、&lt;code>Id&lt;/code>、&lt;code>Email&lt;/code>和 &lt;code>Phones&lt;/code>字段&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Person_PhoneNumber&lt;/code>结构体包含了&lt;code>Number&lt;/code>和&lt;code>Type&lt;/code>字段&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Person_PhoneType&lt;/code>结构体和&lt;code>Person.PhoneType&lt;/code>枚举&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>你可以从&lt;a href="https://developers.google.com/protocol-buffers/docs/reference/go-generated">Go Generated Code guide&lt;/a>了解到代码生成的细节，对于大部分代码你只需要像对待Go类型一样。&lt;/p>
&lt;p>&lt;code>list_people&lt;/code>的单元测试&lt;a href="https://github.com/protocolbuffers/protobuf/blob/master/examples/list_people_test.go">command&amp;rsquo;s unit tests&lt;/a>中展示了你应该如何创建&lt;code>Person&lt;/code>的实例：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">pb&lt;/span>.&lt;span style="color:#a6e22e">Person&lt;/span>{
&lt;span style="color:#a6e22e">Id&lt;/span>: &lt;span style="color:#ae81ff">1234&lt;/span>,
&lt;span style="color:#a6e22e">Name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;John Doe&amp;#34;&lt;/span>,
&lt;span style="color:#a6e22e">Email&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;jdoe@example.com&amp;#34;&lt;/span>,
&lt;span style="color:#a6e22e">Phones&lt;/span>: []&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">pb&lt;/span>.&lt;span style="color:#a6e22e">Person_PhoneNumber&lt;/span>{
{&lt;span style="color:#a6e22e">Number&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;555-4321&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">Type&lt;/span>: &lt;span style="color:#a6e22e">pb&lt;/span>.&lt;span style="color:#a6e22e">Person_HOME&lt;/span>},
},
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="写消息">写消息&lt;/h2>
&lt;p>使用proptocol buffers的目的是序列化你的数据，而后能够在任何地方解析。Go语言中，你可以使用&lt;code>proto&lt;/code>库的&lt;a href="https://pkg.go.dev/google.golang.org/protobuf/proto?tab=doc#Marshal">Marshal&lt;/a>方法序列化你的protocol buffer数据。protocol buffer消息体的指针类型实现了&lt;code>proto.Message&lt;/code>接口。调用&lt;code>proto.Marshal&lt;/code>返回序列化后的编码成wire格式的protocol buffer数据。例如，我们在&lt;a href="https://github.com/protocolbuffers/protobuf/blob/master/examples/add_person.go">&lt;code>add_person&lt;/code> command&lt;/a>中使用了这个方法：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#a6e22e">book&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">pb&lt;/span>.&lt;span style="color:#a6e22e">AddressBook&lt;/span>{}
&lt;span style="color:#75715e">// ...
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">// Write the new address book back to disk.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">proto&lt;/span>.&lt;span style="color:#a6e22e">Marshal&lt;/span>(&lt;span style="color:#a6e22e">book&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#a6e22e">log&lt;/span>.&lt;span style="color:#a6e22e">Fatalln&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Failed to encode address book:&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
}
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">ioutil&lt;/span>.&lt;span style="color:#a6e22e">WriteFile&lt;/span>(&lt;span style="color:#a6e22e">fname&lt;/span>, &lt;span style="color:#a6e22e">out&lt;/span>, &lt;span style="color:#ae81ff">0644&lt;/span>); &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#a6e22e">log&lt;/span>.&lt;span style="color:#a6e22e">Fatalln&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Failed to write address book:&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="读数据">读数据&lt;/h2>
&lt;p>你可以使用&lt;code>proto&lt;/code>库中的&lt;a href="https://pkg.go.dev/google.golang.org/protobuf/proto?tab=doc#Unmarshal">Unmarshal&lt;/a>方法来解析编码过的数据。调用这个方法将&lt;code>buf&lt;/code>中的protocol buffer数据解析出来存放在&lt;code>pb&lt;/code>中。因此我们使用下面的代码在&lt;a href="https://github.com/protocolbuffers/protobuf/blob/master/examples/list_people.go">&lt;code>list_people&lt;/code> command&lt;/a>中进行解析：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#75715e">// Read the existing address book.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">in&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">ioutil&lt;/span>.&lt;span style="color:#a6e22e">ReadFile&lt;/span>(&lt;span style="color:#a6e22e">fname&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#a6e22e">log&lt;/span>.&lt;span style="color:#a6e22e">Fatalln&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Error reading file:&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
}
&lt;span style="color:#a6e22e">book&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">pb&lt;/span>.&lt;span style="color:#a6e22e">AddressBook&lt;/span>{}
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">proto&lt;/span>.&lt;span style="color:#a6e22e">Unmarshal&lt;/span>(&lt;span style="color:#a6e22e">in&lt;/span>, &lt;span style="color:#a6e22e">book&lt;/span>); &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#a6e22e">log&lt;/span>.&lt;span style="color:#a6e22e">Fatalln&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Failed to parse address book:&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="扩展protocol-buffer">扩展Protocol Buffer&lt;/h2>
&lt;p>在你使用protocol buffer的代码发布之后，或早或晚你总是希望改进你的protocol buffer定义。如果你希望你新的定义能向后兼容，且你的老的定义能向前兼容（你一定总是希望这样），那么你需要遵循一些规则。在新版本的protocol buffer中：&lt;/p>
&lt;ul>
&lt;li>你一定不能修改现在的字段的标签号码&lt;/li>
&lt;li>你可能会删除某些字段&lt;/li>
&lt;li>你可能会新增字段，但是新增的字段一定要使用全新的标签号码（一定是没有被使用过的，包括那些被删除的字段曾经使用过的）。&lt;/li>
&lt;/ul>
&lt;p>（使用这些规则有一些例外&lt;a href="https://developers.google.com/protocol-buffers/docs/proto3#updating">some exceptions&lt;/a>，但这些很少使用到）&lt;/p>
&lt;p>如果你遵循了这些规则，你会发现老代码也可以读取新的消息，只是会忽略新的字段。对于老代码，被删除的非数组字段会有它们的默认值，数组类型为空。新的代码可以透明的读取老的消息。&lt;/p>
&lt;p>需要注意的是，新的字段不会出现在老消息里，因此你需要添加合理的逻辑处理默认值&lt;a href="https://developers.google.com/protocol-buffers/docs/proto3#default">default value&lt;/a>。&lt;/p></description></item><item><title>使用Github Pages+Hugo搭建个人博客</title><link>https://www.jonathanlin.top/posts/how-to-setup-hugo-github-page/</link><pubDate>Wed, 30 Jun 2021 21:41:09 +0800</pubDate><guid>https://www.jonathanlin.top/posts/how-to-setup-hugo-github-page/</guid><description>
&lt;p>本文通过一些列的步骤，来介绍一下如何通过Github Pages和Hugo来搭建一个个人博客。&lt;/p>
&lt;h2 id="说明">说明&lt;/h2>
&lt;p>首先需要你要有一个github账号。我的一个思路是：把markdown源文件放在一个私有的repo下，然后通过hugo build出来的静态html放在另一个公开的repo下，这个过程可以通过Github Action来触发。基于此，我的博客源文件是在私有repo jonlimx/blogs-src里，博客本身是在公开repo jonlimx/blogs下，如下图所示：&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jonlimx/blogs/image/image-20210630232900924.png" alt="overview">&lt;/p>
&lt;p>所以，如果你想跟我一样，你需要事先建好一个&lt;strong>私有repo&lt;/strong>和一个&lt;strong>公开repo&lt;/strong>。下文中提到的jonlimx/blogs-src就是特指我的私有repo，jonlimx/blogs就是特指我的公开repo。&lt;/p>
&lt;p>此外，你最好对Hugo有一些基本的认识。你可以通过&lt;a href="https://gohugo.io/getting-started/quick-start/">Quick Start Hugo&lt;/a>来快速了解，&lt;strong>并且事先安装好hugo&lt;/strong>。&lt;/p>
&lt;h2 id="配置jonlimxblogs-src和github-action">配置jonlimx/blogs-src和Github Action&lt;/h2>
&lt;p>在github上创建好jonlimx/blogs-src之后，在本地创建一个名为blogs-src的文件夹（路径和名称可自行决定），然后初始化为hugo站点，最后和jonlimx/blogs-src关联即可。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">hugo new site .
&lt;/code>&lt;/pre>&lt;/div>&lt;p>接着打开jonlimx/blogs-src，创建一个workflow &lt;strong>gh-pages.yml&lt;/strong>，完整内容如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">github pages&lt;/span>
&lt;span style="color:#f92672">on&lt;/span>:
&lt;span style="color:#f92672">push&lt;/span>:
&lt;span style="color:#f92672">branches&lt;/span>:
- &lt;span style="color:#ae81ff">main &lt;/span> &lt;span style="color:#75715e"># Set a branch to deploy&lt;/span>
&lt;span style="color:#f92672">pull_request&lt;/span>:
&lt;span style="color:#f92672">jobs&lt;/span>:
&lt;span style="color:#f92672">deploy&lt;/span>:
&lt;span style="color:#f92672">runs-on&lt;/span>: &lt;span style="color:#ae81ff">ubuntu-20.04&lt;/span>
&lt;span style="color:#f92672">steps&lt;/span>:
- &lt;span style="color:#f92672">uses&lt;/span>: &lt;span style="color:#ae81ff">actions/checkout@v2&lt;/span>
&lt;span style="color:#f92672">with&lt;/span>:
&lt;span style="color:#f92672">submodules&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span> &lt;span style="color:#75715e"># Fetch Hugo themes (true OR recursive)&lt;/span>
&lt;span style="color:#f92672">fetch-depth&lt;/span>: &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#75715e"># Fetch all history for .GitInfo and .Lastmod&lt;/span>
- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Setup Hugo&lt;/span>
&lt;span style="color:#f92672">uses&lt;/span>: &lt;span style="color:#ae81ff">peaceiris/actions-hugo@v2&lt;/span>
&lt;span style="color:#f92672">with&lt;/span>:
&lt;span style="color:#f92672">hugo-version&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;latest&amp;#39;&lt;/span>
&lt;span style="color:#75715e"># extended: true&lt;/span>
- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Build&lt;/span>
&lt;span style="color:#f92672">run&lt;/span>: &lt;span style="color:#ae81ff">hugo --minify&lt;/span>
- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Deploy&lt;/span>
&lt;span style="color:#f92672">uses&lt;/span>: &lt;span style="color:#ae81ff">peaceiris/actions-gh-pages@v3&lt;/span>
&lt;span style="color:#f92672">if&lt;/span>: &lt;span style="color:#ae81ff">github.ref == &amp;#39;refs/heads/main&amp;#39;&lt;/span>
&lt;span style="color:#f92672">with&lt;/span>:
&lt;span style="color:#f92672">personal_token&lt;/span>: &lt;span style="color:#ae81ff">${{ secrets.PERSONAL_TOKEN }}&lt;/span>
&lt;span style="color:#f92672">external_repository&lt;/span>: &lt;span style="color:#ae81ff">jonlimx/blogs&lt;/span>
&lt;span style="color:#f92672">publish_dir&lt;/span>: &lt;span style="color:#ae81ff">./public&lt;/span>
&lt;span style="color:#f92672">cname&lt;/span>: &lt;span style="color:#ae81ff">www.jonathanlin.top&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中，Deploy部分使用了&lt;a href="https://github.com/peaceiris/actions-gh-pages">peaceiris/actions-gh-pages&lt;/a>这个Action，配置的相应部分需要替换成你自己相应的内容，具体说明如下：&lt;/p>
&lt;ul>
&lt;li>personal_token: ${{ secrets.PERSONAL_TOKEN }} - 由于我是将jonlimx/blogs-src下的markdown源文件build出来的静态文件发布到jonlimx/blogs下，这种跨repo的发布，只能使用personal_token或者deploy_key。我这里使用的是personal_token。所以在&lt;a href="https://github.com/settings/tokens">Personal Access Tokens (github.com)&lt;/a>上生成一个personal_token，接着将这个token配置到jonlimx/blogs-src到Action secrets，最后使得workflow中能通过secrets.PERSONAL_TOKEN获取到这个token进而有权限发布到jonlimx/blogs。&lt;/li>
&lt;li>external_repository: jonlimx/blogs - 这个很明显，指定了要发布到哪个repo&lt;/li>
&lt;li>cname: &lt;a href="http://www.jonathanlin.top">www.jonathanlin.top&lt;/a> - 为jonlimx/blogs这个repo对应的Github Pages配置自定义域名&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>特别说明&lt;/strong>，如果基于上面这个配置，这个worklow会将markdown build出来的静态文件发布到jonlimx/blogs的&lt;strong>gh-pages&lt;/strong>分支，因此后面在配置Github Pages的时候要选个&lt;strong>gh-pages&lt;/strong>这个分支。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jonlimx/blogs@main/images/image-20210701103429278.png" alt="github-action">&lt;/p>
&lt;h2 id="配置github-pages">配置Github Pages&lt;/h2>
&lt;p>关于Github Pages的介绍请参考&lt;a href="https://docs.github.com/en/pages/getting-started-with-github-pages/about-github-pages">About GitHub Pages - GitHub Docs&lt;/a>。配置Github Pages比较简单。如下图所示，在Github上打开你的公开repo，参考下图红框部分配置，然后保存即可。这里有两点需要注意一下：&lt;/p>
&lt;ul>
&lt;li>分支这块我选的是gh-pages，这是因为我的Github Action跑完是把静态文件发布到jonlimx/blogs的gh-pages分支。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jonlimx/blogs@main/images/image-20210630231109086.png" alt="github配置">&lt;/p>
&lt;ul>
&lt;li>路径是可选/(root)或者/docs。这二者的区别是你把这个repo都配置为Github Pages，还是说仅仅是/doc目录。这个在官方资料里有说明，请自行查阅。&lt;/li>
&lt;li>自定义域名这个是可选的。如果你跟我想配置自定义域名，请参考：&lt;a href="https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/about-custom-domains-and-github-pages">About custom domains and GitHub Pages - GitHub Docs&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>至此，基于Github Pages和Hugo的个人博客基本搭建完成。&lt;/p></description></item></channel></rss>