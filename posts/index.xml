<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Standing on the Shoulder of Giants</title><link>https://www.jonathanlin.top/posts/</link><description>Recent content in Posts on Standing on the Shoulder of Giants</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © {year} Jonathan Lin. All rights reserved.</copyright><lastBuildDate>Thu, 05 Aug 2021 13:48:47 +0800</lastBuildDate><atom:link href="https://www.jonathanlin.top/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>MongoDB学习笔记（一）</title><link>https://www.jonathanlin.top/posts/mongo-notes-01/</link><pubDate>Thu, 05 Aug 2021 13:48:47 +0800</pubDate><guid>https://www.jonathanlin.top/posts/mongo-notes-01/</guid><description>
&lt;h2 id="安装mongodb">安装mongodb&lt;/h2>
&lt;p>我使用的是macOS bigsur，因此这里记录的是在mac下安装mongodb社区版。在mac下最便捷的安装方式就是使用&lt;code>brew&lt;/code>来安装，使用以下命令：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>添加官方tap&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="ln">1&lt;/span>brew tap mongodb/brew
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>安装mongo全家桶，包括社区版服务端，Shell和数据库相关工具&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="ln">1&lt;/span>brew install mongodb-community
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;p>安装完成后，对应的二进制文件和配置文件的位置如下：（Inter处理器）&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>文件&lt;/th>
&lt;th>位置&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>二进制可执行文件&lt;/td>
&lt;td>/usr/local/Cellar/mongodb-community/5.0.1/bin&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>配置文件&lt;/td>
&lt;td>/usr/local/etc/mongod.conf&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>日志文件&lt;/td>
&lt;td>/usr/local/var/log/mongodb&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>数据文件&lt;/td>
&lt;td>/usr/local/var/mongodb&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="以服务的方式启动停止mongodb">以服务的方式启动/停止mongodb&lt;/h2>
&lt;p>启动mongodb服务：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="ln">1&lt;/span>brew services start mongodb-community@5.0
&lt;/code>&lt;/pre>&lt;/div>&lt;p>停止mongodb服务：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="ln">1&lt;/span>brew services stop mongodb-community@5.0
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>C Primer Plus 编程练习</title><link>https://www.jonathanlin.top/posts/c-primer-plus-handson/</link><pubDate>Fri, 23 Jul 2021 23:35:03 +0800</pubDate><guid>https://www.jonathanlin.top/posts/c-primer-plus-handson/</guid><description>
&lt;h2 id="ch06-c控制语句循环">ch06. C控制语句：循环&lt;/h2>
&lt;blockquote>
&lt;ol start="5">
&lt;li>
&lt;p>编写一个程序，提示用户输入大写字母。使用嵌套循环以下面金字塔型的格式打印字母：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="ln">1&lt;/span> &lt;span class="n">A&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="n">ABA&lt;/span>
&lt;span class="ln">3&lt;/span> &lt;span class="n">ABCBA&lt;/span>
&lt;span class="ln">4&lt;/span> &lt;span class="n">ABCDCBA&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="n">ABCDEDCBA&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>提示：用外层循环处理行，每行使用3个内层循环，分别处理空格、以升序打印字母、以降序打印字母。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>思考：外层循环处理行容易实现，但是使用3个内层循环控制空格、升序字母和降序空格字母似乎有点多。这里可以结合条件判断，是的内层只需要一个循环搞定空格、升降序字母的打印。这里有几点比较关键&lt;/p>
&lt;ul>
&lt;li>每行有多少个空格&lt;/li>
&lt;li>每个一共要打印的字符是多少个，是包括每行的空格加上字符&lt;/li>
&lt;li>每行都是对称的，要找到每行对称中心的字符&lt;/li>
&lt;li>每行的空格数、字符数和对称中心的字符都是不一样的，这个要内循环中处理好&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="ln"> 1&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;#34;stdio.h&amp;#34;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="ln"> 3&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">middle&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">start&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="sc">&amp;#39;A&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Please input a char (A - Z):&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="n">scanf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%c&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">middle&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">middle&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="sc">&amp;#39;A&amp;#39;&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">middle&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="sc">&amp;#39;Z&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">lines&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">middle&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">start&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 总的行数
&lt;/span>&lt;span class="ln">12&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">spaces&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">chars&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 定义变量保存内循环里的空格数以及自字符。字符数实际上是等差数列 - 1，3，5，7...
&lt;/span>&lt;span class="ln">13&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">lines&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="n">spaces&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">lines&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 计算每行的空格数
&lt;/span>&lt;span class="ln">16&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="n">chars&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 计算每行的字符数
&lt;/span>&lt;span class="ln">18&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">asc_start&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">start&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 每行升序部分的起始字符
&lt;/span>&lt;span class="ln">19&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">middle_of_line&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">middle&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">spaces&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 每行的对称中心的字符
&lt;/span>&lt;span class="ln">20&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">desc_start&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">middle_of_line&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 每行的降序部分起始字符
&lt;/span>&lt;span class="ln">21&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">spaces&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">chars&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">22&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">23&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">spaces&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">24&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34; &amp;#34;&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 打印空格
&lt;/span>&lt;span class="ln">25&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">else&lt;/span>
&lt;span class="ln">26&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">27&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">asc_start&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">middle_of_line&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">28&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%c&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">asc_start&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 打印升序部分
&lt;/span>&lt;span class="ln">29&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">else&lt;/span>
&lt;span class="ln">30&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%c&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="n">desc_start&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 打印降序部分
&lt;/span>&lt;span class="ln">31&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">32&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">33&lt;/span>
&lt;span class="ln">34&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln">35&lt;/span>
&lt;span class="ln">36&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">37&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">38&lt;/span> &lt;span class="k">else&lt;/span>
&lt;span class="ln">39&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">40&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Your input is invalid!&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln">41&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">42&lt;/span>
&lt;span class="ln">43&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">44&lt;/span>
&lt;span class="ln">45&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="ln">46&lt;/span>
&lt;span class="ln">47&lt;/span>&lt;span class="c1">// 结果输出
&lt;/span>&lt;span class="ln">48&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">Please&lt;/span> &lt;span class="n">input&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">A&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">Z&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="n">G&lt;/span>
&lt;span class="ln">49&lt;/span> &lt;span class="n">A&lt;/span>
&lt;span class="ln">50&lt;/span> &lt;span class="n">ABA&lt;/span>
&lt;span class="ln">51&lt;/span> &lt;span class="n">ABCBA&lt;/span>
&lt;span class="ln">52&lt;/span> &lt;span class="n">ABCDCBA&lt;/span>
&lt;span class="ln">53&lt;/span> &lt;span class="n">ABCDEDCBA&lt;/span>
&lt;span class="ln">54&lt;/span> &lt;span class="n">ABCDEFEDCBA&lt;/span>
&lt;span class="ln">55&lt;/span>&lt;span class="n">ABCDEFGFEDCBA&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;ol start="7">
&lt;li>编写一个程序把一个单词读入一个字符数组中，然后倒序打印这个单词。提示：&lt;code>strlen()&lt;/code>函数。&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>思考：&lt;/p>
&lt;ul>
&lt;li>&lt;code>strlen()&lt;/code>和&lt;code>sizeof&lt;/code>的区别是 - &lt;code>strlen&lt;/code>输出的字符串的长度，即一个字符串里字符的个数（不包括）末尾的占位符；&lt;code>sizeof&lt;/code>输出的是字符数组的长度&lt;/li>
&lt;li>&lt;code>scanf&lt;/code>读入字符串的时候，遇到空格就停止读入了，也就是读入的只是空格前字符&lt;/li>
&lt;li>实际上，字符串是通过字符数组存放。如果输入的字符串长度超过的数组长度，那么也不会报错且存放的数据也都是正确的，本章和前面的章节还没给出答案，后面专门的字符串章节应该会介绍&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="ln"> 1&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;#34;stdio.h&amp;#34;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;#34;string.h&amp;#34;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 5&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">word&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Please input a word: &amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="n">scanf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%s&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">word&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;sizeof: %zd, string length: %ld&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">word&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">strlen&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">word&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="ln">10&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Magic - &amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">strlen&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">word&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%c&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">word&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln">17&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">19&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="ln">20&lt;/span>
&lt;span class="ln">21&lt;/span>&lt;span class="c1">// 结果输出
&lt;/span>&lt;span class="ln">22&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">Please&lt;/span> &lt;span class="n">input&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="nl">word&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">congratulation&lt;/span>
&lt;span class="ln">23&lt;/span>&lt;span class="k">sizeof&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">string&lt;/span> &lt;span class="nl">length&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">14&lt;/span>
&lt;span class="ln">24&lt;/span>&lt;span class="n">Magic&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">noitalutargnoc&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;ol start="11">
&lt;li>编写一个程序，在数组中读入8个整数，然后按照倒序打印这个8个整数&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>思考：这个考察的是通过循环从&lt;code>scanf&lt;/code>输入字符元素，输入的时候&lt;code>scanf&lt;/code>通过空格分隔。实际上&lt;code>scanf&lt;/code>遇到与期望的数据类型不一致的时候就停止输入，然后继续把不合格的类型的数据传递给下一次&lt;code>scanf&lt;/code>，这个要注意&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="ln"> 1&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;#34;stdio.h&amp;#34;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="cp">#define SIZE 8
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 5&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">SIZE&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Enter 8 numbers(int): &amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">SIZE&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="n">scanf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Numbers in reverse: &amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">SIZE&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d &amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">18&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="ln">19&lt;/span>
&lt;span class="ln">20&lt;/span>&lt;span class="c1">// 结果输出
&lt;/span>&lt;span class="ln">21&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">Enter&lt;/span> &lt;span class="mi">8&lt;/span> &lt;span class="n">numbers&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="mi">3&lt;/span> &lt;span class="mi">4&lt;/span> &lt;span class="mi">5&lt;/span> &lt;span class="mi">6&lt;/span> &lt;span class="mi">7&lt;/span> &lt;span class="mi">8&lt;/span>
&lt;span class="ln">22&lt;/span>&lt;span class="n">Numbers&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="nl">reverse&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">8&lt;/span> &lt;span class="mi">7&lt;/span> &lt;span class="mi">6&lt;/span> &lt;span class="mi">5&lt;/span> &lt;span class="mi">4&lt;/span> &lt;span class="mi">3&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">%&lt;/span>
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>C Primer Plus读书笔记（二）</title><link>https://www.jonathanlin.top/posts/c-primer-plus-notes-02/</link><pubDate>Mon, 19 Jul 2021 21:24:20 +0800</pubDate><guid>https://www.jonathanlin.top/posts/c-primer-plus-notes-02/</guid><description>
&lt;p>&lt;em>本文是《C Primer Plus》第六章至第九章读书笔记，持续更新中。&lt;/em>&lt;/p>
&lt;h2 id="ch06-c控制语句循环">ch06. C控制语句：循环&lt;/h2>
&lt;blockquote>
&lt;ol>
&lt;li>C语言支持哪些循环控制关键字&lt;/li>
&lt;li>循环体中（里）变量的作用域&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>可以通过&lt;code>scanf&lt;/code>函数控制循环 - 如果输入数据无法转换成指定类型的时候，&lt;code>scanf&lt;/code>函数返回0&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>while&lt;/code>循环部分要点：&lt;strong>只有测试条件之后的单独语句（简单或者符合语句）才是循环部分&lt;/strong> （一般编程习惯好的都不会出现这种情况，但是也得了解如果出现这种情况到底是因为什么。现代高级的IDE都会有相应的提醒）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="ln">1&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">3&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;n is %d&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln">4&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 这里的n++已经不是循环体的一部分了，这个程序会陷入死循环
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="ln">1&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="o">++&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 这里的分号是一个完整的语句了，一个空语句，只有这个空语句是while的循环体，因此这个程序只会打印 - n is 4
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;n is %d&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>关系表达式 - 浮点数比较时尽量只使用&lt;code>&amp;gt;&lt;/code>和&lt;code>&amp;lt;&lt;/code>，因为浮点数的舍入误差会导致逻辑上应该相等的两个数不相等&lt;/p>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>TIP - 在构建是否相等的关系表示式的时候，可以如果是比价是否和一个常量相等，这时候可以把常量放左边，这可以避免误把赋值操作当做了比较操作&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="ln">1&lt;/span>&lt;span class="mi">5&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">canoes&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 语法错误，编译器不允许这么做
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">5&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">canose&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>C语言中，数值可以作为测试表达式（真值），但是C语言的真值的逻辑是：&lt;strong>所有非0都视为真，只有0被视为假&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="ln"> 1&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln"> 2&lt;/span>&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%2d is true. | &amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%2d is false.&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln"> 5&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln"> 6&lt;/span>&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%2d is true. | &amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln"> 8&lt;/span>&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%2d is false.&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln"> 9&lt;/span>
&lt;span class="ln">10&lt;/span>&lt;span class="c1">// Output:
&lt;/span>&lt;span class="ln">11&lt;/span>&lt;span class="c1">// 3 is true. | 2 is true. | 1 is true. | 0 is false.
&lt;/span>&lt;span class="ln">12&lt;/span>&lt;span class="c1">// -3 is true. | -2 is true. | -1 is true. | 0 is false.
&lt;/span>&lt;span class="ln">13&lt;/span>&lt;span class="c1">&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>C99之前，用&lt;code>int&lt;/code>表示真/假值。C99之后引入了&lt;code>_Bool&lt;/code>类型，该类型只能存储1（真）或0（假）。如果把非0的数值赋值给&lt;code>_Bool&lt;/code>类型变量，改变量自动被设置成1&lt;/p>
&lt;/li>
&lt;li>
&lt;p>**关系运算符优先级：**关系运算符的优先级比算术运算符（包括+和-）&lt;strong>低&lt;/strong>，&lt;strong>比赋值运算符高&lt;/strong> (优先级：&lt;a href="https://www.jonathanlin.top/posts/c-primer-plus-notes-01/#ch05%E8%BF%90%E7%AE%97%E7%AC%A6%E8%A1%A8%E8%BE%BE%E7%AC%A6%E5%92%8C%E8%AF%AD%E5%8F%A5">C Primer Plus读书笔记（一） | Standing on the Shoulder of Giants (jonathanlin.top)&lt;/a>)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="ch07-c控制语句分支和跳转">ch07. C控制语句：分支和跳转&lt;/h2>
&lt;blockquote>
&lt;ol>
&lt;li>支持分支、跳转的关键字有哪些&lt;/li>
&lt;li>字符I/O函数&lt;code>getchar&lt;/code>和&lt;code>putchar&lt;/code>有什么特别之处&lt;/li>
&lt;li>&lt;code>goto&lt;/code>语句是否应该使用，应该注意哪些事项&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;code>ch = getchar()&lt;/code> - 与&lt;code>scanf(&amp;quot;%c&amp;quot;, &amp;amp;ch)&lt;/code>类似，读取下一个字符赋值给变量&lt;code>ch&lt;/code>&lt;/li>
&lt;li>&lt;code>putchar(ch)&lt;/code> - 与&lt;code>printf(&amp;quot;%c&amp;quot;, ch)&lt;/code>类似，打印一个字符&lt;/li>
&lt;/ul></description></item><item><title>[译]Go Concurrency Best Practice</title><link>https://www.jonathanlin.top/posts/go-concurrency-best-practice/</link><pubDate>Mon, 12 Jul 2021 15:22:05 +0800</pubDate><guid>https://www.jonathanlin.top/posts/go-concurrency-best-practice/</guid><description>
&lt;p>Dave Cheney 2019年在QCon上分享的一些Go编程的原则很有参考价值。我摘录了关于并发的部分，这部分是关于Go编发编程的一些原则和思想。&lt;/p>
&lt;p>原文链接：&lt;a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_concurrency">Practical Go: Real world advice for writing maintainable Go programs (cheney.net)&lt;/a>&lt;/p>
&lt;p>通常选择Go来做项目，往往是因为它的并发特性。Go团队已经不遗余力的让Go在并发方面即能节省资源又能满足性能要求。然而，使用Go的并发特性写出低性能或者不稳定的代码是完全可能的。在最后我想留给你们一些我关于如何避免使用Go并发特定带来的一些隐患的建议。&lt;/p>
&lt;p>支持并发特性的语句&lt;code>channel&lt;/code>，&lt;code>select&lt;/code>和&lt;code>go&lt;/code>在Go特性中是一等公民。如果你在一本书或者培训教程中正式的学习过Go，你可能注意到了并发的部分总是在最后你要学习的。今天这个Workshop（工作坊）也是一样，我也是把并发相关的内容放在最后，这样会让人觉得无论怎样Go并发是一个Go程序员除了常规技能之外一定要掌握的内容。&lt;/p>
&lt;p>凡事都有其两面性：Go的头等特性是它简单、轻量的并发模型。作为一个产品，Go语言几乎是以这个特性作为卖点。但是从另一个方面来说，有一个说法是Go并发并没有那么容易使用，否则那些作者也不会把这个特性放在他们的书的最后一个章节，我们也不会遗憾的回顾我们曾经做的努力（&lt;em>这里不是很理解想表达什么意思&lt;/em>）。&lt;/p>
&lt;p>这个部分我们会讨论一些Go并发特性的天真（随意）用法所带来的隐患。&lt;/p>
&lt;h2 id="keep-your-self-busy-or-do-the-work-yourself">Keep your self busy or do the work yourself&lt;/h2>
&lt;p>&lt;em>我理解作者的意思是：让你自己保持忙碌有事情可做（而不是干等），或者你自己来做这个工作&lt;/em>&lt;/p>
&lt;p>下面的这段程度有什么问题：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln"> 1&lt;/span>&lt;span class="kn">package&lt;/span> &lt;span class="nx">main&lt;/span>
&lt;span class="ln"> 2&lt;/span>
&lt;span class="ln"> 3&lt;/span>&lt;span class="kn">import&lt;/span> &lt;span class="p">(&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="s">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="s">&amp;#34;log&amp;#34;&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="s">&amp;#34;net/http&amp;#34;&lt;/span>
&lt;span class="ln"> 7&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 8&lt;/span>
&lt;span class="ln"> 9&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">HandleFunc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">w&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ResponseWriter&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">r&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Request&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Fprintln&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">w&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;Hello, GopherCon SG&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="p">})&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ListenAndServe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;:8080&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="nx">log&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Fatal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="p">}()&lt;/span>
&lt;span class="ln">18&lt;/span>
&lt;span class="ln">19&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">20&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">21&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个程序的预期就是一个很简单的web服务。然而它同时也做了其他事情，它在一个无限循环中浪费CPU资源。这是因为&lt;code>main&lt;/code>函数最后通过&lt;code>for{}&lt;/code>阻止main Goroutine退出，而不是等待任何IO，也不是在锁上面等待，也不是发送数据到channel或者从channel接收，也不是和调度器通信。&lt;/p>
&lt;p>由于 Go 运行时大部分是协作调度的，因此该程序将在单个 CPU 上徒劳无功，最终可能会以活锁结束。&lt;/p>
&lt;p>我们应该如何解决这个问题？这里有一个建议。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln"> 1&lt;/span>&lt;span class="kn">package&lt;/span> &lt;span class="nx">main&lt;/span>
&lt;span class="ln"> 2&lt;/span>
&lt;span class="ln"> 3&lt;/span>&lt;span class="kn">import&lt;/span> &lt;span class="p">(&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="s">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="s">&amp;#34;log&amp;#34;&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="s">&amp;#34;net/http&amp;#34;&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="s">&amp;#34;runtime&amp;#34;&lt;/span>
&lt;span class="ln"> 8&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 9&lt;/span>
&lt;span class="ln">10&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">HandleFunc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">w&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ResponseWriter&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">r&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Request&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Fprintln&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">w&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;Hello, GopherCon SG&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="p">})&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ListenAndServe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;:8080&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="nx">log&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Fatal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="p">}()&lt;/span>
&lt;span class="ln">19&lt;/span>
&lt;span class="ln">20&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">21&lt;/span> &lt;span class="nx">runtime&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Gosched&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="ln">22&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">23&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这或许看起来很傻，但这是我在外面看到的常见解决方案。 这明显是不了解潜在问题的症状。&lt;/p>
&lt;p>现在，如果你与一点点go方面的经验，你可能会写出下面的代码。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln"> 1&lt;/span>&lt;span class="kn">package&lt;/span> &lt;span class="nx">main&lt;/span>
&lt;span class="ln"> 2&lt;/span>
&lt;span class="ln"> 3&lt;/span>&lt;span class="kn">import&lt;/span> &lt;span class="p">(&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="s">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="s">&amp;#34;log&amp;#34;&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="s">&amp;#34;net/http&amp;#34;&lt;/span>
&lt;span class="ln"> 7&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 8&lt;/span>
&lt;span class="ln"> 9&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">HandleFunc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">w&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ResponseWriter&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">r&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Request&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Fprintln&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">w&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;Hello, GopherCon SG&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="p">})&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ListenAndServe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;:8080&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="nx">log&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Fatal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="p">}()&lt;/span>
&lt;span class="ln">18&lt;/span>
&lt;span class="ln">19&lt;/span> &lt;span class="k">select&lt;/span> &lt;span class="p">{}&lt;/span>
&lt;span class="ln">20&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>空的 select 语句将永远阻塞。 这是一个有用的属性，因为现在我们不是为了调用 &lt;code>runtime.GoSched()&lt;/code> 而轮转整个 CPU。然而我们只是治标不治本。&lt;/p>
&lt;p>我想给你展示另一个方案，我希望你也想到这个方案了。简单的在main goroutine上直接运行&lt;code>http.ListenAndServe&lt;/code>，而不是在一个新的goroutine上运行&lt;code>http.ListenAndServe&lt;/code>然后把要在main goroutine上做什么这个事情留给我们。&lt;/p>
&lt;blockquote>
&lt;p>TIP - Go程序中，如果&lt;code>main.main&lt;/code>函数返回了那么程序也就无条件退出了，不论程序启动的其他goroutine在正在做什么。&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln"> 1&lt;/span>&lt;span class="kn">package&lt;/span> &lt;span class="nx">main&lt;/span>
&lt;span class="ln"> 2&lt;/span>
&lt;span class="ln"> 3&lt;/span>&lt;span class="kn">import&lt;/span> &lt;span class="p">(&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="s">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="s">&amp;#34;log&amp;#34;&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="s">&amp;#34;net/http&amp;#34;&lt;/span>
&lt;span class="ln"> 7&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 8&lt;/span>
&lt;span class="ln"> 9&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">HandleFunc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">w&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ResponseWriter&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">r&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Request&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Fprintln&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">w&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;Hello, GopherCon SG&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="p">})&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ListenAndServe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;:8080&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="nx">log&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Fatal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">16&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>所以这是我的第一个小小的建议：在你的goroutine从其他goroutine获取到结果之前，如果你的goroutine没有任何一点点进展（只能干等），那么这种情况下，你自己的goroutine来做这个工作更合适些，而不是把这个工作代理给其他goroutine。&lt;/p>
&lt;p>这通常消除了将结果从 goroutine 返回到其发起者所需的大量状态跟踪和channel操作。&lt;/p>
&lt;blockquote>
&lt;p>TIP - 许多 Go 程序员过度使用 goroutine，尤其是在他们刚开始的时候。 与生活中的所有事情一样，适度是成功的关键。&lt;/p>
&lt;/blockquote>
&lt;h2 id="leave-concurrency-to-caller">Leave concurrency to caller&lt;/h2>
&lt;p>&lt;em>把并发的权利留给调用者&lt;/em>&lt;/p>
&lt;p>下面这两个API有什么差别？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln">1&lt;/span>&lt;span class="c1">// ListDirectory returns the contents of dir.
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">ListDirectory&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dir&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">([]&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="c1">// ListDirectory returns a channel over which
&lt;/span>&lt;span class="ln">4&lt;/span>&lt;span class="c1">// directory entries will be published. When the list
&lt;/span>&lt;span class="ln">5&lt;/span>&lt;span class="c1">// of entries is exhausted, the channel will be closed.
&lt;/span>&lt;span class="ln">6&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">ListDirectory&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dir&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kd">chan&lt;/span> &lt;span class="kt">string&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>首先，明显的区别是：第一例子是把整个目录都读到一个切片里然后返回这个切片，或者发生错误了就返回错误。这是一个同步操作，&lt;code>ListDirectory&lt;/code>的调用者在读取完所有目录项之前是出于阻塞状态。这就取决于目录本身有多大，可能会耗费大量的时间，可能需要大量的内存存放目录项。&lt;/p>
&lt;p>我们来看看第二个例子。这个就有点Go风格了，&lt;code>ListDirectory&lt;/code>返回了一个channel，读取的目录项是通过这个channel传递。当这个channel关闭的时候，说明没有更多的目录项要读取了。由于通道的填充发生在 ListDirectory 返回之后，ListDirectory 可能正在启动一个 goroutine 来填充通道。&lt;/p>
&lt;blockquote>
&lt;p>NOTE - 第二个版本没有必要实际使用 goroutine。它可以分配一个足以容纳所有目录条目而不会阻塞的通道，填充channel，关闭它，然后将channel返回给调用者。 但这不太可能，因为这样做也是有一样的问题 - 在channel上缓存所有的目录项一样会耗费大量的内存。&lt;/p>
&lt;/blockquote>
&lt;p>使用channel版本的&lt;code>ListDirectory&lt;/code>还有两个额外的问题：&lt;/p>
&lt;ul>
&lt;li>通过关闭的channel作为没有更多目录项要处理的信号，ListDirectory 无法告诉调用者通过channel返回的目录项不完整，因为在获取目录项的中途可能就遇到错误了。调用者也无法区分是空目录还是读取目录时遇到了错误，因为是哪种情况都会导致从&lt;code>ListDirectory&lt;/code>返回channel时就立即关闭了&lt;/li>
&lt;li>调用者必须继续从channel读取直到它关闭，因为这是调用者知道用于填充channel的 goroutine 已停止的唯一方法。这是使用 ListDirectory 的严重限制，调用者必须花时间从channel读取，即使它可能已经得到了它想要的答案&lt;/li>
&lt;/ul>
&lt;p>结果上述问题的方案是使用一个回调函数，该函数在执行时在每个目录条目的上下文中调用。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln">1&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">ListDirectory&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dir&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">fn&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这一点也不奇怪，这就是&lt;code>filepath.WalkDir&lt;/code>函数的工作原理。&lt;/p>
&lt;blockquote>
&lt;p>TIP - 如果你的函数启动了一个 goroutine，你必须为调用者提供一种明确停止该 goroutine 的方法。 将异步执行函数的决定留给该函数的调用者通常更容易。&lt;/p>
&lt;/blockquote>
&lt;h2 id="never-start-a-goroutine-without-knowning-when-it-will-stop">Never start a goroutine without knowning when it will stop&lt;/h2>
&lt;p>&lt;em>如果不知道一个goroutine何时会停止，那么你最好永远也不要启动它&lt;/em>&lt;/p>
&lt;p>前面的例子展示了在没有必要的情况下使用了 goroutine。 但是使用 Go 的一个驱因是该语言提供的一流并发特性。 事实上，在许多情况下，你希望利用硬件提供的可用的并行性。 为此，你必须使用 goroutines。&lt;/p>
&lt;p>这个简单的应用程序在两个不同的端口上提供 http 服务，端口 8080 用于应用程序流量，端口 8001 用于访问&lt;code>/debug/pprof&lt;/code>端点。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln"> 1&lt;/span>&lt;span class="kn">package&lt;/span> &lt;span class="nx">main&lt;/span>
&lt;span class="ln"> 2&lt;/span>
&lt;span class="ln"> 3&lt;/span>&lt;span class="kn">import&lt;/span> &lt;span class="p">(&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="s">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="s">&amp;#34;net/http&amp;#34;&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="s">&amp;#34;net/http/pprof&amp;#34;&lt;/span>
&lt;span class="ln"> 7&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 8&lt;/span>
&lt;span class="ln"> 9&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="nx">mux&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewServeMux&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="nx">mux&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">HandleFunc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">resp&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ResponseWriter&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">req&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Request&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Fprintln&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">resp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;Hello, QCon!&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="p">})&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="k">go&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ListenAndServe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;127.0.0.1:8001&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">DefaultServeMux&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// debug
&lt;/span>&lt;span class="ln">15&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ListenAndServe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;0.0.0.0:8080&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">mux&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// app traffic
&lt;/span>&lt;span class="ln">16&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>虽然上面的程序并没有多么复杂，但一个真正的应用基本上就是这样子了。&lt;/p>
&lt;p>应用程序目前存在一些问题，这些问题会随着应用程序的增长而显现出来，所以现在让我们解决其中的一些问题。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">serveApp&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="nx">mux&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewServeMux&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="nx">mux&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">HandleFunc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">resp&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ResponseWriter&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">req&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Request&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Fprintln&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">resp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;Hello, QCon!&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="p">})&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ListenAndServe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;0.0.0.0:8080&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">mux&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 7&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="ln"> 8&lt;/span>
&lt;span class="ln"> 9&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">serveDebug&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ListenAndServe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;127.0.0.1:8001&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">DefaultServeMux&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">11&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="ln">12&lt;/span>
&lt;span class="ln">13&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="k">go&lt;/span> &lt;span class="nf">serveDebug&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="nf">serveApp&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="ln">16&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过将handler分解为他们自己的函数以解耦。同时我们也遵守了上面的建议，也就是确保把函数的并发性留给他们的调用者&lt;code>main.main&lt;/code>。&lt;/p>
&lt;p>但是这个程序依然存在一些可操作性问题。如果程序返回了那么返回导致程序关闭，接着程序由你使用的进程管理器重新启动。&lt;/p>
&lt;blockquote>
&lt;p>TIP - 正如在Go中应该把函数的并发性留给函数的调用者一样，应用程序应该把其状态监控和应用重启的职责留给启动这个应该程序的程序。不要让你的应用程序自己负责自己的重启，这个过程应该留给应用程序本身以外的其他程序来控制。&lt;/p>
&lt;/blockquote>
&lt;p>然而在一个单独的goroutine中运行，如果它返回了那么只有该goroutine会退出，程序的其余部分会继续。你们的运维人员可能会不高兴的发现他们无法在需要时从你的应用中获取统计信息，因为获取统计信息的handler早就停止工作了。&lt;/p>
&lt;p>我们需要确保当任何一个提供服务的goroutine停止时，那么整个应用程序都要被停止。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">serveApp&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="nx">mux&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewServeMux&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="nx">mux&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">HandleFunc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">resp&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ResponseWriter&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">req&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Request&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Fprintln&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">resp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;Hello, QCon!&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="p">})&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ListenAndServe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;0.0.0.0:8080&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">mux&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="nx">log&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Fatal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln"> 9&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="ln">10&lt;/span>
&lt;span class="ln">11&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">serveDebug&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ListenAndServe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;127.0.0.1:8001&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">DefaultServeMux&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="nx">log&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Fatal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">15&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="ln">16&lt;/span>
&lt;span class="ln">17&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="k">go&lt;/span> &lt;span class="nf">serveDebug&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="ln">19&lt;/span> &lt;span class="k">go&lt;/span> &lt;span class="nf">serveApp&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="ln">20&lt;/span> &lt;span class="k">select&lt;/span> &lt;span class="p">{}&lt;/span>
&lt;span class="ln">21&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在，&lt;code>serverApp&lt;/code>和&lt;code>serveDebug&lt;/code>检查从&lt;code>ListenAndServe&lt;/code>返回的错误，如果发生了错误则调用&lt;code>log.Fatal&lt;/code>。因为这两个handlers都在各自的goroutine中运行，main goroutine通过&lt;code>select{}&lt;/code>阻塞。这种方式有这些问题：&lt;/p>
&lt;ol>
&lt;li>如果&lt;code>ListenAndServe&lt;/code>返回的错误是&lt;code>nil&lt;/code>，&lt;code>log.Fatal&lt;/code>就不会调用，这样监听在对应端口上的HTTP服务会停止但是应该程序并不会停止&lt;/li>
&lt;li>&lt;code>log.Fatal&lt;/code>会调用&lt;code>os.Exit&lt;/code>这将无条件使程序突出，&lt;code>defer&lt;/code>语句也不会执行，其他goroutine也不会被通知要关闭，程序就这样停止了。这使得给这些函数写测试用例变的很困难&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>TIP - 只在&lt;code>init&lt;/code>函数和&lt;code>main.main&lt;/code>函数中使用&lt;code>log.Fatal&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;p>我们真正想要的是将发生的任何错误传递回 goroutine 的发起者，以便它知道 goroutine 停止的原因，可以干净地关闭进程。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">serveApp&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="nx">mux&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewServeMux&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="nx">mux&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">HandleFunc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">resp&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ResponseWriter&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">req&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Request&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Fprintln&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">resp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;Hello, QCon!&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="p">})&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ListenAndServe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;0.0.0.0:8080&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">mux&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 7&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="ln"> 8&lt;/span>
&lt;span class="ln"> 9&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">serveDebug&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ListenAndServe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;127.0.0.1:8001&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">DefaultServeMux&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">11&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="ln">12&lt;/span>
&lt;span class="ln">13&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="nx">done&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="nx">done&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="nf">serveDebug&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="p">}()&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">19&lt;/span> &lt;span class="nx">done&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="nf">serveApp&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="ln">20&lt;/span> &lt;span class="p">}()&lt;/span>
&lt;span class="ln">21&lt;/span>
&lt;span class="ln">22&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="nb">cap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">done&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">23&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">done&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">24&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;error: %v&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">25&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">26&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">27&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="ln">28&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以使用一个通道来收集 goroutine 的返回状态。 通道的大小等于我们要管理的 goroutine 的数量，这样发送到通道就不会阻塞，因为这会阻塞 goroutine 的关闭，导致它泄漏。&lt;/p>
&lt;p>由于没有办法安全地关闭通道，我们不能使用&lt;code>for ... range ...&lt;/code>来循环的通道直到所有 goroutines 都报告完成，而是循环循环我们启动的 goroutines，数量等于channel的容量。&lt;/p>
&lt;p>现在我们有一种方法可以等待每个 goroutine 干净地退出并记录它们遇到的任何错误。 所需要的只是一种将关闭信号从第一个退出的 goroutine 转发给其他 goroutine 的方法。&lt;/p>
&lt;p>事实证明，让一个&lt;code>http.Server&lt;/code>关闭有一些牵强，因此我把关闭的逻辑分离出来放在一个helper函数&lt;code>serve&lt;/code>里。helper函数接收一个地址参数和&lt;code>http.Handler&lt;/code>参数（跟&lt;code>http.ListenAndServe&lt;/code>类似)，同时还有一个用来触发关闭函数&lt;code>Shutdown&lt;/code>的channel。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">serve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">addr&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">handler&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Handler&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">stop&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{})&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Server&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="nx">Addr&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">addr&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="nx">Handler&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">handler&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln"> 6&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">stop&lt;/span> &lt;span class="c1">// wait for stop signal
&lt;/span>&lt;span class="ln"> 9&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Shutdown&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">context&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Background&lt;/span>&lt;span class="p">())&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="p">}()&lt;/span>
&lt;span class="ln">11&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ListenAndServe&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="ln">13&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="ln">14&lt;/span>
&lt;span class="ln">15&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">serveApp&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">stop&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{})&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="nx">mux&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewServeMux&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="nx">mux&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">HandleFunc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">resp&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ResponseWriter&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">req&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Request&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Fprintln&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">resp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;Hello, QCon!&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">19&lt;/span> &lt;span class="p">})&lt;/span>
&lt;span class="ln">20&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nf">serve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;0.0.0.0:8080&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">mux&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">stop&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">21&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="ln">22&lt;/span>
&lt;span class="ln">23&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">serveDebug&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">stop&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{})&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">24&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nf">serve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;127.0.0.1:8001&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">DefaultServeMux&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">stop&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">25&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="ln">26&lt;/span>
&lt;span class="ln">27&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">28&lt;/span> &lt;span class="nx">done&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">29&lt;/span> &lt;span class="nx">stop&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{})&lt;/span>
&lt;span class="ln">30&lt;/span> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">31&lt;/span> &lt;span class="nx">done&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="nf">serveDebug&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">stop&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">32&lt;/span> &lt;span class="p">}()&lt;/span>
&lt;span class="ln">33&lt;/span> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">34&lt;/span> &lt;span class="nx">done&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="nf">serveApp&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">stop&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">35&lt;/span> &lt;span class="p">}()&lt;/span>
&lt;span class="ln">36&lt;/span>
&lt;span class="ln">37&lt;/span> &lt;span class="kd">var&lt;/span> &lt;span class="nx">stopped&lt;/span> &lt;span class="kt">bool&lt;/span>
&lt;span class="ln">38&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="nb">cap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">done&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">39&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">done&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">40&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;error: %v&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">41&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">42&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">!&lt;/span>&lt;span class="nx">stopped&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">43&lt;/span> &lt;span class="nx">stopped&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">true&lt;/span>
&lt;span class="ln">44&lt;/span> &lt;span class="nb">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">stop&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">45&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">46&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">47&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在，每当我们从channel上接收到值（&lt;code>serveDebug&lt;/code>或者&lt;code>serveApp&lt;/code>返回的错误），我们就关闭channel &lt;code>stop&lt;/code>，这导致所有等待在&lt;code>stop&lt;/code>上的goroutine调用&lt;code>Shutdown&lt;/code>方法以关闭HTTP服务进而停止启动HTTP服务的goroutine，最终所有的goroutine都将停止。一旦我们启动的goroutine都停止了，程序也就优雅的停止了。&lt;/p>
&lt;blockquote>
&lt;p>TIP - 自己编写这个逻辑就有些重复了。 可以考虑像这个包 &lt;a href="https://github.com/heptio/workgroup">https://github.com/heptio/workgroup&lt;/a>这样的东西，它将为你完成大部分工作。&lt;/p>
&lt;/blockquote></description></item><item><title>[译]Concurrency Trap #2: Incomplete Work</title><link>https://www.jonathanlin.top/posts/concurrency-trap-2-incomplete-work/</link><pubDate>Mon, 12 Jul 2021 09:15:19 +0800</pubDate><guid>https://www.jonathanlin.top/posts/concurrency-trap-2-incomplete-work/</guid><description>
&lt;p>原文链接：&lt;a href="https://www.ardanlabs.com/blog/2019/04/concurrency-trap-2-incomplete-work.html">Concurrency Trap #2: Incomplete Work (ardanlabs.com)&lt;/a>&lt;/p>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>在我的上一篇博文[&lt;a href="https://www.jonathanlin.top/posts/gorouting-leak-the-forgotten-sender/">译]Goroutine Leaks - The Forgotten Sender&lt;/a>中，我提到了并发是一个非常有用的工具，但是并发往往伴随着特定的陷阱，而这些不会在同步编程中出现。本文会继续这个主题，在本文中我将介绍一个名为未完成的工作的陷阱。未完成的工作发生于在仍然有未完成的Goroutine（非main goroutine）存在的时候程序终止退出了。发生这种情况时，Goroutine的本质使得它会被强制退出，这可能是一个严重的问题。&lt;/p>
&lt;h2 id="未完成的工作">未完成的工作&lt;/h2>
&lt;p>为了说明什么是未完成的工作，请观察下面的例子。&lt;/p>
&lt;p>&lt;strong>Listing 1&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://play.golang.org/p/VORJoAD2oAh">https://play.golang.org/p/VORJoAD2oAh&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln">1&lt;/span>&lt;span class="mi">5&lt;/span> &lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="mi">6&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Hello&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="mi">7&lt;/span> &lt;span class="k">go&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Goodbye&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="mi">8&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Listing 1中的程序在第6行打印了”Hello“，第7行在另一个Goroutine里再次调用了&lt;code>fmt.Println&lt;/code>，在这个Goroutine之后，程序立即到达了&lt;code>main&lt;/code>函数的尾部接着终止退出。如果你运行这个程序，你不会看到”Goodbye“打印出来，这是基于 &lt;a href="https://golang.org/ref/spec#Program_execution">Go specification&lt;/a>中的一个规则：&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>”程序的运行始于main包的初始化和main函数的调用。当main方法的调用返回后，程序就退出了，它并不会等待其他非main Goroutine完成以后才退出。“&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>这个说明已经非常清晰了 - 程序并不会等待未完成的Goroutine，main函数返回以后程序就退出了。这是一个好事情！考虑一下，让一个Goroutine泄露或者让一个Goroutine运行很长一段时间是多么容易发生。如果程序在可以突出之前一直等待非main Goroutine运行，它可能在某种僵尸状态卡住一直无法退出。&lt;/p>
&lt;p>然而，当你启动一个Goroutine去做一些很重要的工作时，程序这种退出的行为就造成问题了，因为main函数不知道要等待Goroutine完成。这种情景会导致完整性问题，比如数据库或者文件系统错误，或者数据丢失。&lt;/p>
&lt;h2 id="一个真实的例子">一个真实的例子&lt;/h2>
&lt;p>在Ardan Labs，我的团队构建了一个Web服务提供给那些需要追踪特定的事件的客户端使用。用于记录事件的那个系统有一个方法，类似于如下Listing 2中所示定义在&lt;code>Tracker&lt;/code>类型上的方法：&lt;/p>
&lt;p>&lt;strong>Listing 2&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://play.golang.org/p/8LoUoCdrT7T">https://play.golang.org/p/8LoUoCdrT7T&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln">1&lt;/span> &lt;span class="mi">9&lt;/span> &lt;span class="c1">// Tracker knows how to track events for the application.
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">10&lt;/span> &lt;span class="kd">type&lt;/span> &lt;span class="nx">Tracker&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{}&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="mi">11&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="mi">12&lt;/span> &lt;span class="c1">// Event records an event to a database or stream.
&lt;/span>&lt;span class="ln">5&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">13&lt;/span> &lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Tracker&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">Event&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">data&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">6&lt;/span>&lt;span class="mi">14&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Millisecond&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// Simulate network write latency.
&lt;/span>&lt;span class="ln">7&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">15&lt;/span> &lt;span class="nx">log&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">data&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">8&lt;/span>&lt;span class="mi">16&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>客户端担心追踪这些事件会带来不必要的响应时延增大，所以想以异步的方式追踪。&lt;strong>对性能做假设实际上是不明智的&lt;/strong>，因此我们的第一个任务是用直接的、同步的方式来追踪事件然后观察服务的时延。在我们的例子中，我们观察到这个时延太长无法接受，因此团队决定用异步方式来实现。如果同步的方式足够快那么这个故事也就结束了，接着我们就把注意力放在更重要的事情上。&lt;/p>
&lt;p>基于上面判断，用于追踪事件的handler最初的实现如下：&lt;/p>
&lt;p>&lt;strong>Listing 3&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://play.golang.org/p/8LoUoCdrT7T">https://play.golang.org/p/8LoUoCdrT7T&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln"> 1&lt;/span>&lt;span class="mi">18&lt;/span> &lt;span class="c1">// App holds application state.
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">19&lt;/span> &lt;span class="kd">type&lt;/span> &lt;span class="nx">App&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 3&lt;/span>&lt;span class="mi">20&lt;/span> &lt;span class="nx">track&lt;/span> &lt;span class="nx">Tracker&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="mi">21&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln"> 5&lt;/span>&lt;span class="mi">22&lt;/span>
&lt;span class="ln"> 6&lt;/span>&lt;span class="mi">23&lt;/span> &lt;span class="c1">// Handle represents an example handler for the web service.
&lt;/span>&lt;span class="ln"> 7&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">24&lt;/span> &lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">App&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">Handle&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">w&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ResponseWriter&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">r&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Request&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 8&lt;/span>&lt;span class="mi">25&lt;/span>
&lt;span class="ln"> 9&lt;/span>&lt;span class="mi">26&lt;/span> &lt;span class="c1">// Do some actual work.
&lt;/span>&lt;span class="ln">10&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">27&lt;/span>
&lt;span class="ln">11&lt;/span>&lt;span class="mi">28&lt;/span> &lt;span class="c1">// Respond to the client.
&lt;/span>&lt;span class="ln">12&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">29&lt;/span> &lt;span class="nx">w&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">WriteHeader&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">StatusCreated&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">13&lt;/span>&lt;span class="mi">30&lt;/span>
&lt;span class="ln">14&lt;/span>&lt;span class="mi">31&lt;/span> &lt;span class="c1">// Fire and Hope.
&lt;/span>&lt;span class="ln">15&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">32&lt;/span> &lt;span class="c1">// BUG: We are not managing this goroutine.
&lt;/span>&lt;span class="ln">16&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">33&lt;/span> &lt;span class="k">go&lt;/span> &lt;span class="nx">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">track&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Event&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;this event&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">17&lt;/span>&lt;span class="mi">34&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>最重要的代码是在Listing 3中的第33行 - 在一个新的Goroutine中调用&lt;code>a.track.Event&lt;/code>的地方。这个效果和预期一样即不给请求增加时延的前提下异步的追踪事件。然而这个代码会调入未完成的工作陷阱，因此必须要重构。任何像第33行那种创建的Goroutine，无论是运行还是结束都是没有保障的。这就是一个完成性问题，因为由于服务器关闭，事件有可能会丢失。&lt;/p>
&lt;h2 id="重构来获取保障">重构来获取保障&lt;/h2>
&lt;p>为了避开这个陷阱，我们团队修改了&lt;code>Tracker&lt;/code>类型来自我管理Goroutine。现在这个类型使用了&lt;code>sync.WaitGroup&lt;/code>来记录启动的Goroutine，并且提供了一个&lt;code>Shutdown&lt;/code>函数给&lt;code>main&lt;/code>，这样&lt;code>main&lt;/code>就可以等待所有Goroutine完成。&lt;/p>
&lt;p>首先，handler被修改为不直接创建Goroutine - 唯一的变化就是Listing 4中第53行去掉了&lt;code>go&lt;/code>关键字。&lt;/p>
&lt;p>&lt;strong>Listing 4&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://play.golang.org/p/BMah6_C57-l">https://play.golang.org/p/BMah6_C57-l&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln"> 1&lt;/span>&lt;span class="mi">44&lt;/span> &lt;span class="c1">// Handle represents an example handler for the web service.
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">45&lt;/span> &lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">App&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">Handle&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">w&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ResponseWriter&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">r&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Request&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 3&lt;/span>&lt;span class="mi">46&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="mi">47&lt;/span> &lt;span class="c1">// Do some actual work.
&lt;/span>&lt;span class="ln"> 5&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">48&lt;/span>
&lt;span class="ln"> 6&lt;/span>&lt;span class="mi">49&lt;/span> &lt;span class="c1">// Respond to the client.
&lt;/span>&lt;span class="ln"> 7&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">50&lt;/span> &lt;span class="nx">w&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">WriteHeader&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">StatusCreated&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 8&lt;/span>&lt;span class="mi">51&lt;/span>
&lt;span class="ln"> 9&lt;/span>&lt;span class="mi">52&lt;/span> &lt;span class="c1">// Track the event.
&lt;/span>&lt;span class="ln">10&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">53&lt;/span> &lt;span class="nx">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">track&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Event&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;this event&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">11&lt;/span>&lt;span class="mi">54&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来，修改&lt;code>Tracker&lt;/code>类型使得它能自己管理Goroutine。&lt;/p>
&lt;p>&lt;strong>Listing 5&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://play.golang.org/p/BMah6_C57-l">https://play.golang.org/p/BMah6_C57-l&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln"> 1&lt;/span>&lt;span class="mi">10&lt;/span> &lt;span class="c1">// Tracker knows how to track events for the application.
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">11&lt;/span> &lt;span class="kd">type&lt;/span> &lt;span class="nx">Tracker&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 3&lt;/span>&lt;span class="mi">12&lt;/span> &lt;span class="nx">wg&lt;/span> &lt;span class="nx">sync&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">WaitGroup&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="mi">13&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln"> 5&lt;/span>&lt;span class="mi">14&lt;/span>
&lt;span class="ln"> 6&lt;/span>&lt;span class="mi">15&lt;/span> &lt;span class="c1">// Event starts tracking an event. It runs asynchronously to
&lt;/span>&lt;span class="ln"> 7&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">16&lt;/span> &lt;span class="c1">// not block the caller. Be sure to call the Shutdown function
&lt;/span>&lt;span class="ln"> 8&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">17&lt;/span> &lt;span class="c1">// before the program exits so all tracked events finish.
&lt;/span>&lt;span class="ln"> 9&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">18&lt;/span> &lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Tracker&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">Event&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">data&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">10&lt;/span>&lt;span class="mi">19&lt;/span>
&lt;span class="ln">11&lt;/span>&lt;span class="mi">20&lt;/span> &lt;span class="c1">// Increment counter so Shutdown knows to wait for this event.
&lt;/span>&lt;span class="ln">12&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">21&lt;/span> &lt;span class="nx">t&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">wg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">13&lt;/span>&lt;span class="mi">22&lt;/span>
&lt;span class="ln">14&lt;/span>&lt;span class="mi">23&lt;/span> &lt;span class="c1">// Track event in a goroutine so caller is not blocked.
&lt;/span>&lt;span class="ln">15&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">24&lt;/span> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">16&lt;/span>&lt;span class="mi">25&lt;/span>
&lt;span class="ln">17&lt;/span>&lt;span class="mi">26&lt;/span> &lt;span class="c1">// Decrement counter to tell Shutdown this goroutine finished.
&lt;/span>&lt;span class="ln">18&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">27&lt;/span> &lt;span class="k">defer&lt;/span> &lt;span class="nx">t&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">wg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Done&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="ln">19&lt;/span>&lt;span class="mi">28&lt;/span>
&lt;span class="ln">20&lt;/span>&lt;span class="mi">29&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Millisecond&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// Simulate network write latency.
&lt;/span>&lt;span class="ln">21&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">30&lt;/span> &lt;span class="nx">log&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">data&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">22&lt;/span>&lt;span class="mi">31&lt;/span> &lt;span class="p">}()&lt;/span>
&lt;span class="ln">23&lt;/span>&lt;span class="mi">32&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">24&lt;/span>&lt;span class="mi">33&lt;/span>
&lt;span class="ln">25&lt;/span>&lt;span class="mi">34&lt;/span> &lt;span class="c1">// Shutdown waits for all tracked events to finish processing.
&lt;/span>&lt;span class="ln">26&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">35&lt;/span> &lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Tracker&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">Shutdown&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">27&lt;/span>&lt;span class="mi">36&lt;/span> &lt;span class="nx">t&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">wg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Wait&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="ln">28&lt;/span>&lt;span class="mi">37&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">29&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Listing 5中第12行，在&lt;code>Tracker&lt;/code>类型中添加了&lt;code>sync.WaitGroup&lt;/code>。在&lt;code>Event&lt;/code>方法中第21行调用了&lt;code>t.wg.Add(1)&lt;/code>，这使得Goroutine（第24行创建）计数器加1。一旦Goroutine被创建，&lt;code>Event&lt;/code>方法就返回了，这符合客户端想减少事件追踪的时延的需求。创建出来的Goroutine就去做它该做的工作，然后在做完以后在第27行调用&lt;code>t.wg.Done()&lt;/code>。调用&lt;code>Done&lt;/code>方法就减少了Goroutine计数器，因此WaitGroup知道这个Goroutine结束了。&lt;/p>
&lt;p>&lt;code>Add&lt;/code>和&lt;code>Done&lt;/code>对于跟踪Goroutine的数量是非常有用的，但我们依然需要告诉程序去等待所有的Goroutine完成。为了达成这个目的，&lt;code>Tracker&lt;/code>类型在第35行添加了一个新的方法&lt;code>Shutdown&lt;/code> - 最简单的一个实现就是调用&lt;code>t.wg.Wait()&lt;/code>，这会阻塞程序知道Goroutine计数器变为0。最后，这个方法会再&lt;code>func main&lt;/code>中调用，如下面的Listing 6：&lt;/p>
&lt;p>&lt;strong>Listing 6&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://play.golang.org/p/BMah6_C57-l">https://play.golang.org/p/BMah6_C57-l&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln"> 1&lt;/span>&lt;span class="mi">56&lt;/span> &lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 2&lt;/span>&lt;span class="mi">57&lt;/span>
&lt;span class="ln"> 3&lt;/span>&lt;span class="mi">58&lt;/span> &lt;span class="c1">// Start a server.
&lt;/span>&lt;span class="ln"> 4&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">59&lt;/span> &lt;span class="c1">// Details not shown...
&lt;/span>&lt;span class="ln"> 5&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">60&lt;/span> &lt;span class="kd">var&lt;/span> &lt;span class="nx">a&lt;/span> &lt;span class="nx">App&lt;/span>
&lt;span class="ln"> 6&lt;/span>&lt;span class="mi">61&lt;/span>
&lt;span class="ln"> 7&lt;/span>&lt;span class="mi">62&lt;/span> &lt;span class="c1">// Shut the server down.
&lt;/span>&lt;span class="ln"> 8&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">63&lt;/span> &lt;span class="c1">// Details not shown...
&lt;/span>&lt;span class="ln"> 9&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">64&lt;/span>
&lt;span class="ln">10&lt;/span>&lt;span class="mi">65&lt;/span> &lt;span class="c1">// Wait for all event goroutines to finish.
&lt;/span>&lt;span class="ln">11&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">66&lt;/span> &lt;span class="nx">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">track&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Shutdown&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="ln">12&lt;/span>&lt;span class="mi">67&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Listing 6中很重要的部分就是第66行，它阻塞了程序退出直到&lt;code>a.track.Shutdown()&lt;/code>完成。&lt;/p>
&lt;h2 id="或许不要等待太久">或许不要等待太久&lt;/h2>
&lt;p>&lt;code>Shown&lt;/code>方法的实现很简单，但确实也做了它该做的事情 - 它等待所有的Goroutine执行完成。但不幸的是，这里面无法限制要等待多久。如果是生产环境，你不能不会愿意看要无限制的等待你的程序退出。为了给&lt;code>Shutdown&lt;/code>方法一个等待的期限，我们团队修改成如下方式：&lt;/p>
&lt;p>&lt;strong>Listing 7&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://play.golang.org/p/p4gsDkpw1Gh">https://play.golang.org/p/p4gsDkpw1Gh&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln"> 1&lt;/span>&lt;span class="mi">36&lt;/span> &lt;span class="c1">// Shutdown waits for all tracked events to finish processing
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">37&lt;/span> &lt;span class="c1">// or for the provided context to be canceled.
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">38&lt;/span> &lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Tracker&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">Shutdown&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span> &lt;span class="nx">context&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Context&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="mi">39&lt;/span>
&lt;span class="ln"> 5&lt;/span>&lt;span class="mi">40&lt;/span> &lt;span class="c1">// Create a channel to signal when the waitgroup is finished.
&lt;/span>&lt;span class="ln"> 6&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">41&lt;/span> &lt;span class="nx">ch&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{})&lt;/span>
&lt;span class="ln"> 7&lt;/span>&lt;span class="mi">42&lt;/span>
&lt;span class="ln"> 8&lt;/span>&lt;span class="mi">43&lt;/span> &lt;span class="c1">// Create a goroutine to wait for all other goroutines to
&lt;/span>&lt;span class="ln"> 9&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">44&lt;/span> &lt;span class="c1">// be done then close the channel to unblock the select.
&lt;/span>&lt;span class="ln">10&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">45&lt;/span> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">11&lt;/span>&lt;span class="mi">46&lt;/span> &lt;span class="nx">t&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">wg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Wait&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="ln">12&lt;/span>&lt;span class="mi">47&lt;/span> &lt;span class="nb">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ch&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">13&lt;/span>&lt;span class="mi">48&lt;/span> &lt;span class="p">}()&lt;/span>
&lt;span class="ln">14&lt;/span>&lt;span class="mi">49&lt;/span>
&lt;span class="ln">15&lt;/span>&lt;span class="mi">50&lt;/span> &lt;span class="c1">// Block this function from returning. Wait for either the
&lt;/span>&lt;span class="ln">16&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">51&lt;/span> &lt;span class="c1">// waitgroup to finish or the context to expire.
&lt;/span>&lt;span class="ln">17&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">52&lt;/span> &lt;span class="k">select&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">18&lt;/span>&lt;span class="mi">53&lt;/span> &lt;span class="k">case&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">ch&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="ln">19&lt;/span>&lt;span class="mi">54&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="ln">20&lt;/span>&lt;span class="mi">55&lt;/span> &lt;span class="k">case&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Done&lt;/span>&lt;span class="p">():&lt;/span>
&lt;span class="ln">21&lt;/span>&lt;span class="mi">56&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nx">errors&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">New&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;timeout&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">22&lt;/span>&lt;span class="mi">57&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">23&lt;/span>&lt;span class="mi">58&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在Listing 7中第38行，&lt;code>Shutdown&lt;/code>方法接收一个&lt;code>context.context&lt;/code>参数。这就是调用者用于限制&lt;code>Shutdown&lt;/code>等待的时长。第41行，创建了一个channel，第45行启动了一个Goroutine。这个Goroutine的唯一工作就是等待WaitGroup进而关闭channel。第52行，通过一个&lt;code>select&lt;/code>块阻塞程序，最终程序退出要么是因为等待时间超时要么通道被关闭了（注：所有Goroutine都执行完成）。&lt;/p>
&lt;p>接下来，我们团队在&lt;code>func main&lt;/code>中修改了调用方式：&lt;/p>
&lt;p>&lt;strong>Listing 8&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://play.golang.org/p/p4gsDkpw1Gh">https://play.golang.org/p/p4gsDkpw1Gh&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln">1&lt;/span>&lt;span class="mi">86&lt;/span> &lt;span class="c1">// Wait up to 5 seconds for all event goroutines to finish.
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">87&lt;/span> &lt;span class="kd">const&lt;/span> &lt;span class="nx">timeout&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">5&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Second&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="mi">88&lt;/span> &lt;span class="nx">ctx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">cancel&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">context&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">WithTimeout&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">context&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Background&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="nx">timeout&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="mi">89&lt;/span> &lt;span class="k">defer&lt;/span> &lt;span class="nf">cancel&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="mi">90&lt;/span>
&lt;span class="ln">6&lt;/span>&lt;span class="mi">91&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">track&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Shutdown&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在Listing 8中创建了一个超时时间为5秒的context，然后这个context传递给&lt;code>a.track.Shutdown&lt;/code>以设置&lt;code>main&lt;/code>函数期望等待的时间。&lt;/p>
&lt;h2 id="结论">结论&lt;/h2>
&lt;p>随着Goroutine的引入，这个服务器的handler能够最小化跟踪事件的API调用的时延。最简单的方式就是使用&lt;code>go&lt;/code>关键字在后台运行但是这会有完整性问题。合适的方法是要确保在程序终止前所有的相关Goroutine完成各自的工作然后退出。&lt;/p>
&lt;p>&lt;em>&lt;strong>并发是非常有用的工具，但是你一定要非常小心的使用它。&lt;/strong>&lt;/em>&lt;/p></description></item><item><title>[译]Goroutine Leaks - The Forgotten Sender</title><link>https://www.jonathanlin.top/posts/gorouting-leak-the-forgotten-sender/</link><pubDate>Wed, 07 Jul 2021 23:24:02 +0800</pubDate><guid>https://www.jonathanlin.top/posts/gorouting-leak-the-forgotten-sender/</guid><description>
&lt;p>原文链接：&lt;a href="https://www.ardanlabs.com/blog/2018/11/goroutine-leaks-the-forgotten-sender.html">Goroutine Leaks - The Forgotten Sender (ardanlabs.com)&lt;/a>&lt;/p>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>并发编程可以让程序员以多个执行路径来解决问题，而且通常是试图提高程序性能。并发并不意味着这些执行路径是以并行的方式执行，而是说这些执行路径以无序异步的方式执行而不是同步顺序执行。历史上这种编程模型是通过标准款或者第三方库来实现的。&lt;/p>
&lt;p>Go语言中，并发特性是通过语言内置的Goroutine和channel来实现，这样就减少了对库的依赖。这容易给人一种错觉，觉得使用Go来编写并发程序会很简单。你得非常小心，因为如果你没有正确的使用Go的并发特性，往往会引入特定的边界效应或者调入陷阱。一不小心，这些陷阱就会给你程序带来很多复杂度以及很恶心的bug。&lt;/p>
&lt;p>本文中，我将讨论的可能出现的陷阱是Goroutine泄漏。&lt;/p>
&lt;h2 id="goroutine泄漏">Goroutine泄漏&lt;/h2>
&lt;p>关于内存管理，Go语言为了处理了许许多多的内存管理细节。Go编译器根据逃逸分析来决定值应该存放在内存中的什么地方（原文站点引用了一篇逃逸分析的博文&lt;a href="https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-escape-analysis.html">Language Mechanics On Escape Analysis (ardanlabs.com)&lt;/a>，回头我也会翻译出来）。运行时通过垃圾回收器管理跟踪和管理堆上分配的内存，正因为此，虽然不能完全肯定你的程序不会发生内存泄漏，但这种概率已经被极大降低了。&lt;/p>
&lt;p>一种常见的内存泄漏是由于Goroutine泄漏引起的。如果你启动了一个Goroutine并且你期望它最终会退出，但由于某种原因最终这个Goroutine没有退出，这时候就发生了泄漏。这种情况下，这个Goroutine就存在于你的应用的整个生命周期，分配给这Goroutine的内存也无法释放。这就是Dave Cheney所建议的“&lt;a href="https://dave.cheney.net/2016/12/22/never-start-a-goroutine-without-knowing-how-it-will-stop">Never start a goroutine without knowing how it will stop&lt;/a>”背后的逻辑。&lt;/p>
&lt;p>下面的代码演示了一种非常常见的Goroutine泄漏。&lt;/p>
&lt;p>&lt;strong>Listing 1&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://play.golang.org/p/dsu3PARM24K">https://play.golang.org/p/dsu3PARM24K&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln"> 1&lt;/span>&lt;span class="mi">31&lt;/span> &lt;span class="c1">// leak is a buggy function. It launches a goroutine that
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">32&lt;/span> &lt;span class="c1">// blocks receiving from a channel. Nothing will ever be
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">33&lt;/span> &lt;span class="c1">// sent on that channel and the channel is never closed so
&lt;/span>&lt;span class="ln"> 4&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">34&lt;/span> &lt;span class="c1">// that goroutine will be blocked forever.
&lt;/span>&lt;span class="ln"> 5&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">35&lt;/span> &lt;span class="kd">func&lt;/span> &lt;span class="nf">leak&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 6&lt;/span>&lt;span class="mi">36&lt;/span> &lt;span class="nx">ch&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 7&lt;/span>&lt;span class="mi">37&lt;/span>
&lt;span class="ln"> 8&lt;/span>&lt;span class="mi">38&lt;/span> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 9&lt;/span>&lt;span class="mi">39&lt;/span> &lt;span class="nx">val&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">ch&lt;/span>
&lt;span class="ln">10&lt;/span>&lt;span class="mi">40&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;We received a value:&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">val&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">11&lt;/span>&lt;span class="mi">41&lt;/span> &lt;span class="p">}()&lt;/span>
&lt;span class="ln">12&lt;/span>&lt;span class="mi">42&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Listing 1定义了一个叫&lt;code>leak&lt;/code>的函数。这个函数在第36行创建了一个channel，通过这个channel把数据传递给后面启动的Goroutine。第38行启动了一个Goroutine，然后这个Goroutine在第39行被阻塞以等待接收channel上的来的数据。当这个Goroutine等待的时候，启动它的函数&lt;code>leak&lt;/code>就执行完返回了，&lt;strong>这时候程序中的没有其他任何地方可以给这个channel发送数据&lt;/strong>，这就导致Goroutine被永久的阻塞在了第39行。第40行的&lt;code>fmt.Println&lt;/code>就永远不会执行。&lt;/p>
&lt;p>在这个例子中，这种Goroutine泄漏可以在一次代码审核中很快被识别出来。不幸的是，生成环境Goroutine泄漏往往很难被发现。我没办法穷举Goroutine泄漏的情景，但是本博文会消息讨论你可能会遇到的一种Goroutine泄漏。&lt;/p>
&lt;h2 id="泄漏被遗忘的发送者">泄漏：被遗忘的发送者&lt;/h2>
&lt;p>(&lt;em>注：个人理解，原作者想表达的”被遗忘的发送者“是指 - gorouting阻塞在了往（非缓冲）channel发送数据，因为由于种种原因程序中其他地方没有从channel中接收&lt;/em>)&lt;/p>
&lt;p>&lt;em>&lt;strong>在这个泄漏的例子中，你将看到一个Goroutine被永久阻塞，等待发送数据给channel&lt;/strong>&lt;/em>&lt;/p>
&lt;p>我们将看到的这个程序 - 基于关键字查找记录然后打印。该程序围绕一个&lt;code>search&lt;/code>函数构建：&lt;/p>
&lt;p>&lt;strong>Listing 2&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://play.golang.org/p/o6_eMjxMVFv">https://play.golang.org/p/o6_eMjxMVFv&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln">1&lt;/span>&lt;span class="mi">29&lt;/span> &lt;span class="c1">// search simulates a function that finds a record based
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">30&lt;/span> &lt;span class="c1">// on a search term. It takes 200ms to perform this work.
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">31&lt;/span> &lt;span class="kd">func&lt;/span> &lt;span class="nf">search&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">term&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="mi">32&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">200&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Millisecond&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="mi">33&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="s">&amp;#34;some value&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="ln">6&lt;/span>&lt;span class="mi">34&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Listing 2中的&lt;code>search&lt;/code>函数的第31行，模拟了一个长时间运行的耗时操作，比如数据库查询或者Web调用。在这里，假设这个耗时操作为200ms。调用&lt;code>search&lt;/code>函数的代码在Listing 3中，如下所示：&lt;/p>
&lt;p>&lt;strong>Listing 3&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln"> 1&lt;/span>&lt;span class="mi">17&lt;/span> &lt;span class="c1">// process is the work for the program. It finds a record
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">18&lt;/span> &lt;span class="c1">// then prints it.
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">19&lt;/span> &lt;span class="kd">func&lt;/span> &lt;span class="nf">process&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">term&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="mi">20&lt;/span> &lt;span class="nx">record&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">search&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">term&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 5&lt;/span>&lt;span class="mi">21&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 6&lt;/span>&lt;span class="mi">22&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;span class="ln"> 7&lt;/span>&lt;span class="mi">23&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln"> 8&lt;/span>&lt;span class="mi">24&lt;/span>
&lt;span class="ln"> 9&lt;/span>&lt;span class="mi">25&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Received:&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">record&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">10&lt;/span>&lt;span class="mi">26&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="ln">11&lt;/span>&lt;span class="mi">27&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Listing 3中第19行，定义了一个&lt;code>process&lt;/code>函数，它接受一个字符串类型的参数&lt;code>term&lt;/code>，这个参数就表示搜索关键字。第20行，&lt;code>term&lt;/code>传递给&lt;code>search&lt;/code>函数该函数返回一条记录和错误。如果有错误发生，在第22行返回错误，否则在第25行打印这条记录。&lt;/p>
&lt;p>对于一些应用而言，串行的调用&lt;code>search&lt;/code>带来的时延或许无法接受。假设&lt;code>search&lt;/code>无法更快的运行了，&lt;code>processs&lt;/code>函数可以修改成不必完全消耗在等待&lt;code>search&lt;/code>返回结果。为了达到这个目的，如下面Listing 4所示，可以使用一个Goroutine来解决这个问题。不幸的是，这个尝试是有问题的，它带来了潜在的Goroutine泄漏。&lt;/p>
&lt;p>&lt;strong>Listing 4&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://play.golang.org/p/m0DHuchgX0A">https://play.golang.org/p/m0DHuchgX0A&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln"> 1&lt;/span>&lt;span class="mi">38&lt;/span> &lt;span class="c1">// result wraps the return values from search. It allows us
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">39&lt;/span> &lt;span class="c1">// to pass both values across a single channel.
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">40&lt;/span> &lt;span class="kd">type&lt;/span> &lt;span class="nx">result&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="mi">41&lt;/span> &lt;span class="nx">record&lt;/span> &lt;span class="kt">string&lt;/span>
&lt;span class="ln"> 5&lt;/span>&lt;span class="mi">42&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="kt">error&lt;/span>
&lt;span class="ln"> 6&lt;/span>&lt;span class="mi">43&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln"> 7&lt;/span>&lt;span class="mi">44&lt;/span>
&lt;span class="ln"> 8&lt;/span>&lt;span class="mi">45&lt;/span> &lt;span class="c1">// process is the work for the program. It finds a record
&lt;/span>&lt;span class="ln"> 9&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">46&lt;/span> &lt;span class="c1">// then prints it. It fails if it takes more than 100ms.
&lt;/span>&lt;span class="ln">10&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">47&lt;/span> &lt;span class="kd">func&lt;/span> &lt;span class="nf">process&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">term&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">11&lt;/span>&lt;span class="mi">48&lt;/span>
&lt;span class="ln">12&lt;/span>&lt;span class="mi">49&lt;/span> &lt;span class="c1">// Create a context that will be canceled in 100ms.
&lt;/span>&lt;span class="ln">13&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">50&lt;/span> &lt;span class="nx">ctx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">cancel&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">context&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">WithTimeout&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">context&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Background&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="mi">100&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Millisecond&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">14&lt;/span>&lt;span class="mi">51&lt;/span> &lt;span class="k">defer&lt;/span> &lt;span class="nf">cancel&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="ln">15&lt;/span>&lt;span class="mi">52&lt;/span>
&lt;span class="ln">16&lt;/span>&lt;span class="mi">53&lt;/span> &lt;span class="c1">// Make a channel for the goroutine to report its result.
&lt;/span>&lt;span class="ln">17&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">54&lt;/span> &lt;span class="nx">ch&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="nx">result&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">18&lt;/span>&lt;span class="mi">55&lt;/span>
&lt;span class="ln">19&lt;/span>&lt;span class="mi">56&lt;/span> &lt;span class="c1">// Launch a goroutine to find the record. Create a result
&lt;/span>&lt;span class="ln">20&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">57&lt;/span> &lt;span class="c1">// from the returned values to send through the channel.
&lt;/span>&lt;span class="ln">21&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">58&lt;/span> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">22&lt;/span>&lt;span class="mi">59&lt;/span> &lt;span class="nx">record&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">search&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">term&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">23&lt;/span>&lt;span class="mi">60&lt;/span> &lt;span class="nx">ch&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="nx">result&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="nx">record&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="ln">24&lt;/span>&lt;span class="mi">61&lt;/span> &lt;span class="p">}()&lt;/span>
&lt;span class="ln">25&lt;/span>&lt;span class="mi">62&lt;/span>
&lt;span class="ln">26&lt;/span>&lt;span class="mi">63&lt;/span> &lt;span class="c1">// Block waiting to either receive from the goroutine&amp;#39;s
&lt;/span>&lt;span class="ln">27&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">64&lt;/span> &lt;span class="c1">// channel or for the context to be canceled.
&lt;/span>&lt;span class="ln">28&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">65&lt;/span> &lt;span class="k">select&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">29&lt;/span>&lt;span class="mi">66&lt;/span> &lt;span class="k">case&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Done&lt;/span>&lt;span class="p">():&lt;/span>
&lt;span class="ln">30&lt;/span>&lt;span class="mi">67&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nx">errors&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">New&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;search canceled&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">31&lt;/span>&lt;span class="mi">68&lt;/span> &lt;span class="k">case&lt;/span> &lt;span class="nx">result&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">ch&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="ln">32&lt;/span>&lt;span class="mi">69&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">result&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">33&lt;/span>&lt;span class="mi">70&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nx">result&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">err&lt;/span>
&lt;span class="ln">34&lt;/span>&lt;span class="mi">71&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">35&lt;/span>&lt;span class="mi">72&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Received:&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">result&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">record&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">36&lt;/span>&lt;span class="mi">73&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="ln">37&lt;/span>&lt;span class="mi">74&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">38&lt;/span>&lt;span class="mi">75&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Listing 4的第50行，&lt;code>process&lt;/code>函数创建了一个100ms的&lt;code>Cancel Context&lt;/code>。关于如何使用&lt;code>Context&lt;/code>你可以阅读&lt;a href="https://blog.golang.org/context">golang.org blog post&lt;/a>。&lt;/p>
&lt;p>第54行，程序创建了一个非缓冲（阻塞）channel允许对它发送&lt;code>result&lt;/code>类型数据或者从它接收。第58行到61行定义了一个匿名函数并启动了一个Goroutine开始执行。这个Goroutine调用了&lt;code>search&lt;/code>函数而后在第60行把返回结果发送到channel。在这个Goroutine工作的时候，&lt;code>process&lt;/code>执行第65行的&lt;code>select&lt;/code>代码块，这个代码块有两个&lt;code>case&lt;/code>分支等待从对应的channel接收数据。&lt;/p>
&lt;p>第66行，这个分支从&lt;code>ctx.Done()&lt;/code>这个channel上接收数据，如果对应的&lt;code>Context&lt;/code>由于100ms超时这个case则被执行。如果这个分支被执行，&lt;code>process&lt;/code>函数则返回错误报告&lt;code>seacrh&lt;/code>超时了。或者说，第68行的分支执行了，意味着&lt;code>search&lt;/code>正常返回了并把结果赋给了变量&lt;code>result&lt;/code>。如上面Listing 3中串行调用&lt;code>search&lt;/code>的那样，第69和70行，程序判断&lt;code>search&lt;/code>函数是否返回错误，如果有则处理错误。如果没有错误，那么在第72行打印结果而后最终发挥&lt;code>nil&lt;/code>给上层调用者。&lt;/p>
&lt;p>这个版本的重构，在&lt;code>process&lt;/code>函数中设定了一个等待&lt;code>search&lt;/code>完成的最长时间，也就是100ms。然后，这种方式也带来了潜在的Goroutine泄漏。想一想这个Goroutine做的事情，在第60行发送结果到channel - 这个操作会阻塞直到另一个Goroutine读取了这个channel里的数据。但是考虑超时的情况，如果超时先发生了（&lt;code>search&lt;/code>还没返回结果），那么&lt;code>select&lt;/code>块就结束等待往下进行（&lt;code>case &amp;lt;-ctx.Done()&lt;/code>分支)，由于channel里的数据没有地方消费那么Goroutine就永久阻塞（第60行），这就导致了Goroutine泄漏。&lt;/p>
&lt;h2 id="修复给channel点空间非缓冲---缓冲">修复：给channel点空间（非缓冲 -&amp;gt; 缓冲）&lt;/h2>
&lt;p>上面的泄漏问题，最简单的解决方式就是 - 把原先的非缓冲（阻塞）channel修改为容量为1的缓冲（非阻塞）channel。&lt;/p>
&lt;p>&lt;strong>Listing 5&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://play.golang.org/p/u3xtQ48G3qK">https://play.golang.org/p/u3xtQ48G3qK&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln">1&lt;/span>&lt;span class="mi">53&lt;/span> &lt;span class="c1">// Make a channel for the goroutine to report its result.
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">54&lt;/span> &lt;span class="c1">// Give it capacity so sending doesn&amp;#39;t block.
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="mi">55&lt;/span> &lt;span class="nx">ch&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="nx">result&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在在超时的那个分支，即使由于超时导致&lt;code>select&lt;/code>块结束等待往下进行（&lt;code>case &amp;lt;-ctx.Done()&lt;/code>分支)，启动&lt;code>search&lt;/code>的那个Goroutine最终也会得到搜索结果并发送到channel进而执行完成返回而不阻塞。最终Goroutine以及channel占用的内存都会被释放掉。所有事情自然而然的都解决了。&lt;/p>
&lt;p>在William Kennedy的一片博文&lt;a href="https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html">The Behavior of Channels&lt;/a>中，他给出了一些很不错的关于channel行为的例子，同时也介绍了如何使用channel的哲学。那篇文章中最后一个例子Listing 10中演示的程序和本文中timeout的例子相似。你可以读一读他的博文以了解更多关于如何使用缓冲channel和如何设置容量的建议。&lt;/p>
&lt;h2 id="结论">结论&lt;/h2>
&lt;p>Go语言中很容易去使用Goroutine，但是如何明智的使用是我们的责任。在本文中，我展示一个错误的使用Goroutine的例子。还有许许多多其他陷阱一样，也是有许许多多的方式会造成并发编程中的Goroutine的泄漏。在将来的博文中，我会提供更多关于Goroutine泄漏的例子和陷阱。现在我留给你一个建议：任何时候你需要启动一个Goroutine的时候，你必须要问问你自己：&lt;/p>
&lt;ul>
&lt;li>它何时会终止？&lt;/li>
&lt;li>有哪些情况会阻碍它终止？&lt;/li>
&lt;/ul>
&lt;p>&lt;em>&lt;strong>并发是非常有用的工具，但是你一定要非常小心的使用它。&lt;/strong>&lt;/em>&lt;/p></description></item><item><title>[译]Protocol Buffer Language Guide (proto3)</title><link>https://www.jonathanlin.top/posts/protocol-buffer-language-guide/</link><pubDate>Tue, 06 Jul 2021 14:49:22 +0800</pubDate><guid>https://www.jonathanlin.top/posts/protocol-buffer-language-guide/</guid><description>
&lt;p>原文链接：&lt;a href="https://developers.google.com/protocol-buffers/docs/proto3">Language Guide (proto3) | Protocol Buffers | Google Developers&lt;/a>&lt;/p>
&lt;p>本指导文档描述了如何使用protocol buffer语言来构建你的protocol buffer数据，包括&lt;code>.proto&lt;/code>文件的语法规则，包括如何从你的&lt;code>.proto&lt;/code>文件中生成数据访问类。本文介绍的是&lt;strong>proto3&lt;/strong>版本的语言规则，关于&lt;strong>proto2&lt;/strong>版本的信息，请参考： &lt;a href="https://developers.google.com/protocol-buffers/docs/proto">Proto2 Language Guide&lt;/a>。&lt;/p>
&lt;p>本文是一个指导性的参考文档，关于如何使用本文中提及的特性的例子，请参考&lt;a href="https://developers.google.com/protocol-buffers/docs/tutorials">tutorial&lt;/a> 并选择你想要的特定编程语言的例子。&lt;/p>
&lt;h2 id="定义一个消息类型">定义一个消息类型&lt;/h2>
&lt;p>首先让我们来看一个非常简单的例子。比如说你想要定义一个搜索请求这样一个消息，这个消息里包含一个查询字符串（query string）、你所感兴趣页面的数量以及每个页面包含的结果。如下是你的&lt;code>.proto&lt;/code>文件定义：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="n">syntax&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;proto3&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">SearchRequest&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">4&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="n">query&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">5&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">int32&lt;/span> &lt;span class="n">page_number&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">6&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">int32&lt;/span> &lt;span class="n">result_per_page&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">7&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>第一行说明你使用的是&lt;code>proto3&lt;/code>版本的语言规则。如果没有这一行，那么protocol buffer编译器会认为你是使用&lt;code>proto2&lt;/code> 版本的语言规则。&lt;code>syntax&lt;/code>定义必须是在&lt;code>.proto&lt;/code>文件的第一行&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>SearchRequest&lt;/code>包含了三个字段（键值对），每个字段都有一个名字和对应的数据类型&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="指定字段类型">指定字段类型&lt;/h3>
&lt;p>上面的例子中，三个字段都是&lt;a href="#%E6%A0%87%E9%87%8F%E7%B1%BB%E5%9E%8B">标量类型&lt;/a>（相对与复合类型，比如struct而言)：两个整型变量（&lt;code>page_number&lt;/code>和&lt;code>result_per_page&lt;/code>）和一个字符串变量（&lt;code>query&lt;/code>)。当然，你可以定义你的字段为复合类型，比如&lt;a href="#%E6%9E%9A%E4%B8%BE">枚举&lt;/a>和其他消息类型。&lt;/p>
&lt;h3 id="分配字段号码">分配字段号码&lt;/h3>
&lt;p>正如你所见，消息定义中的每一个字段都一个唯一的号码。这些字段号码是在二进制消息格式中（&lt;a href="https://developers.google.com/protocol-buffers/docs/encoding">message binary format&lt;/a>）的标识，一旦你开始使用你定义的消息，这些字段号码都不应该再改变。注意，字段号码为1到15的字段在编码的时候占用一个字节（包括字段号码和字段类型，关于这点的更多细节，请参看：&lt;a href="https://developers.google.com/protocol-buffers/docs/encoding#structure">Protocol Buffer Encoding&lt;/a>）。字段号码从16到2047的字段会占用两个字节。因此你应该将1到15范围的号码留给那些在消息里经常用到的字段。并且要考虑预留一些该范围的号码，以便将来扩展你的消息。&lt;/p>
&lt;p>你可以使用的最小字段号码是1，最大字段2&lt;sup>29&lt;/sup> - 1或者536,870,911。你不可以使用字段号码为19000到19999的部分（&lt;code>FieldDescriptor::kFirstReservedNumber&lt;/code> 到 &lt;code>FieldDescriptor::kLastReservedNumber&lt;/code>），这些是为protocol buffer本身的实现所保留的 - 如果你在&lt;code>.proto&lt;/code>文件中使用了这些保留范围内的字段号码，编译器报错。同样的，如果你使用了那些被标记为&lt;code>reserved&lt;/code>的字段号码，编译器也会报错。&lt;/p>
&lt;h3 id="指定字段规则">指定字段规则&lt;/h3>
&lt;p>消息的字段可以是下面两种形式：&lt;/p>
&lt;ul>
&lt;li>单数形式：一个良好组织的消息可以有零个或者一个这种字段（不能超过一个）。这是&lt;code>proto3&lt;/code>版本的默认字段规则。（个人理解，这里不是说只能定义零个或者一个这种单数形式的字段，而是说定义为单数形式的字段里最多包含一个元素。这个要对应&lt;code>repeated&lt;/code>来理解）&lt;/li>
&lt;li>&lt;code>repeated&lt;/code>：这种字段对应的元素在一个消息里可以重复任意多次。&lt;code>repeated&lt;/code>中的元素的顺序是固定的。&lt;/li>
&lt;/ul>
&lt;p>在&lt;code>proto3&lt;/code>中，标量类型的&lt;code>repeated&lt;/code>字段是默认是使用&lt;code>packed&lt;/code>来编码的。你可以从&lt;a href="https://developers.google.com/protocol-buffers/docs/encoding#packed">Protocol Buffer Encoding&lt;/a>中了解更多关于&lt;code>packed&lt;/code>编码的信息。&lt;/p>
&lt;h3 id="添加更多的消息类型">添加更多的消息类型&lt;/h3>
&lt;p>在一个&lt;code>.proto&lt;/code>文件中你可以定义多种不同的消息类型，如果你奥定义多个相关的消息，这就非常有用 - 比如你想要定义和&lt;code>SearchRequest&lt;/code>相对应的&lt;code>SearchResponse&lt;/code>消息，你可以在同一个&lt;code>.proto&lt;/code>文件中添加：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">SearchRequest&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="n">query&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">int32&lt;/span> &lt;span class="n">page_number&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">4&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">int32&lt;/span> &lt;span class="n">result_per_page&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">5&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">6&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">7&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">SearchResponse&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">8&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="o">...&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">9&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="添加注释">添加注释&lt;/h3>
&lt;p>在&lt;code>.proto&lt;/code>中添加注释，你可以使用C/C++风格的语法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="cm">/* SearchRequest represents a search query, with pagination options to
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="cm"> * indicate which results to include in the response. */&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">4&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">SearchRequest&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">5&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="n">query&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">6&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">int32&lt;/span> &lt;span class="n">page_number&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// Which page number do we want?
&lt;/span>&lt;span class="ln">7&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int32&lt;/span> &lt;span class="n">result_per_page&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// Number of results to return per page.
&lt;/span>&lt;span class="ln">8&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="保留字段">保留字段&lt;/h3>
&lt;p>如果你&lt;a href="#%E6%9B%B4%E6%96%B0%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B">更新息类型&lt;/a>的时候删除了一个字段，或者把一个字段注释掉，将来其他人在更新相同的消息的时候是可以重用之前字段的号码。之后在他们使用老版本的&lt;code>.proto&lt;/code>时将会导致许多问题，包括数据出错，privacy bugs等。为了确保这些问题不会发生，有一个办法是把那些你删除的字段的使用过的字段号码（和/或名称）标记为&lt;code>reserved&lt;/code>。如果你使用了这些被&lt;code>reserved&lt;/code>标记的号码，编译器会报错。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">Foo&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">reserved&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">15&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">9&lt;/span> &lt;span class="k">to&lt;/span> &lt;span class="mi">11&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">reserved&lt;/span> &lt;span class="s">&amp;#34;foo&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;bar&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">4&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意，你不可以在同一个&lt;code>reserved&lt;/code>语句中同时制定字段号码和字段名称。&lt;/p>
&lt;h3 id="从proto文件中生成的代码">从&lt;code>.proto&lt;/code>文件中生成的代码&lt;/h3>
&lt;p>当你编译&lt;code>.proto&lt;/code>文件时，编译器会生成你指定的语言代码来和你定义在&lt;code>.proto&lt;/code>文件中消息交互，包括访问和设置字段的值、序列化你的消息问输出流以及从输入流中解析为消息。&lt;/p>
&lt;ul>
&lt;li>**C++**语言：生成&lt;code>.h&lt;/code>和&lt;code>.cc&lt;/code>文件，每个消息都会生成一个对应的类&lt;/li>
&lt;li>&lt;strong>Java&lt;/strong>语言，每个消息都会生成一个包含对应类的&lt;code>.java&lt;/code>文件，以及创建对应类实例的&lt;code>Builder&lt;/code>类&lt;/li>
&lt;li>&lt;strong>Kotlin&lt;/strong>语言，除了和Java语言生成的一样的代码以外，还会生成一个&lt;code>.kt&lt;/code>文件包含一个用例创建类型实例的DSL&lt;/li>
&lt;li>&lt;strong>Pytyon&lt;/strong>语言少许不同，生成一个包含了每个消息对应的静态描述器的模块，这些被用来在运行时创建必要的Python数据访问类&lt;/li>
&lt;li>&lt;strong>Go&lt;/strong>语言，生成一个包含所有消息的&lt;code>.pb.go&lt;/code>代码文件&lt;/li>
&lt;li>&lt;strong>Ruby&lt;/strong>语言，生成一个包含所有消息的&lt;code>.rb&lt;/code>代码文件&lt;/li>
&lt;li>&lt;strong>Object-C&lt;/strong>语言，生成一个&lt;code>probjc.h&lt;/code>和&lt;code>projc.m&lt;/code>文件，每一个消息对应了一个类&lt;/li>
&lt;li>**C#**语言，生成一个&lt;code>.cs&lt;/code>文件，每一个消息对应了一个类&lt;/li>
&lt;li>&lt;strong>Dart&lt;/strong>，生成一个&lt;code>.pb.dart&lt;/code>文件，每一个消息对应了一个类&lt;/li>
&lt;/ul>
&lt;p>关于特定语言的API的使用，你可以参考：&lt;a href="https://developers.google.com/protocol-buffers/docs/reference/overview">API reference&lt;/a>。&lt;/p>
&lt;h2 id="标量类型">标量类型&lt;/h2>
&lt;p>标量类型即下表中的一种类型。下表展示了&lt;code>.proto&lt;/code>中支持的标量类型和特定语言标量类型的对应关系（原文有更多的编程语言的对应关系，译文中我只选取我关心的语言☺）：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">.proto Type&lt;/th>
&lt;th style="text-align:left">Notes&lt;/th>
&lt;th style="text-align:left">C++ Type&lt;/th>
&lt;th style="text-align:left">Java/Kotlin Type[1]&lt;/th>
&lt;th style="text-align:left">Python Type[3]&lt;/th>
&lt;th style="text-align:left">Go Type&lt;/th>
&lt;th style="text-align:left">C# Type&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">double&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;td style="text-align:left">double&lt;/td>
&lt;td style="text-align:left">double&lt;/td>
&lt;td style="text-align:left">float&lt;/td>
&lt;td style="text-align:left">float64&lt;/td>
&lt;td style="text-align:left">double&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">float&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;td style="text-align:left">float&lt;/td>
&lt;td style="text-align:left">float&lt;/td>
&lt;td style="text-align:left">float&lt;/td>
&lt;td style="text-align:left">float32&lt;/td>
&lt;td style="text-align:left">float&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">int32&lt;/td>
&lt;td style="text-align:left">Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead.&lt;/td>
&lt;td style="text-align:left">int32&lt;/td>
&lt;td style="text-align:left">int&lt;/td>
&lt;td style="text-align:left">int&lt;/td>
&lt;td style="text-align:left">int32&lt;/td>
&lt;td style="text-align:left">int&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">int64&lt;/td>
&lt;td style="text-align:left">Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead.&lt;/td>
&lt;td style="text-align:left">int64&lt;/td>
&lt;td style="text-align:left">long&lt;/td>
&lt;td style="text-align:left">int/long[4]&lt;/td>
&lt;td style="text-align:left">int64&lt;/td>
&lt;td style="text-align:left">long&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">uint32&lt;/td>
&lt;td style="text-align:left">Uses variable-length encoding.&lt;/td>
&lt;td style="text-align:left">uint32&lt;/td>
&lt;td style="text-align:left">int[2]&lt;/td>
&lt;td style="text-align:left">int/long[4]&lt;/td>
&lt;td style="text-align:left">uint32&lt;/td>
&lt;td style="text-align:left">uint&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">uint64&lt;/td>
&lt;td style="text-align:left">Uses variable-length encoding.&lt;/td>
&lt;td style="text-align:left">uint64&lt;/td>
&lt;td style="text-align:left">long[2]&lt;/td>
&lt;td style="text-align:left">int/long[4]&lt;/td>
&lt;td style="text-align:left">uint64&lt;/td>
&lt;td style="text-align:left">ulong&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">sint32&lt;/td>
&lt;td style="text-align:left">Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s.&lt;/td>
&lt;td style="text-align:left">int32&lt;/td>
&lt;td style="text-align:left">int&lt;/td>
&lt;td style="text-align:left">int&lt;/td>
&lt;td style="text-align:left">int32&lt;/td>
&lt;td style="text-align:left">int&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">sint64&lt;/td>
&lt;td style="text-align:left">Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s.&lt;/td>
&lt;td style="text-align:left">int64&lt;/td>
&lt;td style="text-align:left">long&lt;/td>
&lt;td style="text-align:left">int/long[4]&lt;/td>
&lt;td style="text-align:left">int64&lt;/td>
&lt;td style="text-align:left">long&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">fixed32&lt;/td>
&lt;td style="text-align:left">Always four bytes. More efficient than uint32 if values are often greater than 228.&lt;/td>
&lt;td style="text-align:left">uint32&lt;/td>
&lt;td style="text-align:left">int[2]&lt;/td>
&lt;td style="text-align:left">int/long[4]&lt;/td>
&lt;td style="text-align:left">uint32&lt;/td>
&lt;td style="text-align:left">uint&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">fixed64&lt;/td>
&lt;td style="text-align:left">Always eight bytes. More efficient than uint64 if values are often greater than 256.&lt;/td>
&lt;td style="text-align:left">uint64&lt;/td>
&lt;td style="text-align:left">long[2]&lt;/td>
&lt;td style="text-align:left">int/long[4]&lt;/td>
&lt;td style="text-align:left">uint64&lt;/td>
&lt;td style="text-align:left">ulong&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">sfixed32&lt;/td>
&lt;td style="text-align:left">Always four bytes.&lt;/td>
&lt;td style="text-align:left">int32&lt;/td>
&lt;td style="text-align:left">int&lt;/td>
&lt;td style="text-align:left">int&lt;/td>
&lt;td style="text-align:left">int32&lt;/td>
&lt;td style="text-align:left">int&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">sfixed64&lt;/td>
&lt;td style="text-align:left">Always eight bytes.&lt;/td>
&lt;td style="text-align:left">int64&lt;/td>
&lt;td style="text-align:left">long&lt;/td>
&lt;td style="text-align:left">int/long[4]&lt;/td>
&lt;td style="text-align:left">int64&lt;/td>
&lt;td style="text-align:left">long&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">bool&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;td style="text-align:left">bool&lt;/td>
&lt;td style="text-align:left">boolean&lt;/td>
&lt;td style="text-align:left">bool&lt;/td>
&lt;td style="text-align:left">bool&lt;/td>
&lt;td style="text-align:left">bool&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">A string must always contain UTF-8 encoded or 7-bit ASCII text, and cannot be longer than 232.&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">String&lt;/td>
&lt;td style="text-align:left">str/unicode[5]&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">bytes&lt;/td>
&lt;td style="text-align:left">May contain any arbitrary sequence of bytes no longer than 232.&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">ByteString&lt;/td>
&lt;td style="text-align:left">str&lt;/td>
&lt;td style="text-align:left">[]byte&lt;/td>
&lt;td style="text-align:left">ByteString&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>你可以从&lt;a href="https://developers.google.com/protocol-buffers/docs/encoding">Protocol Buffer Encoding&lt;/a>了解更多关于消息序列化时的编码相关的信息。&lt;/p>
&lt;h2 id="默认值">默认值&lt;/h2>
&lt;p>解析消息的时候，如果原先经过编码的消息里没有包含特定的单数形式的元素（原文很拗口，个人觉得这里就是说从编码的消息里解析的时候找不到特定的字段），那些这些字段就被赋值成对应类型的默认值，规则如下：&lt;/p>
&lt;ul>
&lt;li>strings类型的默认值是空字符串&lt;/li>
&lt;li>bytes类型的默认值是空字节&lt;/li>
&lt;li>bools类型的默认值是false&lt;/li>
&lt;li>数字类型的默认值是0&lt;/li>
&lt;li>&lt;a href="#%E6%9E%9A%E4%B8%BE">枚举类型&lt;/a>类型的默认值是枚举的第一个元素，也就是枚举值为0的元素&lt;/li>
&lt;li>如果字段类型是其他的消息，那么其默认值跟特定的语言相关，详见：&lt;a href="https://developers.google.com/protocol-buffers/docs/reference/overview">generated code guide&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;code>repeated&lt;/code>类型的字段的默认值一般是对应语言里的空列表。&lt;/p>
&lt;p>对于标量类型的字段，实际上消息解析以后是没办法确定字段的值是人为设置的还是由于根本就没有赋值，而后解析的时候被解析成了默认值 - 你在定义消息的时候需要牢记这一点。例如说，不要定义一个boolean类型的开关是的当值为false的时候执行某些动作（如果你不希望这个动作默认是要执行的，因为boolean类型的默认值就是false）。同时还需要注意，当一个标量字段被设置为默认值的时候，值是不会被序列化的。&lt;/p>
&lt;h2 id="枚举">枚举&lt;/h2>
&lt;p>当你定义你的消息的时候，你可能希望某些字段的值只能从一些预先定义好的值里来。例如，你想为你的&lt;code>SearchRequest&lt;/code>添加一个&lt;code>corpus&lt;/code>字段，这个字段的值可以是&lt;code>UNIVERSAL&lt;/code>, &lt;code>WEB&lt;/code>, &lt;code>IMAGES&lt;/code>, &lt;code>LOCAL&lt;/code>, &lt;code>NEWS&lt;/code>, &lt;code>PRODUCTS&lt;/code> 或者 &lt;code>VIDEO&lt;/code>。你可以通过定义枚举类满足你的需求，枚举中所有可能的值都是一个常量。&lt;/p>
&lt;p>下面的例子中我们添加了一个名为&lt;code>Corpus&lt;/code>的枚举，这个枚举中定义了它可能的值，同时也定义类型为&lt;code>Corpus&lt;/code>的字段：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">SearchRequest&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="n">query&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">int32&lt;/span> &lt;span class="n">page_number&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 4&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">int32&lt;/span> &lt;span class="n">result_per_page&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 5&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kd">enum&lt;/span> &lt;span class="n">Corpus&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 6&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">UNIVERSAL&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 7&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">WEB&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 8&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">IMAGES&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 9&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">LOCAL&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">10&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">NEWS&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">11&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">PRODUCTS&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">12&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">VIDEO&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">13&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">14&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">Corpus&lt;/span> &lt;span class="n">corpus&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">15&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如你所见，枚举&lt;code>Corpus&lt;/code>中的第一个值&lt;code>UNIVERSAL&lt;/code>是常量0：实际上所有的枚举的第一个常量值都应该是0，这是因为：&lt;/p>
&lt;ul>
&lt;li>一定得有0值，这样枚举可以当成数字类型，默认值就是0&lt;/li>
&lt;li>0值作为枚举的第一个元素，这个和&lt;code>proto2&lt;/code>的语言兼容，即第一个元素的值总是默认值&lt;/li>
&lt;/ul>
&lt;p>你可以通过给不同的枚举元素赋相同的值来定义别名，前提是你需要把&lt;code>allow_alias&lt;/code>选项设置为&lt;code>true&lt;/code>，否者编译器遇到这样的别名设置会报错。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">MyMessage1&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kd">enum&lt;/span> &lt;span class="n">EnumAllowingAlias&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="k">option&lt;/span> &lt;span class="n">allow_alias&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 4&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">UNKNOWN&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 5&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">STARTED&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 6&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">RUNNING&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 7&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 8&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 9&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">MyMessage2&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">10&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kd">enum&lt;/span> &lt;span class="n">EnumNotAllowingAlias&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">11&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">UNKNOWN&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">12&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">STARTED&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">13&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="c1">// RUNNING = 1; // Uncommenting this line will cause a compile error inside Google and a warning message outside.
&lt;/span>&lt;span class="ln">14&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">15&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>枚举元素的值不能超过32位整型的范围。由于枚举值是使用&lt;a href="https://developers.google.com/protocol-buffers/docs/encoding">varint encoding&lt;/a> 编码，负值是无效的因此也不建议使用负值。你可以在一个消息内部定义枚举（如上面的例子所示）或者外部定义，然后可以在&lt;code>.proto&lt;/code>中定义的任意消息里使用内部或者外部定义的枚举。你可以像使用消息里的字段一样来使用定义在一个消息内部的枚举：&lt;code>_MessageType_._EnumType_&lt;/code>。&lt;/p>
&lt;p>在&lt;code>.proto&lt;/code>中定义的&lt;code>enum&lt;/code>，对应生成的代码中，比如Java，Kotlin，C++也会有对应的&lt;code>enum&lt;/code>，Pyton语言是&lt;code>EnumDescriptor&lt;/code>类。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>注意:&lt;/strong> 对于枚举类型的值的个数限制，这个是和编程语言本身相关，关于这个限制请查看特定的语言说明。&lt;/p>
&lt;/blockquote>
&lt;p>在反序列化的时候，对于无法识别的枚举值，也会在消息中保留下来，至于保留下来以何种方式展现，这个就和语言相关了。对于那些允许枚举值越界的变成语言，比如C++和Go，这些未知的枚举值就是被简单的以整型形式保留。对于不允许枚举值越界的语言，比如Java，可以通过特定的访问器来访问底层的整型值。不管何种情况，消息序列化的时候，会把无法识别的枚举值包含进去。&lt;/p>
&lt;p>更多关于如何使用&lt;code>enum&lt;/code>的信息，请参考：&lt;a href="https://developers.google.com/protocol-buffers/docs/reference/overview">generated code guide&lt;/a>中特定编程语言的部分。&lt;/p>
&lt;h3 id="枚举保留值">枚举保留值&lt;/h3>
&lt;p>如果你&lt;a href="#%E6%9B%B4%E6%96%B0%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B">更新消息类型&lt;/a>的时候删除了一个枚举项或者注释掉，后面其他人在更新这个枚举的时候可以重用原枚举项对应的数值。之后在他们使用老版本的&lt;code>.proto&lt;/code>时将会导致许多问题，包括数据出错，privacy bugs等。为了确保这些问题不会发生，有一个办法是把那些你删除的枚举项的使用过的数值（和/或名称）标记为&lt;code>reserved&lt;/code>。如果你使用了这些被&lt;code>reserved&lt;/code>标记的号码，编译器会报错。你可以指定你保留的枚举数值的范围，你可以使用&lt;code>max&lt;/code>关键字来指定范围的最大值。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="kd">enum&lt;/span> &lt;span class="n">Foo&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">reserved&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">15&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">9&lt;/span> &lt;span class="k">to&lt;/span> &lt;span class="mi">11&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">40&lt;/span> &lt;span class="k">to&lt;/span> &lt;span class="k">max&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">reserved&lt;/span> &lt;span class="s">&amp;#34;FOO&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;BAR&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">4&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意，你不可以在同一个&lt;code>reserved&lt;/code>语句中同时指定枚举项的名称和枚举值。&lt;/p>
&lt;h2 id="使用其他消息类型">使用其他消息类型&lt;/h2>
&lt;p>你可以使用其他消息作为你的字段的类型。例如，你希望你的&lt;code>SearchResponse&lt;/code>中包含&lt;code>Result&lt;/code>类型的字段 - 你可以在同一个&lt;code>.proto&lt;/code>文件找那个定义&lt;code>Result&lt;/code>消息，然后指定&lt;code>SearchResponse&lt;/code>的字段为&lt;code>Result&lt;/code>类型：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">SearchResponse&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="k">repeated&lt;/span> &lt;span class="n">Result&lt;/span> &lt;span class="n">results&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">4&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">5&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">Result&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">6&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="n">url&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">7&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="n">title&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">8&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="k">repeated&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="n">snippets&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">9&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="导入定义">导入定义&lt;/h3>
&lt;p>&lt;strong>注意，这个特性不适用于Java&lt;/strong>&lt;/p>
&lt;p>在上面的例子中，&lt;code>Result&lt;/code>是和&lt;code>SearchResponse&lt;/code>位于相同的&lt;code>.proto&lt;/code>文件中 - 如果你想要使用的消息类型是定义在其他&lt;code>.proto&lt;/code>文件中呢？&lt;/p>
&lt;p>你可以通过导入&lt;code>.proto&lt;/code>文件来使用定义在其他&lt;code>.proto&lt;/code>文件中的消息类型。你可以在文件头部添加import语句来导入：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="k">import&lt;/span> &lt;span class="s">&amp;#34;myproject/other_protos.proto&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>默认情况下，你只能使用直接导入的&lt;code>.proto&lt;/code>文件中定义的消息类型。但是，有时候你可能需要把&lt;code>.proto&lt;/code>文件移动到一个新的位置。你可以直接移动&lt;code>.proto&lt;/code>文件到一个新的位置，然后然后更新所有的import语句指向&lt;code>.proto&lt;/code>的新位置，你现在也可以在原来的位置放一个”假“的&lt;code>.proto&lt;/code>然后使用&lt;code>import public&lt;/code>语句把老的&lt;code>.proto&lt;/code>中的import语句重定向到新的位置。任何导入了包含&lt;code>import public&lt;/code>的&lt;code>.proto&lt;/code>文件也就把&lt;code>import public&lt;/code>的依赖也导入了。例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="c1">// new.proto
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="c1">// All definitions are moved here
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="c1">// old.proto
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="c1">// This is the proto that all clients are importing.
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">import&lt;/span> &lt;span class="n">public&lt;/span> &lt;span class="s">&amp;#34;new.proto&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">4&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">import&lt;/span> &lt;span class="s">&amp;#34;other.proto&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="c1">// client.proto
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">import&lt;/span> &lt;span class="s">&amp;#34;old.proto&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c1">// You use definitions from old.proto and new.proto, but not other.proto
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>protocol buffer编译器从命令行参数&lt;code>-I&lt;/code>/&lt;code>--proto_path&lt;/code>指定的一系列路径中查找导入的&lt;code>.proto&lt;/code>文件。如果这个参数没有指定一个值，编译器就从运行的目录里查找。通常地，你应该把&lt;code>--proto_path&lt;/code>的值设置为你项目的根目录，然后在import语句中使用完整的名称。&lt;/p>
&lt;h3 id="使用proto2的消息类型">使用&lt;code>proto2&lt;/code>的消息类型&lt;/h3>
&lt;p>在&lt;code>proto3&lt;/code>的消息中导入并使用&lt;code>proto2&lt;/code>的消息类型是可以的，相反也是可以。但是&lt;code>proto2&lt;/code>的枚举是无法在&lt;code>proto3&lt;/code>中使用（如果&lt;code>proto2&lt;/code>的消息体中使用&lt;code>proto2&lt;/code>枚举是可以的）&lt;/p>
&lt;h2 id="嵌套类型">嵌套类型&lt;/h2>
&lt;p>你可以在一个消息类型里定义嵌套的消息类型并使用它，如下面的例子所示 - &lt;code>Result&lt;/code>消息是定义在&lt;code>SearchResponse&lt;/code>里的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">SearchResponse&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kd">message&lt;/span> &lt;span class="nc">Result&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="n">url&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">4&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="n">title&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">5&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="k">repeated&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="n">snippets&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">6&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">7&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="k">repeated&lt;/span> &lt;span class="n">Result&lt;/span> &lt;span class="n">results&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">8&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果你想在定义嵌套消息的父消息外使用，你可以通过&lt;code>_Parent_._Type_&lt;/code>来使用：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">SomeOtherMessage&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">SearchResponse.Result&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>你可以多层嵌套消息，如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">Outer&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// Level 0
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">message&lt;/span> &lt;span class="nc">MiddleAA&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// Level 1
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">message&lt;/span> &lt;span class="nc">Inner&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// Level 2
&lt;/span>&lt;span class="ln"> 4&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int64&lt;/span> &lt;span class="n">ival&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 5&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="n">booly&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 6&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 7&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 8&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kd">message&lt;/span> &lt;span class="nc">MiddleBB&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// Level 1
&lt;/span>&lt;span class="ln"> 9&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">message&lt;/span> &lt;span class="nc">Inner&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// Level 2
&lt;/span>&lt;span class="ln">10&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int32&lt;/span> &lt;span class="n">ival&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">11&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="n">booly&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">12&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">13&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">14&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="更新消息类型">更新消息类型&lt;/h2>
&lt;p>如果当前的消息已经不能满足你的需要，例如你希望你的消息里添加一个额外的字段，但是你仍然希望使用基于老的格式生成的代码。不用担心，更新消息类型而不破坏现有的代码是很简单的。你只需要记住以下规则：&lt;/p>
&lt;ul>
&lt;li>不要更改现有字段的字段号码&lt;/li>
&lt;li>如果你添加了新的字段，那些通过老的代码序列化出来的消息仍然可以被新的代码解析。你要牢记默认值 &lt;a href="https://developers.google.com/protocol-buffers/docs/proto3#default">default values&lt;/a>规则，这样才能恰当地和老代码生成的消息交互。同样的，新代码创建的消息也是可以被老代码解析：老代码程序解析的时候只是简单地忽略新加的字段。你可以参考&lt;a href="#%E6%9C%AA%E7%9F%A5%E5%AD%97%E6%AE%B5">未知字段&lt;/a>获取更多的细节&lt;/li>
&lt;li>字段可以被删除，但是要确保这些要删除的字段对应的字段号码不会在消息中再次被使用。你或许可以对字段重命名，比如添加&amp;quot;OBSOLETE_&amp;quot;这样的前缀，或者把字段号码标记为&lt;a href="#%E4%BF%9D%E7%95%99%E5%AD%97%E6%AE%B5">保留字段&lt;/a>，这样将来更新你的&lt;code>.proto&lt;/code>文件的时候就不会意外的使用那些号码&lt;/li>
&lt;li>&lt;code>int32&lt;/code>,&lt;code>uint32&lt;/code>,&lt;code>int64&lt;/code>,&lt;code>uint64&lt;/code>和&lt;code>bool&lt;/code>是相互兼容的 - 这意味着你从其中的一种类型改为另一种类型不会破坏向前或者向后的兼容性。如果一个解析一个数字的时候和目标类型不匹配，会发生和在C++中转化数字类型一样的结果，例如一个64位的数字读取为32位的时候，会被截断为32位的数字&lt;/li>
&lt;li>&lt;code>sint32&lt;/code>和&lt;code>sint64&lt;/code>兼容，但是和其他整型类型不兼容&lt;/li>
&lt;li>&lt;code>string&lt;/code>和&lt;code>bytes&lt;/code>兼容，只要&lt;code>bytes&lt;/code>是有效的UTF-8格式&lt;/li>
&lt;li>嵌套的消息和&lt;code>bytes&lt;/code>兼容，只要&lt;code>bytes&lt;/code>包含编码过的消息&lt;/li>
&lt;li>&lt;code>fixed32&lt;/code>和&lt;code>sfixed32&lt;/code>，&lt;code>fixed64&lt;/code>以及&lt;code>sfixed64&lt;/code>兼容&lt;/li>
&lt;li>对于&lt;code>string&lt;/code>，&lt;code>byte&lt;/code>和消息字段，&lt;code>optional&lt;/code>和&lt;code>repeated&lt;/code>兼容。如果一个&lt;code>repeated&lt;/code>类型字段的序列化数据作为输入，对于期望这个字段为&lt;code>optional&lt;/code>的客户端来说，如果这个字段是基本类型，那么会获取最后一个输入的值；如果这个字段是一个消息类型，那么会把消息里的所有元素合并（&lt;em>这个有点拗口，不知道该怎么理解&lt;/em>）。需要注意的是，对于数值类型（包括bools和enums）来说这是不安全的。数值类型的&lt;code>repeated&lt;/code>字段可以序列化为&lt;a href="https://developers.google.com/protocol-buffers/docs/encoding#packed">packed&lt;/a> 格式，如果客户端期望的是&lt;code>optional&lt;/code>字段，那么不能被正确解析&lt;/li>
&lt;li>&lt;code>enum&lt;/code>和&lt;code>int32&lt;/code>，&lt;code>uint32&lt;/code>，&lt;code>int64&lt;/code>，&lt;code>uint64&lt;/code>兼容（注意如果类型不完全匹配，数据可能被截断）。然而需要注意的是，客户端的代码在反序列的时候可能会有不同的行为，比如未识别的&lt;code>proto3 enum&lt;/code>类型的值会在消息中保留下来，这种行为是和语言本身相关。整型的字段的值总是保持了原来的值&lt;/li>
&lt;li>把一个字段的类型改为&lt;code>oneof&lt;/code>的成员是安全的且二进制上兼容。把多个字段变成&lt;code>oneof&lt;/code>或许是安全的，但是你要确保设置的代码只能有一次（&lt;em>这里也不理解是啥意思&lt;/em>）。把任何字段移到已存在的&lt;code>oneof&lt;/code>里是不安全的&lt;/li>
&lt;/ul>
&lt;h2 id="未知字段">未知字段&lt;/h2>
&lt;p>未知字段是指protocol buffer序列化数据的时候被良好的组织的数据，但是反序列化的时候解析器不认识的字段。例如，对于老代码程序解析由新代码程序序列化的带有新添加的字段的数据时，那些新添加的字段对于老代码程序就变成了未知字段。&lt;/p>
&lt;p>原先proto3消息在解析的时候总是丢弃未知字段，但是在版本3.5我们重新引入了对未知字段的保留以匹配proto2的行为。在版本3.5以及之后未知字段在解析和序列化的时候又重新保留了下来。&lt;/p>
&lt;h2 id="any">Any&lt;/h2>
&lt;p>&lt;code>Any&lt;/code>消息类型能让你像使用嵌套类型一样来使用一个消息而不需要有&lt;code>.proto&lt;/code>的定义。一个&lt;code>Any&lt;/code>消息包含一个序列化为&lt;code>bytes&lt;/code>的消息以及用来解释成对应消息类型的一个全局唯一标识符URL。你需要&lt;a href="#%E4%BD%BF%E7%94%A8%E5%85%B6%E4%BB%96%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B">导入&lt;/a>&lt;code>google/protobuf/any.proto&lt;/code>来使用&lt;code>Any&lt;/code>类型。（注：说白了，这个Any类型就是一种序列化，把一种特定类型按照某种方式序列化为字节数组）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="k">import&lt;/span> &lt;span class="s">&amp;#34;google/protobuf/any.proto&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">ErrorStatus&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">4&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="kd">message&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">5&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="k">repeated&lt;/span> &lt;span class="n">google.protobuf.Any&lt;/span> &lt;span class="n">details&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">6&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>默认的类型URL是&lt;code>type.googleapis.com/_packagename_._messagename_&lt;/code>。&lt;/p>
&lt;p>不同的语言实现会提供类型安全的运行时库来打包和解包&lt;code>Any&lt;/code>类型的值 - 例如在Java中，&lt;code>Any&lt;/code>类型提供了&lt;code>pack()&lt;/code>和&lt;code>unpack()&lt;/code>访问器，在C++中提供了&lt;code>PackFrom()&lt;/code>和&lt;code>UnpackTo()&lt;/code>方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="ln"> 1&lt;/span>&lt;span class="c1">// Storing an arbitrary message type in Any.
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">NetworkErrorDetails&lt;/span> &lt;span class="n">details&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">...;&lt;/span>
&lt;span class="ln"> 3&lt;/span>&lt;span class="n">ErrorStatus&lt;/span> &lt;span class="n">status&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="n">status&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">add_details&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">PackFrom&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">details&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln"> 5&lt;/span>
&lt;span class="ln"> 6&lt;/span>&lt;span class="c1">// Reading an arbitrary message from Any.
&lt;/span>&lt;span class="ln"> 7&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">ErrorStatus&lt;/span> &lt;span class="n">status&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">...;&lt;/span>
&lt;span class="ln"> 8&lt;/span>&lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="n">Any&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="nl">detail&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">status&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">details&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">detail&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Is&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">NetworkErrorDetails&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="n">NetworkErrorDetails&lt;/span> &lt;span class="n">network_error&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="n">detail&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">UnpackTo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">network_error&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="p">...&lt;/span> &lt;span class="n">processing&lt;/span> &lt;span class="n">network_error&lt;/span> &lt;span class="p">...&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">14&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>当前用于和&lt;code>Any&lt;/code>类型交互的运行时库还在开发中&lt;/strong>。&lt;/p>
&lt;p>如果你熟悉 &lt;a href="https://developers.google.com/protocol-buffers/docs/proto">proto2 语法&lt;/a>，和&lt;code>proto2&lt;/code>消息的允许&lt;a href="https://developers.google.com/protocol-buffers/docs/proto#extensions">extensions&lt;/a>一样，&lt;code>Any&lt;/code>可以用来存放&lt;code>proto3&lt;/code>的消息。&lt;/p>
&lt;h2 id="oneof">Oneof&lt;/h2>
&lt;p>如果你的一个消息有多个字段，并且同一时刻最多只有一个字段被赋值，你可以使用&lt;code>oneof&lt;/code>特性来强制这种行为和节省内存。&lt;/p>
&lt;p>&lt;code>oneof&lt;/code>字段和常规字段一样，只是&lt;code>oneof&lt;/code>里所有的成员是共享内存的，且同一时刻最多只有一个字段被赋值。设置任何一个&lt;code>oneof&lt;/code>里的成员将自动清空其他的成员。你可以一个特殊的&lt;code>case()&lt;/code>或者&lt;code>WhichOneof()&lt;/code>方法（取决特定的语言）来判断&lt;code>oneof&lt;/code>里的成员是否被赋值了。&lt;/p>
&lt;h3 id="使用oneof">使用&lt;code>oneof&lt;/code>&lt;/h3>
&lt;p>你可以使用&lt;code>oneof&lt;/code>关键字跟上你的&lt;code>oneof&lt;/code>名称来定义一个&lt;code>oneof&lt;/code>，比如在&lt;code>test_oneof&lt;/code>中：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">SampleMessage&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="k">oneof&lt;/span> &lt;span class="n">test_oneof&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="n">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">4&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">SubMessage&lt;/span> &lt;span class="n">sub_message&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">9&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">5&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">6&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后你可以添加&lt;code>oneof&lt;/code>成员到它的定义中。你可以添加除了&lt;code>map&lt;/code>和&lt;code>repeated&lt;/code>类型的成员到&lt;code>oneof&lt;/code>定义里。在你生成的代码中，&lt;code>oneof&lt;/code>有着和常规字段一样的读写访问器。你还会有一个方法（取决特定的语言）来判断&lt;code>oneof&lt;/code>里的成员是否被赋值了。请参考特定语言的&lt;a href="https://developers.google.com/protocol-buffers/docs/reference/overview">API reference&lt;/a>以了解更多。&lt;/p>
&lt;h3 id="oneof特性">&lt;code>oneof&lt;/code>特性&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>设置任何一个&lt;code>oneof&lt;/code>里的成员将自动清空其他的成员。如果你设置了多个成员，只有最后一个设置的成员才有值。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln">1&lt;/span>&lt;span class="n">SampleMessage&lt;/span> &lt;span class="n">message&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="n">message&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">set_name&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;name&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="n">CHECK&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">message&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">has_name&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="n">message&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">mutable_sub_message&lt;/span>&lt;span class="o">();&lt;/span> &lt;span class="c1">// Will clear name field.
&lt;/span>&lt;span class="ln">5&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">CHECK&lt;/span>&lt;span class="o">(!&lt;/span>&lt;span class="n">message&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">has_name&lt;/span>&lt;span class="o">());&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>解析的时候如果遇到来自同一个&lt;code>oneof&lt;/code>的多个成员，只有最后一次看到的成员才会被解析&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>oneof&lt;/code>不用标识成&lt;code>repeat&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>反射API可以访问&lt;code>oneof&lt;/code>字段&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果&lt;code>oneof&lt;/code>字段设置为默认值（比如int32类型的&lt;code>oneof&lt;/code>成员设置为0），&lt;code>case&lt;/code>方法就会判定这个成员被设置了，这个值会被序列化&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果你使用C++，确保你的代码不会引发内存泄漏。下面的代码会奔溃原因是因为&lt;code>sub_message&lt;/code>在调用了&lt;code>set_name()&lt;/code>后就被删除了&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="ln">1&lt;/span>&lt;span class="n">SampleMessage&lt;/span> &lt;span class="n">message&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="n">SubMessage&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">sub_message&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">message&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">mutable_sub_message&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="n">message&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">set_name&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;name&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// Will delete sub_message
&lt;/span>&lt;span class="ln">4&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">sub_message&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">set_&lt;/span>&lt;span class="p">...&lt;/span> &lt;span class="c1">// Crashes here
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>还是C++，&lt;code>Swap()&lt;/code>两个&lt;code>oneof&lt;/code>消息后，每个消息的&lt;code>oneof&lt;/code>字段发生互换。在下面的例子中，&lt;code>msg1&lt;/code>将会有&lt;code>sub_message&lt;/code>成员而&lt;code>msg2&lt;/code>将会有&lt;code>name&lt;/code>成员：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="ln">1&lt;/span>&lt;span class="n">SampleMessage&lt;/span> &lt;span class="n">msg1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="n">msg1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">set_name&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;name&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="n">SampleMessage&lt;/span> &lt;span class="n">msg2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="n">msg2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">mutable_sub_message&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="n">msg1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">swap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">msg2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln">6&lt;/span>&lt;span class="n">CHECK&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">msg1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">has_sub_message&lt;/span>&lt;span class="p">());&lt;/span>
&lt;span class="ln">7&lt;/span>&lt;span class="n">CHECK&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">msg2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">has_name&lt;/span>&lt;span class="p">());&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="ln">1&lt;/span>&lt;span class="n">SampleMessage&lt;/span> &lt;span class="n">msg1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="n">msg1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">set_name&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;name&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="n">SampleMessage&lt;/span> &lt;span class="n">msg2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="n">msg2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">mutable_sub_message&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="n">msg1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">swap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">msg2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln">6&lt;/span>&lt;span class="n">CHECK&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">msg1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">has_sub_message&lt;/span>&lt;span class="p">());&lt;/span>
&lt;span class="ln">7&lt;/span>&lt;span class="n">CHECK&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">msg2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">has_name&lt;/span>&lt;span class="p">());&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h3 id="向后兼容的问题">向后兼容的问题&lt;/h3>
&lt;p>新增或者移除&lt;code>oneof&lt;/code>字段的是要小心 - 在检查&lt;code>oneof&lt;/code>的成员是否被赋值的时候返回&lt;code>None/NOT_SET&lt;/code>，这可能意味着&lt;code>oneof&lt;/code>成员没有被赋值或者某个成员的赋值是基于不同版本的&lt;code>oneof&lt;/code>字段。这其中的区别无从得知，因为无法确定未知字段是否是&lt;code>oneof&lt;/code>的成员。&lt;/p>
&lt;p>&lt;strong>标签复用问题：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>从&lt;code>oneof&lt;/code>中移出成员或者添加成员到&lt;code>oneof&lt;/code>&lt;/strong>：在消息序列化和解析后，你可能会丢失一些信息（比如一些字段被清空）。但是你可以安全的把一个字段移到一个新的&lt;code>oneof&lt;/code>里，或者把多个字段移到也可以，前提是你知道只能有一个字段被赋值&lt;/li>
&lt;li>**删除一个成员或者重新添加回去：**这个可能会知道消息序列化和解析后成员的赋值丢失&lt;/li>
&lt;li>**分离或者合并&lt;code>oneof&lt;/code>成员：**这和移动常规的字段有一样的问题&lt;/li>
&lt;/ul>
&lt;h2 id="maps">Maps&lt;/h2>
&lt;p>如果你希望在你的数据定义中创建&lt;code>map&lt;/code>，protocol buffer提供了一个方便的语法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="n">map&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">key_type&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">value_type&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="n">map_field&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>key_type&lt;/code>可以是任何整型或者字符串类型（也就是说除了浮点和&lt;code>bytes&lt;/code>之外的标量类型）。因此，如果你希望创建一个键为字符串类型值为&lt;code>Project&lt;/code>消息的&lt;code>map&lt;/code>，你可以定义如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="n">map&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">Project&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="n">projects&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>map&lt;/code>类型的字段是不可以定义为&lt;code>repeated&lt;/code>&lt;/li>
&lt;li>Wire格式的顺序不固定，迭代&lt;code>map&lt;/code>也是无序的，因此你不能依赖&lt;code>map&lt;/code>为你提供有序的成员&lt;/li>
&lt;li>为&lt;code>.proto&lt;/code>生成text格式的时候，&lt;code>maps&lt;/code>是按照键排序的。数值类型的键是根据数值排序（&lt;em>这是啥意思，是不是和编码有关系？&lt;/em>）&lt;/li>
&lt;li>如果你只给定了一个键，对应的值没有赋值，这种情况在序列化的时候不同的语言有不同的行为 - C++，Java，Kotlin和Python中会用默认值来序列化，其他语言中这种情况不会被序列化&lt;/li>
&lt;/ul>
&lt;p>访问&lt;code>map&lt;/code>的API目前已对&lt;code>proto3&lt;/code>支持。你可以从 &lt;a href="https://developers.google.com/protocol-buffers/docs/reference/overview">API reference&lt;/a>中查找特定语言相关的说明。&lt;/p>
&lt;h3 id="向后兼容">向后兼容&lt;/h3>
&lt;p>&lt;code>map&lt;/code>的语法和下面的定义等价，因此对那些不支持&lt;code>map&lt;/code>的protocol buffer实现依然可以处理你的数据。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">MapFieldEntry&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">key_type&lt;/span> &lt;span class="n">key&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">value_type&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">4&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">5&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">6&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">repeated&lt;/span> &lt;span class="n">MapFieldEntry&lt;/span> &lt;span class="n">map_field&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>任何支持&lt;code>map&lt;/code>的protocol buffer的实现必须能够基于上面的定义生成和接受数据。&lt;/p>
&lt;h2 id="包">包&lt;/h2>
&lt;p>你可以在&lt;code>.proto&lt;/code>中添加一个可选的&lt;code>package&lt;/code>指示符，这样可以防止不同的消息类型间名字冲突。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="kn">package&lt;/span> &lt;span class="nn">foo&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">bar&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">Open&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="o">...&lt;/span> &lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>你可以在定义你的消息类型的时候使用&lt;code>package&lt;/code>指示符：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">Foo&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="o">...&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">foo.bar.Open&lt;/span> &lt;span class="n">open&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">4&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="o">...&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">5&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>package&lt;/code>指示符是如何起作用的，这个取决于你选择的编程语言：&lt;/p>
&lt;ul>
&lt;li>**C++**中，生成的类被包含在C++命名空间里。例如，&lt;code>Open&lt;/code>会在命名空间&lt;code>foo::bar&lt;/code>里&lt;/li>
&lt;li>&lt;strong>Java&lt;/strong>和&lt;strong>Kotlin&lt;/strong>中，&lt;code>package&lt;/code>和Java的包一样，除非你自己显式的在&lt;code>.proto&lt;/code>里指定了&lt;code>option java_package&lt;/code>&lt;/li>
&lt;li>&lt;strong>Python&lt;/strong>中，&lt;code>package&lt;/code>会被忽略，因为Python modules是按照文件位置来组织的&lt;/li>
&lt;li>&lt;strong>Go&lt;/strong>中，&lt;code>package&lt;/code>和Go的包一样，除非你自己显式的在&lt;code>.proto&lt;/code>里指定了&lt;code>option go_package&lt;/code>&lt;/li>
&lt;li>**C#**中，&lt;code>package&lt;/code>的名称先被转变成PascalCase作为命名空间的名称，除非你自己显式的在&lt;code>.proto&lt;/code>里指定了&lt;code>option csharp_namespace&lt;/code>。例如，&lt;code>Open&lt;/code>会放在命名空间&lt;code>Foo.Bar&lt;/code>下&lt;/li>
&lt;/ul>
&lt;h3 id="包和名字解析">包和名字解析&lt;/h3>
&lt;p>在protocol buffer中类型名称的解析就跟C++中类似：从最内部的范围里查找，然后次之以此类推（任何一个包都被当成父包的内部包）。'.'意味着从最外层开始（比如：&lt;code>.foo.bar.Baz&lt;/code>）&lt;/p>
&lt;p>protocol buffer编译器通过解析导入的&lt;code>.proto&lt;/code>文件来解析所有的类型名称。即使不同语言有不同的范围规则，不同语言的代码生成器知道如何找到特定的类型。&lt;/p>
&lt;h2 id="定义服务">定义服务&lt;/h2>
&lt;p>如果你希望在你的RPC服务中使用你定义的消息，你可以在&lt;code>.proto&lt;/code>文件中定义RPC服务接口，而后protocol buffer会生成特定语言的服务接口代码和mock实现。因此，假如你需要定义个RPC服务的方法接受&lt;code>SearchRequest&lt;/code>参数返回&lt;code>SearchResponse&lt;/code>，你可以按如下方式定义：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="kd">service&lt;/span> &lt;span class="n">SearchService&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="k">rpc&lt;/span> &lt;span class="n">Search&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">SearchRequest&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">returns&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">SearchResponse&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://grpc.io/">gRPC&lt;/a>是最直接使用protocol buffer的RPC系统：Google开发的一个语言和平台中立的开源的RPC系统。gRPC能非常好的和protocol buffer工作，使用一个特殊的protocol buffer插件能完美的生成gRPC代码。&lt;/p>
&lt;p>如果你不使用gRPC，也是可以在你自己的RPC实现中使用protocol buffers，你可以参考：&lt;a href="https://developers.google.com/protocol-buffers/docs/proto#services">Proto2 Language Guide&lt;/a>&lt;/p>
&lt;p>有许多基于protocol buffers的RPC项目正在开发中，这里有一个我们所知道的项目的列表：&lt;a href="https://github.com/protocolbuffers/protobuf/blob/master/docs/third_party.md">third-party add-ons wiki page&lt;/a>&lt;/p>
&lt;h2 id="json-mapping">Json Mapping&lt;/h2>
&lt;p>&lt;code>proto3&lt;/code>支持通用的Json编码，这使得它可以很方便地跨系统共享数据。如下表所示，Json编译是按照&lt;code>type-by-type&lt;/code>的方式进行。&lt;/p>
&lt;p>如果在Json编码的数据中缺少值，或者值是&lt;code>null&lt;/code>，那么在解析成protocol buffre数据的时候将被解释成默认值。如果protocol buffer编码的字段的值是对应类型的默认值，那么编码成Json的时候，为了节省空间这些值会被忽略。一种实现或许可以提供选项给用户使得把默认值也包括在Json编码的数据中。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">proto3&lt;/th>
&lt;th style="text-align:left">JSON&lt;/th>
&lt;th style="text-align:left">JSON example&lt;/th>
&lt;th style="text-align:left">Notes&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">message&lt;/td>
&lt;td style="text-align:left">object&lt;/td>
&lt;td style="text-align:left">&lt;code>{&amp;quot;fooBar&amp;quot;: v, &amp;quot;g&amp;quot;: null, …}&lt;/code>&lt;/td>
&lt;td style="text-align:left">Generates JSON objects. Message field names are mapped to lowerCamelCase and become JSON object keys. If the &lt;code>json_name&lt;/code> field option is specified, the specified value will be used as the key instead. Parsers accept both the lowerCamelCase name (or the one specified by the &lt;code>json_name&lt;/code> option) and the original proto field name. &lt;code>null&lt;/code> is an accepted value for all field types and treated as the default value of the corresponding field type.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">enum&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">&lt;code>&amp;quot;FOO_BAR&amp;quot;&lt;/code>&lt;/td>
&lt;td style="text-align:left">The name of the enum value as specified in proto is used. Parsers accept both enum names and integer values.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">map&amp;lt;K,V&amp;gt;&lt;/td>
&lt;td style="text-align:left">object&lt;/td>
&lt;td style="text-align:left">&lt;code>{&amp;quot;k&amp;quot;: v, …}&lt;/code>&lt;/td>
&lt;td style="text-align:left">All keys are converted to strings.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">repeated V&lt;/td>
&lt;td style="text-align:left">array&lt;/td>
&lt;td style="text-align:left">&lt;code>[v, …]&lt;/code>&lt;/td>
&lt;td style="text-align:left">&lt;code>null&lt;/code> is accepted as the empty list &lt;code>[]&lt;/code>.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">bool&lt;/td>
&lt;td style="text-align:left">true, false&lt;/td>
&lt;td style="text-align:left">&lt;code>true, false&lt;/code>&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">&lt;code>&amp;quot;Hello World!&amp;quot;&lt;/code>&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">bytes&lt;/td>
&lt;td style="text-align:left">base64 string&lt;/td>
&lt;td style="text-align:left">&lt;code>&amp;quot;YWJjMTIzIT8kKiYoKSctPUB+&amp;quot;&lt;/code>&lt;/td>
&lt;td style="text-align:left">JSON value will be the data encoded as a string using standard base64 encoding with paddings. Either standard or URL-safe base64 encoding with/without paddings are accepted.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">int32, fixed32, uint32&lt;/td>
&lt;td style="text-align:left">number&lt;/td>
&lt;td style="text-align:left">&lt;code>1, -10, 0&lt;/code>&lt;/td>
&lt;td style="text-align:left">JSON value will be a decimal number. Either numbers or strings are accepted.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">int64, fixed64, uint64&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">&lt;code>&amp;quot;1&amp;quot;, &amp;quot;-10&amp;quot;&lt;/code>&lt;/td>
&lt;td style="text-align:left">JSON value will be a decimal string. Either numbers or strings are accepted.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">float, double&lt;/td>
&lt;td style="text-align:left">number&lt;/td>
&lt;td style="text-align:left">&lt;code>1.1, -10.0, 0, &amp;quot;NaN&amp;quot;, &amp;quot;Infinity&amp;quot;&lt;/code>&lt;/td>
&lt;td style="text-align:left">JSON value will be a number or one of the special string values &amp;quot;NaN&amp;quot;, &amp;quot;Infinity&amp;quot;, and &amp;quot;-Infinity&amp;quot;. Either numbers or strings are accepted. Exponent notation is also accepted. -0 is considered equivalent to 0.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">Any&lt;/td>
&lt;td style="text-align:left">&lt;code>object&lt;/code>&lt;/td>
&lt;td style="text-align:left">&lt;code>{&amp;quot;@type&amp;quot;: &amp;quot;url&amp;quot;, &amp;quot;f&amp;quot;: v, … }&lt;/code>&lt;/td>
&lt;td style="text-align:left">If the Any contains a value that has a special JSON mapping, it will be converted as follows: &lt;code>{&amp;quot;@type&amp;quot;: xxx, &amp;quot;value&amp;quot;: yyy}&lt;/code>. Otherwise, the value will be converted into a JSON object, and the &lt;code>&amp;quot;@type&amp;quot;&lt;/code> field will be inserted to indicate the actual data type.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">Timestamp&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">&lt;code>&amp;quot;1972-01-01T10:00:20.021Z&amp;quot;&lt;/code>&lt;/td>
&lt;td style="text-align:left">Uses RFC 3339, where generated output will always be Z-normalized and uses 0, 3, 6 or 9 fractional digits. Offsets other than &amp;quot;Z&amp;quot; are also accepted.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">Duration&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">&lt;code>&amp;quot;1.000340012s&amp;quot;, &amp;quot;1s&amp;quot;&lt;/code>&lt;/td>
&lt;td style="text-align:left">Generated output always contains 0, 3, 6, or 9 fractional digits, depending on required precision, followed by the suffix &amp;quot;s&amp;quot;. Accepted are any fractional digits (also none) as long as they fit into nano-seconds precision and the suffix &amp;quot;s&amp;quot; is required.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">Struct&lt;/td>
&lt;td style="text-align:left">&lt;code>object&lt;/code>&lt;/td>
&lt;td style="text-align:left">&lt;code>{ … }&lt;/code>&lt;/td>
&lt;td style="text-align:left">Any JSON object. See &lt;code>struct.proto&lt;/code>.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">Wrapper types&lt;/td>
&lt;td style="text-align:left">various types&lt;/td>
&lt;td style="text-align:left">&lt;code>2, &amp;quot;2&amp;quot;, &amp;quot;foo&amp;quot;, true, &amp;quot;true&amp;quot;, null, 0, …&lt;/code>&lt;/td>
&lt;td style="text-align:left">Wrappers use the same representation in JSON as the wrapped primitive type, except that &lt;code>null&lt;/code> is allowed and preserved during data conversion and transfer.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">FieldMask&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">&lt;code>&amp;quot;f.fooBar,h&amp;quot;&lt;/code>&lt;/td>
&lt;td style="text-align:left">See &lt;code>field_mask.proto&lt;/code>.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">ListValue&lt;/td>
&lt;td style="text-align:left">array&lt;/td>
&lt;td style="text-align:left">&lt;code>[foo, bar, …]&lt;/code>&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">Value&lt;/td>
&lt;td style="text-align:left">value&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;td style="text-align:left">Any JSON value. Check &lt;a href="https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.Value">google.protobuf.Value&lt;/a> for details.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">NullValue&lt;/td>
&lt;td style="text-align:left">null&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;td style="text-align:left">JSON null&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">Empty&lt;/td>
&lt;td style="text-align:left">object&lt;/td>
&lt;td style="text-align:left">&lt;code>{}&lt;/code>&lt;/td>
&lt;td style="text-align:left">An empty JSON object&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="json-选项">JSON 选项&lt;/h3>
&lt;p>&lt;code>proto3&lt;/code>的JSON实现可能提供以下选项（&lt;em>这下面说的选项原文也没有说明是什么以及怎么使用&lt;/em>）：&lt;/p>
&lt;ul>
&lt;li>**包含默认值在JSON编码中：**默认情况下，具有默认值的字段在编码成JSON的时候其值被忽略。一种实现或许可以提供一个选项来覆盖这种默认行为使得把默认值包含进去&lt;/li>
&lt;li>**忽略未知字段：**Proto3 JSON解析器默认会拒绝未知的字段，但是可能可以提供一个选项在解析的时候忽略未知字段&lt;/li>
&lt;li>**使用字段名称来代替lowerCamelCase格式的：**默认情况，proto3 JSON printer会把字段名称转换为lowerCamelCase格式作为Json名称。一种实现可能可以提供一个选项来直接使用字段名称作为Json名称。proto3 JSON解析器应该都要接受字段名称和lowerCamelCase格式的名称&lt;/li>
&lt;li>**把枚举解释成值而不是枚举项：**默认情况下，枚举项被解释成Json。一种实现可能可以提供一个选项来直接使用枚举值还是枚举项（枚举项就是枚举名称，枚举值就是枚举项对应的数值）&lt;/li>
&lt;/ul>
&lt;h2 id="选项option">选项option&lt;/h2>
&lt;p>&lt;code>.proto&lt;/code>文件中的声明可以用一些列的&lt;code>option&lt;/code>来标记。&lt;code>option&lt;/code>不会改变这些声明的整体的含义，但是可能会按照某种方式影响这些声明被处理的方式。完整可用的&lt;code>option&lt;/code>是定义在&lt;code>google/protobuf/descriptor.proto&lt;/code>中。&lt;/p>
&lt;p>有些&lt;code>option&lt;/code>是文件级别的，意味着他们应该放在作用范围的顶层而不是放在任何一个消息、枚举或者服务的定义里。有些&lt;code>option&lt;/code>是消息级别的，意味着这些应该放在消息里面。有些则是字段级别的，应该放在字段的定义里。除此之外，还可以放在&lt;code>enum&lt;/code>类型、&lt;code>enum&lt;/code>值、&lt;code>oneof&lt;/code>字段、服务类型和服务方法里，只是目前还有有用的&lt;code>option&lt;/code>作用这以上这些（那原文说这个干啥？！）。&lt;/p>
&lt;p>&lt;em>（原文中列举了一些最重要的&lt;code>option&lt;/code>适用于Java，C++等我不使用的语言我就没有放进来，偷个懒省点翻译的时间）&lt;/em>&lt;/p>
&lt;h3 id="自定义option">自定义Option&lt;/h3>
&lt;p>Protocol Buffers允许你自定义选项然后使用。这是一个大多数人都不需要用到的&lt;strong>高级选项&lt;/strong>。如果你确实觉得你需要这些自定义选项，你可以参考&lt;a href="https://developers.google.com/protocol-buffers/docs/proto#customoptions">Proto2 Language Guide&lt;/a>。注意，创建自定义选项需要扩展&lt;a href="https://developers.google.com/protocol-buffers/docs/proto#extensions">extensions&lt;/a>的支持，这些扩展只能用于在&lt;code>proto3&lt;/code>中自定义选项。&lt;/p>
&lt;h2 id="生成你的类">生成你的类&lt;/h2>
&lt;p>你需要运行Protocol buffer编译器&lt;code>.protoc&lt;/code>来编译你的&lt;code>.proto&lt;/code>文件来生成和消息交互的Java/Kotlin/Python/C++/Go/Ruby/Objective-C/C# 代码。如果你还没哟uanzhuang编译器，&lt;a href="https://developers.google.com/protocol-buffers/docs/downloads">请先下载&lt;/a>然后参考README的说明来安装。对Go语言，你需要安装一个特定的代码生成器插件：你可以从&lt;a href="https://github.com/golang/protobuf/">golang/protobuf&lt;/a> 找到这个插件以及这个插件的安装说明。&lt;/p>
&lt;p>Protocol编译器是按照以下的方式来调用：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="n">protoc&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="n">proto_path&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">IMPORT_PATH&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="n">cpp_out&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">DST_DIR&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="n">java_out&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">DST_DIR&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="n">python_out&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">DST_DIR&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="n">go_out&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">DST_DIR&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="n">ruby_out&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">DST_DIR&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="n">objc_out&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">DST_DIR&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="n">csharp_out&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">DST_DIR&lt;/span> &lt;span class="n">path&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="k">to&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">file.proto&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>&lt;code>IMPORT_PATH&lt;/code>指定了从什么位置导入&lt;code>.proto&lt;/code>文件。如果没有指定，默认从当前位置导入。如果有多个导入位置，可以多次指定&lt;code>--proto_path&lt;/code>并设置路径，这些路径将被按顺序查找和导入。&lt;code>-I=_IMPORT_PATH_&lt;/code>是&lt;code>--proto_path&lt;/code>的简短形式。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>你可以提供以下一个或者多个导出目录（这里我只列举了生成Go语言的目录，其他语言请参考原文）&lt;/p>
&lt;ul>
&lt;li>&lt;code>--go_out&lt;/code>指定生成Go代码于&lt;code>DST_DIR&lt;/code>目录。更多细节请参考&lt;a href="https://developers.google.com/protocol-buffers/docs/reference/go-generated">Go generated code reference&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>你必须指定一个或者多个&lt;code>.proto&lt;/code>文件作为输入。可以同时指定多个&lt;code>.proto&lt;/code>文件，前提是这些文件都位于&lt;code>IMPORT_PATH&lt;/code>，这样编译器才能根据名字找到这些文件。&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>C Primer Plus读书笔记（一）</title><link>https://www.jonathanlin.top/posts/c-primer-plus-notes-01/</link><pubDate>Mon, 05 Jul 2021 19:41:09 +0800</pubDate><guid>https://www.jonathanlin.top/posts/c-primer-plus-notes-01/</guid><description>
&lt;p>&lt;em>本文是《C Primer Plus》第三章至第五章读书笔记。&lt;/em>&lt;/p>
&lt;h2 id="ch03-数据和c">ch03. 数据和C&lt;/h2>
&lt;blockquote>
&lt;p>思考问题：&lt;/p>
&lt;ol>
&lt;li>各种类型的数据占用多少空间&lt;/li>
&lt;li>各种类型的数据是如何格式化输出的&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;ul>
&lt;li>一般而言，存储int需要占用一个机器字长&lt;/li>
&lt;li>C语言中的byte不是8个bit，而是和一个char占用的位长一样&lt;/li>
&lt;li>char根据编译器不同，可能被处理成有符号也可能被处理成无符号。具体可以查看头文件limits.h&lt;/li>
&lt;li>整数类型一般都被存储为int类型，当超过int最大范围，编译器会自动将其视为高一个等级的类型，直到越界&lt;/li>
&lt;li>2^16 = 65536 / 2^8 = 256&lt;/li>
&lt;li>浮点数的存储：有效数和指数部分（包括符号），3.16e^7，有效数部分就是3.16&lt;/li>
&lt;li>float至少能表示6位有效数字，double至少能表示10位有效数字&lt;/li>
&lt;li>表达式中，float会自动转化成double&lt;/li>
&lt;li>浮点数和整型数在计算机内部，虽然都是二进制表示，但是二进制的表示形式不一样，浮点数是把有效数字和指数部分分别表示。因此，在处理浮点数和整型的时候，计算机会做自动的转换，这个很危险&lt;/li>
&lt;/ul>
&lt;h2 id="ch04-字符串和格式化输入输出">ch04. 字符串和格式化输入/输出&lt;/h2>
&lt;blockquote>
&lt;p>思考问题：&lt;/p>
&lt;ol>
&lt;li>字符串是如何存取的&lt;/li>
&lt;li>字符串底层的数据结构是怎样的&lt;/li>
&lt;li>输入输出函数如何格式化&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>C语言中，没有专门的数据结构存放字符串。字符串是存放在char数组中，且数组的末尾是存放占位符'\0'，这个占位符是自动添加到数组末尾&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用scanf读取字符串的时候，&lt;strong>输入空格则停止读取&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用scanf读取字符串的时候，变量不需要通过&amp;amp;取地址（因为字符数组本身就是一个指针？？）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&amp;quot;x&amp;quot;和'x'的区别：前者是char数组，实际占用两个字符，后者是char类型，一个字符&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sizeof - 字节长度 / strlen - 字符串长度&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用sizeof计算字符串，会把结束字符（空字符'\0'）也算进去得到总共占用的字节数；而strlen计算字符串长度的时候，不会把末尾的结束字符计算进去&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sizeof结果返回size_t类型，一个无符号整型&lt;/p>
&lt;/li>
&lt;li>
&lt;p>limits.h和float.h中分别定义了各种类型的最大值和最小值，这个会由于操作系统以及其字长的不同而不同&lt;/p>
&lt;/li>
&lt;li>
&lt;p>#define NAME value - 使用预处理器定义了一个明示常量，通常用大写来命名；const定义的实际是变量，可读变量&lt;/p>
&lt;/li>
&lt;li>
&lt;p>printf&lt;em>&lt;strong>转换说明：把以二进制格式存储在计算机中的值转换成一系列字符串然后打印&lt;/strong>&lt;/em>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>转换如果和底层的数据类型不匹配会发生很奇怪的事情，如下代码：&lt;/p>
&lt;ol>
&lt;li>n1是float类型，但是在存储的时候会自动转换成double，因此占用8个字节，但是&lt;code>%ld&lt;/code>导致在转换说明的时候，只读取了前4个字节&lt;/li>
&lt;li>以上，导致每一次&lt;code>%ld&lt;/code>的转换都发生错位，四次的&lt;code>%ld&lt;/code>仅读取了16个字节，但是&lt;code>n1&lt;/code>到&lt;code>n4&lt;/code>一共占用了24个字节&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="ln">1&lt;/span>&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%ld %ld %ld %ld&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n4&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jonlimx/blogs/image/printf-incompatiable.png" alt="转换不匹配">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>格式化字符串转换说明 （关于转换说明符修饰符P71）&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>转换说明&lt;/th>
&lt;th>输出&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>%a %A&lt;/td>
&lt;td>浮点数、十六进制数和p记数法&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%c&lt;/td>
&lt;td>单个字符&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%d&lt;/td>
&lt;td>有符号十进制整数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%e %E&lt;/td>
&lt;td>浮点数，e&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%f&lt;/td>
&lt;td>浮点数，十进制记数法&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%g %G&lt;/td>
&lt;td>根据值的不同，自动选择%f或%e。%e格式用于指数小于-4或者大于或等于精度时&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%i&lt;/td>
&lt;td>有符号十进制整数（与%d相同）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%o&lt;/td>
&lt;td>无符号八进制整数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%p&lt;/td>
&lt;td>指针&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%s&lt;/td>
&lt;td>字符串&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%u&lt;/td>
&lt;td>无符号十进制整数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%x&lt;/td>
&lt;td>无符号十六进制整数，使用十六进制数0f&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%X&lt;/td>
&lt;td>无符号十六进制整数，使用十六进制数0F&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%%&lt;/td>
&lt;td>打印一个百分号&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%zd&lt;/td>
&lt;td>打印size_t类型&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;li>
&lt;p>scanf与printf正好相反，从键盘输入的都是字符串，scanf通过制定数据类型然后将字符串转换成对应的数据类型。注意：&lt;strong>除了字符串类型及char数组，其他所有的类型都要通过指针来接收值&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>scanf通过空格或者回车将输入分割成多个字段（%c是例外，也会把空字符作为输入存储）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>*修饰符&lt;/p>
&lt;ul>
&lt;li>
&lt;p>对于printf而言，*修饰符用于代替字段。如下面代码所示，*修饰符用与替换width和precision表示宽度和精度&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于scanf而言，把*放在%和转换字符之间，则会跳过相应的输入项。下面代码所示，scanf跳过了第一个和第二个输入，把第三个输入赋值给n&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="ln"> 1&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="n">width&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">precision&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">number&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">256&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="kt">double&lt;/span> &lt;span class="n">weight&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">242.5&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%*d&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">width&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">number&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%*.*f&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">width&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">precision&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">weight&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln"> 7&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="n">scanf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%*d %*d %d&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="ln">11&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">13&lt;/span>
&lt;span class="ln">14&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="ch05-运算符表达符和语句">ch05. 运算符、表达符和语句&lt;/h2>
&lt;blockquote>
&lt;p>思考问题：&lt;/p>
&lt;ol>
&lt;li>C语言中有哪些运算符和表达符，运算符的优先级是怎么样的&lt;/li>
&lt;li>C语言中有哪些特殊的语句&lt;/li>
&lt;li>自动类型转换和强制类型转换&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>赋值表达式的目的是把值存储到内存位置上&lt;/p>
&lt;/li>
&lt;li>
&lt;p>浮点数除法的结果是浮点数，整数除法的结果是整数（小数部分直接被截断，不会四舍五入 ），整数和浮点数的除法是浮点数&lt;/p>
&lt;/li>
&lt;li>
&lt;p>运算符优先级&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>运算符&lt;/th>
&lt;th>结合律 - 运算符符合与运算对象结合&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>（）&lt;/td>
&lt;td>从左到右&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>+ - （一元）++ -- sizeof&lt;/td>
&lt;td>从右到左&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>* / %&lt;/td>
&lt;td>从左到右&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>+ - （二元）&lt;/td>
&lt;td>从左到右&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;lt; &amp;gt; &amp;lt;= &amp;gt;=&lt;/td>
&lt;td>从左到右&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>== !=&lt;/td>
&lt;td>从左到右&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>=&lt;/td>
&lt;td>从右到左&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>上表结合律只适用于共享同一运算对象的运算符&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>6*3 + 4*5 - 可以肯定*优先级比+高，但是这例子中，6*3和4*5的运算先后顺序不确定，不同硬件平台可能顺序不一样（&lt;em>发生指令重排？？&lt;/em>）&lt;/li>
&lt;li>12/3*2 - 这个例子中，/和*的优先级一样，但是3是共享运算对象，因此遵循结合律从左到右，所以先算12/3，然后4*2&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>求模运算只能用于整数，不能用于浮点数&lt;/p>
&lt;/li>
&lt;li>
&lt;p>a%b &amp;lt;=&amp;gt; a - (a/b)*b&lt;/p>
&lt;/li>
&lt;li>
&lt;p>自增和自减运算符 ++/--&lt;/p>
&lt;ul>
&lt;li>前缀模式：&lt;strong>先完成自增或者自减&lt;/strong>，然后再用结果参与同一语句中的其他运算&lt;/li>
&lt;li>后缀模式：先完成同一语句的其他预算，&lt;strong>然后再完成自增或者自减&lt;/strong>&lt;/li>
&lt;li>如果只是单独使用，也就是不和其他运算对象以及运算符一起的时候，前缀和后缀模式都没有区别，就是要完成自增或者自减&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>下面两种情况不要使用自增后者自减（由于可能指令重排导致计算没有按预期的顺序进行）&lt;/p>
&lt;ul>
&lt;li>一个变量出现在一个函数的多个参数中，那么不要对该变量使用自增或者自减&lt;/li>
&lt;li>一个变量多次出现表达式中，那么不要对该变量使用自增或者自减 - ans = num/2 + 5*(1+num++)，&lt;em>这里可能因为指令重排导致num++先算，那么前面的num/2就和预期不一样了&lt;/em>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>序列点：程序执行的点，在一个语句中，赋值运算符、自增自减运算符对运算对象做的改变必须在程序执行下一条语句之前完成&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>自动类型转换（&lt;strong>通常应该要避免&lt;/strong>）：&lt;/p>
&lt;ul>
&lt;li>升级：较小类型转换成较大类型&lt;/li>
&lt;li>降级：较大类型转换成较小类型 - &lt;strong>这种情况可能会发生数据截断&lt;/strong>&lt;/li>
&lt;li>升级发生在表达式中运算对象数据类型不同，这时候发生自动自动类型转换。运算结束后，会根据目标类型可能会发生降级，这时候可能就会发生数据截断&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>强制类型转换：(type)variable&lt;/p>
&lt;/li>
&lt;li>
&lt;p>实参和形参&lt;/p>
&lt;ul>
&lt;li>实参 argument - 调用函数时传递给形参的实际的值&lt;/li>
&lt;li>形参 parameter - 函数签名上定义的变量&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>引用书中关于自动类型转换的一段：&lt;/p>
&lt;p>在C语言中，许多类型转换都是自动进行的。当&lt;code>char&lt;/code>和&lt;code>short&lt;/code>类型出现在表达式里或者作为函数的参数（函数原型除外）时，都会被升级为&lt;code>int&lt;/code>类型；当&lt;code>float&lt;/code>类型在函数参数中时，会被升级为&lt;code>double&lt;/code>类型&lt;/p>
&lt;p>当把一种值赋给另一种类型的变量时，值将被转换成与变量的类型相同&lt;/p>
&lt;p>当把较大类型转换成较小类型时，可能会丢失数据&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>函数声明 - 在调用函数的时候，编译器首先需要知道函数的返回类型，所以需要先声明函数，至于函数的实现可以放在后面&lt;/li>
&lt;/ul></description></item><item><title>[译]Protocol Buffer Basics Go</title><link>https://www.jonathanlin.top/posts/protocol-buffer-basics-go/</link><pubDate>Thu, 01 Jul 2021 13:54:58 +0800</pubDate><guid>https://www.jonathanlin.top/posts/protocol-buffer-basics-go/</guid><description>
&lt;p>原文链接：&lt;a href="https://developers.google.com/protocol-buffers/docs/gotutorial">Protocol Buffer Basics: Go | Protocol Buffers | Google Developers&lt;/a>&lt;/p>
&lt;p>本教程使用proto3语言为Go程序员介绍了protocol buffers的基本使用。通过一步步创建一个简单的示例应用，你将会了解到：&lt;/p>
&lt;ul>
&lt;li>在&lt;code>.proto&lt;/code>文件中定义消息格式&lt;/li>
&lt;li>使用protocol buffer编译器&lt;/li>
&lt;li>使用Go protocol buffer API读写消息&lt;/li>
&lt;/ul>
&lt;p>这不是一个使用protocol buffers的完全手册。更多更细节的信息，请参看：&lt;a href="https://developers.google.com/protocol-buffers/docs/proto3">Language Guide (proto3)&lt;/a>、&lt;a href="https://pkg.go.dev/google.golang.org/protobuf/proto">Go API Reference&lt;/a>、&lt;a href="https://developers.google.com/protocol-buffers/docs/reference/go-generated">Go Generated Code&lt;/a>和&lt;a href="https://developers.google.com/protocol-buffers/docs/encoding">Encoding Reference&lt;/a>&lt;/p>
&lt;h2 id="为什么使用protocol-buffers">为什么使用protocol buffers？&lt;/h2>
&lt;p>我们将要创建一个简单的“地址簿”应用，该应用可以从文件中读和写联系人的信息。地址簿中的每一个联系人有名字，ID和联系电话。&lt;/p>
&lt;p>你如何序列化和读取这种结构化数据？有这么几种方式可以解决这个问题：&lt;/p>
&lt;ul>
&lt;li>使用&lt;a href="https://golang.org/pkg/encoding/gob/">gobs&lt;/a>序列化Go数据结构。对于Go语言本身而言，这是一个很好的方案，但是如果你需要跨语言平台共享数据，那这种方式并不好&lt;/li>
&lt;li>按照你期望的方式把数据编码成单一的字符串，例如4个int类型的数据编码成“12:3:-23:67”。这是一个简单且灵活的办法，但这要求你编写一次性的编码和转换的代码，同时转化代码会带来一定的运行时消耗。对于比较简单的数据，使用这种方式就比较好&lt;/li>
&lt;li>将数据序列化成XML。XML对人类可读友好且各种语言都有对应的解析工具使得该方法有点吸引人。XML也能比较好的跨应用/项目共享数据。然而，众所周知，XML占用空间比较大，并且解析XML往往比较耗性能。此外，定位XML DOM树通常比直接访问类字段要复杂的多&lt;/li>
&lt;/ul>
&lt;p>Protocol buffers具有灵活、高效、自动化等特点可以解决上述问题。使用Protocol buffer，你需要把数据结构的描述定义在&lt;code>.proto&lt;/code>文件中，然后protocol buffer编译器会为你生成一个类，这个类实现了对protocol buffer二进制数据的编码和解析。这个类提供了对各个字段的getter和setter方法用于读写。protocol buffer很重要的一点是，如果将来数据格式扩展了，那么代码中依然可以读取由旧的格式编码的数据。&lt;/p>
&lt;h2 id="哪里找示例代码">哪里找示例代码&lt;/h2>
&lt;p>我们的例子是一系列的命令行程序，这些程序管理了由protocol buffers编码的地址簿数据文件。&lt;code>add_person_go&lt;/code>这个命令添加一条记录到数据文件。&lt;code>list_people_go&lt;/code>解析数据文件并把结果输出到控制台。&lt;/p>
&lt;p>你可以从Github Repo中找到完整的示例：&lt;a href="https://github.com/protocolbuffers/protobuf/tree/master/examples">protobuf/examples at master · protocolbuffers/protobuf (github.com)&lt;/a>&lt;/p>
&lt;h2 id="定义你的protocol格式">定义你的protocol格式&lt;/h2>
&lt;p>创建你的地址簿应用的第一步是定义你的&lt;code>.proto&lt;/code>文件。&lt;code>.proto&lt;/code>文件中的定义很简单：你为你想要序列化的每一个数据结构添加一个消息，然后为消息中的每个字段指定一个名称和对应的类型。在我们的例子中，在&lt;code>.proto&lt;/code>中定义的消息请参考&lt;a href="https://github.com/protocolbuffers/protobuf/blob/master/examples/addressbook.proto">addressbook.proto&lt;/a>。&lt;/p>
&lt;p>&lt;code>.proto&lt;/code>文件是从一个包声明开始的，包声明用来防止在不同项目中的名字冲突。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="n">syntax&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;proto3&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="kn">package&lt;/span> &lt;span class="nn">tutorial&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">4&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">import&lt;/span> &lt;span class="s">&amp;#34;google/protobuf/timestamp.proto&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>go_package&lt;/code>定义了代码生成所在的路径，包名即路径中的最后一个目录。例如，我们的例子的包名就是”tutorialpb“。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln">1&lt;/span>&lt;span class="k">option&lt;/span> &lt;span class="n">go_package&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;github.com/protocolbuffers/protobuf/examples/go/tutorialpb&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来，你就可以定义你的消息了。一个小时是包含一组含有类型的字段的集合。许多标准的简单值类型都是支持的，例如&lt;code>bool&lt;/code> 、&lt;code>int32&lt;/code>、 &lt;code>float&lt;/code>、 &lt;code>double&lt;/code> 和&lt;code>string&lt;/code>。你也可以包含其他消息在你要定义的消息里。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">Person&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="n">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">int32&lt;/span> &lt;span class="n">id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// Unique ID number for this person.
&lt;/span>&lt;span class="ln"> 4&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="n">email&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 5&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 6&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kd">enum&lt;/span> &lt;span class="n">PhoneType&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 7&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">MOBILE&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 8&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">HOME&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln"> 9&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">WORK&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">10&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">11&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">12&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kd">message&lt;/span> &lt;span class="nc">PhoneNumber&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">13&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="n">number&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">14&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">PhoneType&lt;/span> &lt;span class="n">type&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">15&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">16&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">17&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="k">repeated&lt;/span> &lt;span class="n">PhoneNumber&lt;/span> &lt;span class="n">phones&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">18&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">19&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="n">google.protobuf.Timestamp&lt;/span> &lt;span class="n">last_updated&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">20&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">21&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">22&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c1">// Our address book file is just one of these.
&lt;/span>&lt;span class="ln">23&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">AddressBook&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">24&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="k">repeated&lt;/span> &lt;span class="n">Person&lt;/span> &lt;span class="n">people&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="ln">25&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的例子中，&lt;code>Person&lt;/code>这个消息里包含了&lt;code>PhoneNumber&lt;/code>这个消息，&lt;code>AddressBook&lt;/code>这个消息包含了&lt;code>Person&lt;/code>这个消息。你甚至可以消息里定义另一个消息 - 正如你看到的，&lt;code>PhoneNumber&lt;/code>是定义在&lt;code>Person&lt;/code>里的。如果你希望你的取值是预先定义的一组值里的一个，那么你可以定义&lt;code>enum&lt;/code>类型 - 上面的例子中，你希望电话号码的类型是&lt;code>MOBILE&lt;/code>、 &lt;code>HOME&lt;/code>或者 &lt;code>WORK&lt;/code>。&lt;/p>
&lt;p>在每一个字段上诸如&amp;quot;= 1&amp;quot; &amp;quot;= 2&amp;quot;的标记是用于在二进制编码的时候对字段指定一个唯一的标记。相对于更高的标记号码而言，1 -15号在编码的时候占用的空间小于一个字节，因此一个有优化手段是你可以把经常会用到的字段或者重复类型的字段（例如数组）标记为1 - 15，把高于15的留给那些不怎么常用到的字段或者可选的字段。重复类型字段里的每一个元素都需要重新编码标记号码，因此重复类型的字段往往都会用到这种优化 。（&lt;em>&lt;strong>这块后面需要再理解一下是什么意思&lt;/strong>&lt;/em>）&lt;/p>
&lt;p>如果一个字段的值没有设置，那么将使用对应类型的&lt;a href="https://developers.google.com/protocol-buffers/docs/proto3#default">默认值&lt;/a>：数字类型的默认值是0，字符串默认值是空字符串，布尔类型的默认值是false。对于嵌套的消息，它的默认值是带有各个字段名的默认值。调用访问器（getter）去读取值的时候，如果对应的字段没有明确赋值，那么就返回对应的默认值。&lt;/p>
&lt;p>如果一个字段是重复类型，那么元素的个数可能是任意数目（包括0个）。元素的顺序在protocol buffer中是被保留下来的。可以想象重复类型字段是动态数组。&lt;/p>
&lt;p>你将在&lt;a href="https://developers.google.com/protocol-buffers/docs/proto3">Protocol Buffer Language Guide&lt;/a>中找到如何编写&lt;code>.proto&lt;/code>文件的完整教程（包括所有的类型）。至于类似于类继承这种机制就不要找了，protocol buffer不支持。&lt;/p>
&lt;h2 id="编译protocol-buffers">编译protocol buffers&lt;/h2>
&lt;p>现在你已经有&lt;code>.proto&lt;/code>文件了，接下来你需要基于这个文件去生成访问&lt;code>AddresBook&lt;/code>消息（&lt;code>Person&lt;/code>和&lt;code>PhoneNumber&lt;/code>也是）的类了。你将要使用protocol buffer编译器&lt;code>protoc&lt;/code>来编译你的&lt;code>.proto&lt;/code>文件：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>如果你还未安装编译器，请先&lt;a href="https://developers.google.com/protocol-buffers/docs/downloads">Download Protocol Buffers&lt;/a>，然后参考README进行安装&lt;/p>
&lt;/li>
&lt;li>
&lt;p>运行下面的命令安装Go protocol buffers plugin：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="ln">1&lt;/span>go get github.com/golang/protobuf/protoc-gen-go
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;p>编译器plugin &lt;code>protoc-gen-to&lt;/code>将被安装在&lt;code>$GOBIN&lt;/code>目录，该目录默认是在&lt;code>$GOPATH/bin&lt;/code>。这个目录必须包含在你的&lt;code>$PATH&lt;/code>中。&lt;/p>
&lt;ol start="3">
&lt;li>
&lt;p>现在你可以运行编译器，指定源目录（就是你的源文件所在的目录，如果没有指定就是指当前目录）和目标目录（生成的代码所在的目录）以及&lt;code>.proto&lt;/code>所在的目录。在我们的例子中，你应该运行下面命令：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="ln">1&lt;/span>protoc -I&lt;span class="o">=&lt;/span>&lt;span class="nv">$SRC_DIR&lt;/span> --go_out&lt;span class="o">=&lt;/span>&lt;span class="nv">$DST_DIR&lt;/span> &lt;span class="nv">$SRC_DIR&lt;/span>/addressbook.proto
&lt;/code>&lt;/pre>&lt;/div>&lt;p>由于你是需要生成Go代码，你应该使用&lt;code>--go-out&lt;/code>选项，其他语言则使用对应的选项。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>运行后，你将会在特定的目录看到生成的代码：&lt;code>github.com/protocolbuffers/protobuf/examples/go/tutorialpb/addressbook.pb.go&lt;/code>。&lt;/p>
&lt;h2 id="protocol-buffer-api">Protocol Buffer API&lt;/h2>
&lt;p>生成的&lt;code>addressbook.pb.go&lt;/code>提供了以下有用的类型：&lt;/p>
&lt;ul>
&lt;li>&lt;code>AddressBook&lt;/code>结构体包含了&lt;code>People&lt;/code>类型的字段&lt;/li>
&lt;li>&lt;code>Person&lt;/code>结构体包含了&lt;code>Name&lt;/code>、&lt;code>Id&lt;/code>、&lt;code>Email&lt;/code>和 &lt;code>Phones&lt;/code>字段&lt;/li>
&lt;li>&lt;code>Person_PhoneNumber&lt;/code>结构体包含了&lt;code>Number&lt;/code>和&lt;code>Type&lt;/code>字段&lt;/li>
&lt;li>&lt;code>Person_PhoneType&lt;/code>结构体和&lt;code>Person.PhoneType&lt;/code>枚举&lt;/li>
&lt;/ul>
&lt;p>你可以从&lt;a href="https://developers.google.com/protocol-buffers/docs/reference/go-generated">Go Generated Code guide&lt;/a>了解到代码生成的细节，对于大部分代码你只需要像对待Go类型一样。&lt;/p>
&lt;p>&lt;code>list_people&lt;/code>的单元测试&lt;a href="https://github.com/protocolbuffers/protobuf/blob/master/examples/list_people_test.go">command's unit tests&lt;/a>中展示了你应该如何创建&lt;code>Person&lt;/code>的实例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln">1&lt;/span>&lt;span class="nx">p&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">pb&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Person&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="nx">Id&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">1234&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="ln">3&lt;/span> &lt;span class="nx">Name&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s">&amp;#34;John Doe&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="ln">4&lt;/span> &lt;span class="nx">Email&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s">&amp;#34;jdoe@example.com&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="ln">5&lt;/span> &lt;span class="nx">Phones&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">pb&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Person_PhoneNumber&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="ln">6&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="nx">Number&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s">&amp;#34;555-4321&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">Type&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">pb&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Person_HOME&lt;/span>&lt;span class="p">},&lt;/span>
&lt;span class="ln">7&lt;/span> &lt;span class="p">},&lt;/span>
&lt;span class="ln">8&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="写消息">写消息&lt;/h2>
&lt;p>使用proptocol buffers的目的是序列化你的数据，而后能够在任何地方解析。Go语言中，你可以使用&lt;code>proto&lt;/code>库的&lt;a href="https://pkg.go.dev/google.golang.org/protobuf/proto?tab=doc#Marshal">Marshal&lt;/a>方法序列化你的protocol buffer数据。protocol buffer消息的指针类型实现了&lt;code>proto.Message&lt;/code>接口。调用&lt;code>proto.Marshal&lt;/code>返回序列化后的编码成wire格式的protocol buffer数据。例如，我们在&lt;a href="https://github.com/protocolbuffers/protobuf/blob/master/examples/add_person.go">&lt;code>add_person&lt;/code> command&lt;/a>中使用了这个方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln"> 1&lt;/span>&lt;span class="nx">book&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">pb&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">AddressBook&lt;/span>&lt;span class="p">{}&lt;/span>
&lt;span class="ln"> 2&lt;/span>&lt;span class="c1">// ...
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="c1">// Write the new address book back to disk.
&lt;/span>&lt;span class="ln"> 5&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="nx">out&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">proto&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Marshal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">book&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 6&lt;/span>&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="nx">log&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Fatalln&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Failed to encode address book:&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 8&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="ln"> 9&lt;/span>&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">ioutil&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">WriteFile&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">fname&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">out&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mo">0644&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="nx">log&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Fatalln&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Failed to write address book:&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">11&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="读数据">读数据&lt;/h2>
&lt;p>你可以使用&lt;code>proto&lt;/code>库中的&lt;a href="https://pkg.go.dev/google.golang.org/protobuf/proto?tab=doc#Unmarshal">Unmarshal&lt;/a>方法来解析编码过的数据。调用这个方法将&lt;code>buf&lt;/code>中的protocol buffer数据解析出来存放在&lt;code>pb&lt;/code>中。因此我们使用下面的代码在&lt;a href="https://github.com/protocolbuffers/protobuf/blob/master/examples/list_people.go">&lt;code>list_people&lt;/code> command&lt;/a>中进行解析：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="ln">1&lt;/span>&lt;span class="c1">// Read the existing address book.
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="nx">in&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">ioutil&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ReadFile&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">fname&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">4&lt;/span> &lt;span class="nx">log&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Fatalln&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Error reading file:&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="ln">6&lt;/span>&lt;span class="nx">book&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">pb&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">AddressBook&lt;/span>&lt;span class="p">{}&lt;/span>
&lt;span class="ln">7&lt;/span>&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">proto&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Unmarshal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">in&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">book&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">8&lt;/span> &lt;span class="nx">log&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Fatalln&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Failed to parse address book:&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">9&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="扩展protocol-buffer">扩展Protocol Buffer&lt;/h2>
&lt;p>在你使用protocol buffer的代码发布之后，或早或晚你总是希望改进你的protocol buffer定义。如果你希望你新的定义能向后兼容，且你的老的定义能向前兼容（你一定总是希望这样），那么你需要遵循一些规则。在新版本的protocol buffer中：&lt;/p>
&lt;ul>
&lt;li>你一定不能修改现在的字段的标签号码&lt;/li>
&lt;li>你可能会删除某些字段&lt;/li>
&lt;li>你可能会新增字段，但是新增的字段一定要使用全新的标签号码（一定是没有被使用过的，包括那些被删除的字段曾经使用过的）。&lt;/li>
&lt;/ul>
&lt;p>（使用这些规则有一些例外&lt;a href="https://developers.google.com/protocol-buffers/docs/proto3#updating">some exceptions&lt;/a>，但这些很少使用到）&lt;/p>
&lt;p>如果你遵循了这些规则，你会发现老代码也可以读取新的消息，只是会忽略新的字段。对于老代码，被删除的非数组字段会有它们的默认值，数组类型为空。新的代码可以透明的读取老的消息。&lt;/p>
&lt;p>需要注意的是，新的字段不会出现在老消息里，因此你需要添加合理的逻辑处理默认值&lt;a href="https://developers.google.com/protocol-buffers/docs/proto3#default">default value&lt;/a>。&lt;/p></description></item><item><title>使用Github Pages+Hugo搭建个人博客</title><link>https://www.jonathanlin.top/posts/how-to-setup-hugo-github-page/</link><pubDate>Wed, 30 Jun 2021 21:41:09 +0800</pubDate><guid>https://www.jonathanlin.top/posts/how-to-setup-hugo-github-page/</guid><description>
&lt;p>本文通过一些列的步骤，来介绍一下如何通过Github Pages和Hugo来搭建一个个人博客。&lt;/p>
&lt;h2 id="说明">说明&lt;/h2>
&lt;p>首先需要你要有一个github账号。我的一个思路是：把markdown源文件放在一个私有的repo下，然后通过hugo build出来的静态html放在另一个公开的repo下，这个过程可以通过Github Action来触发。基于此，我的博客源文件是在私有repo jonlimx/blogs-src里，博客本身是在公开repo jonlimx/blogs下，如下图所示：&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jonlimx/blogs/image/image-20210630232900924.png" alt="overview">&lt;/p>
&lt;p>所以，如果你想跟我一样，你需要事先建好一个&lt;strong>私有repo&lt;/strong>和一个&lt;strong>公开repo&lt;/strong>。下文中提到的jonlimx/blogs-src就是特指我的私有repo，jonlimx/blogs就是特指我的公开repo。&lt;/p>
&lt;p>此外，你最好对Hugo有一些基本的认识。你可以通过&lt;a href="https://gohugo.io/getting-started/quick-start/">Quick Start Hugo&lt;/a>来快速了解，&lt;strong>并且事先安装好hugo&lt;/strong>。&lt;/p>
&lt;h2 id="配置jonlimxblogs-src和github-action">配置jonlimx/blogs-src和Github Action&lt;/h2>
&lt;p>在github上创建好jonlimx/blogs-src之后，在本地创建一个名为blogs-src的文件夹（路径和名称可自行决定），然后初始化为hugo站点，最后和jonlimx/blogs-src关联即可。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="ln">1&lt;/span>hugo new site .
&lt;/code>&lt;/pre>&lt;/div>&lt;p>接着打开jonlimx/blogs-src，创建一个workflow &lt;strong>gh-pages.yml&lt;/strong>，完整内容如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="ln"> 1&lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">github pages&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">on&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln"> 4&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">push&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln"> 5&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">branches&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln"> 6&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">main &lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># Set a branch to deploy&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln"> 7&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">pull_request&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln"> 8&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln"> 9&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">jobs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln">10&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">deploy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln">11&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">runs-on&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ubuntu-20.04&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln">12&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">steps&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln">13&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">actions/checkout@v2&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln">14&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">with&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln">15&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">submodules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># Fetch Hugo themes (true OR recursive)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln">16&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">fetch-depth&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># Fetch all history for .GitInfo and .Lastmod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln">17&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln">18&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Setup Hugo&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln">19&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">peaceiris/actions-hugo@v2&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln">20&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">with&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln">21&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">hugo-version&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;latest&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln">22&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># extended: true&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln">23&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln">24&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Build&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln">25&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">run&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">hugo --minify&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln">26&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln">27&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Deploy&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln">28&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">peaceiris/actions-gh-pages@v3&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln">29&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">if&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">github.ref == &amp;#39;refs/heads/main&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln">30&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">with&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln">31&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">personal_token&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">${{ secrets.PERSONAL_TOKEN }}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln">32&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">external_repository&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">jonlimx/blogs&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln">33&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">publish_dir&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">./public&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln">34&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">cname&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">www.jonathanlin.top&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中，Deploy部分使用了&lt;a href="https://github.com/peaceiris/actions-gh-pages">peaceiris/actions-gh-pages&lt;/a>这个Action，配置的相应部分需要替换成你自己相应的内容，具体说明如下：&lt;/p>
&lt;ul>
&lt;li>personal_token: ${{ secrets.PERSONAL_TOKEN }} - 由于我是将jonlimx/blogs-src下的markdown源文件build出来的静态文件发布到jonlimx/blogs下，这种跨repo的发布，只能使用personal_token或者deploy_key。我这里使用的是personal_token。所以在&lt;a href="https://github.com/settings/tokens">Personal Access Tokens (github.com)&lt;/a>上生成一个personal_token，接着将这个token配置到jonlimx/blogs-src到Action secrets，最后使得workflow中能通过secrets.PERSONAL_TOKEN获取到这个token进而有权限发布到jonlimx/blogs。&lt;/li>
&lt;li>external_repository: jonlimx/blogs - 这个很明显，指定了要发布到哪个repo&lt;/li>
&lt;li>cname: &lt;a href="http://www.jonathanlin.top">www.jonathanlin.top&lt;/a> - 为jonlimx/blogs这个repo对应的Github Pages配置自定义域名&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>特别说明&lt;/strong>，如果基于上面这个配置，这个worklow会将markdown build出来的静态文件发布到jonlimx/blogs的&lt;strong>gh-pages&lt;/strong>分支，因此后面在配置Github Pages的时候要选个&lt;strong>gh-pages&lt;/strong>这个分支。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jonlimx/blogs@main/images/image-20210701103429278.png" alt="github-action">&lt;/p>
&lt;h2 id="配置github-pages">配置Github Pages&lt;/h2>
&lt;p>关于Github Pages的介绍请参考&lt;a href="https://docs.github.com/en/pages/getting-started-with-github-pages/about-github-pages">About GitHub Pages - GitHub Docs&lt;/a>。配置Github Pages比较简单。如下图所示，在Github上打开你的公开repo，参考下图红框部分配置，然后保存即可。这里有两点需要注意一下：&lt;/p>
&lt;ul>
&lt;li>分支这块我选的是gh-pages，这是因为我的Github Action跑完是把静态文件发布到jonlimx/blogs的gh-pages分支。
&lt;img src="https://cdn.jsdelivr.net/gh/jonlimx/blogs@main/images/image-20210630231109086.png" alt="github配置">&lt;/li>
&lt;li>路径是可选/(root)或者/docs。这二者的区别是你把这个repo都配置为Github Pages，还是说仅仅是/doc目录。这个在官方资料里有说明，请自行查阅。&lt;/li>
&lt;li>自定义域名这个是可选的。如果你跟我想配置自定义域名，请参考：&lt;a href="https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/about-custom-domains-and-github-pages">About custom domains and GitHub Pages - GitHub Docs&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>至此，基于Github Pages和Hugo的个人博客基本搭建完成。&lt;/p></description></item></channel></rss>